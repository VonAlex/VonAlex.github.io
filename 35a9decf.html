<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Redis 源码之启动流程"><meta name="keywords" content="redis"><meta name="author" content="Happen"><meta name="copyright" content="Happen"><title>Redis 源码之启动流程 | Happen's Memo</title><link rel="shortcut icon" href="/images/dolphin.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?882b48640075e00a238ae94a7eec0d40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,c,g,o){e.GoogleAnalyticsObject=c,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,g=a.createElement(t),o=a.getElementsByTagName(t)[0],g.async=1,g.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(g,o)}(window,document,"script",0,"ga"),ga("create","RRBput3V2WYVZd2lq058Z4IwJEhViOwuMElqkWh6bcA","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#大概启动流程"><span class="toc-number">1.</span> <span class="toc-text">大概启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#initServerConfig-函数"><span class="toc-number">1.1.</span> <span class="toc-text">initServerConfig 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#大部分成员赋初值"><span class="toc-number">1.1.1.</span> <span class="toc-text">大部分成员赋初值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#默认-rdb-触发条件"><span class="toc-number">1.1.2.</span> <span class="toc-text">默认 rdb 触发条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Replication-related"><span class="toc-number">1.1.3.</span> <span class="toc-text">Replication related</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Double-constants-initialization"><span class="toc-number">1.1.4.</span> <span class="toc-text">Double constants initialization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#client-output-buffer-limit"><span class="toc-number">1.1.5.</span> <span class="toc-text">client output buffer limit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-命令表"><span class="toc-number">1.1.6.</span> <span class="toc-text">redis 命令表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Slow-log"><span class="toc-number">1.1.7.</span> <span class="toc-text">Slow log</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinel-模式"><span class="toc-number">1.2.</span> <span class="toc-text">sentinel 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令行参数解析并载入配置文件"><span class="toc-number">1.3.</span> <span class="toc-text">命令行参数解析并载入配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initServer-函数"><span class="toc-number">1.4.</span> <span class="toc-text">initServer 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#信号处理"><span class="toc-number">1.4.1.</span> <span class="toc-text">信号处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#系统日志"><span class="toc-number">1.4.2.</span> <span class="toc-text">系统日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createSharedObjects-函数"><span class="toc-number">1.4.3.</span> <span class="toc-text">createSharedObjects 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#adjustOpenFilesLimit-函数"><span class="toc-number">1.4.4.</span> <span class="toc-text">adjustOpenFilesLimit 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建-eventLoop"><span class="toc-number">1.4.5.</span> <span class="toc-text">创建 eventLoop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化数据库对象"><span class="toc-number">1.4.6.</span> <span class="toc-text">初始化数据库对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#监听-port-端口"><span class="toc-number">1.4.7.</span> <span class="toc-text">监听 port 端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建系统-cron-定时器"><span class="toc-number">1.4.8.</span> <span class="toc-text">创建系统 cron 定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#监听-接收用户请求"><span class="toc-number">1.4.9.</span> <span class="toc-text">监听/接收用户请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cluster-初始化"><span class="toc-number">1.4.10.</span> <span class="toc-text">cluster 初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他环境初始化"><span class="toc-number">1.4.11.</span> <span class="toc-text">其他环境初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置进程名"><span class="toc-number">1.5.</span> <span class="toc-text">设置进程名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加载持久化数据"><span class="toc-number">1.6.</span> <span class="toc-text">加载持久化数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#loadAppendOnlyFile"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">loadAppendOnlyFile</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rdbLoad"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">rdbLoad</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件循环初始化"><span class="toc-number">1.7.</span> <span class="toc-text">事件循环初始化</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">2.</span> <span class="toc-text">小结</span></a></li></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.png"></div><div class="author-info__name text-center">Happen</div><div class="author-info__description text-center">记录那么学习和生活中遇到的什么</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">37</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://renrenlove.me/" target="_blank" rel="noopener">Galway</a><a class="author-info-links__name text-center" href="http://kvguru.com/" target="_blank" rel="noopener">Wangbin</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div id="page-header"> <span class="pull-left"><a id="site-name" href="/">Happen's Memo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Redis 源码之启动流程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a><div class="post-meta-wordcount"><span>字数总计:</span> <span class="word-count">1.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 7 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>说说 redis 的启动流程。</p><a id="more"></a><p>首先要找到<strong>启动函数</strong>，我们知道 C 程序从 <code>main</code> 函数开始，所以，就找到了“梦想”开始的地方 <code>server.c</code> -&gt; <code>main</code>。<br>这里主要讲启动过程中的主要部分，所以并不会一一涉及到。</p><h2 id="大概启动流程"><a href="#大概启动流程" class="headerlink" title="大概启动流程"></a>大概启动流程</h2><h3 id="initServerConfig-函数"><a href="#initServerConfig-函数" class="headerlink" title="initServerConfig 函数"></a>initServerConfig 函数</h3><p>整个代码中最重要的结构体莫过于 <code>struct redisServer server</code>，它以一个全局变量的形式出现。本函数主要是对它的成员进行赋值操作，这些成员基本上是可以通过 redis.conf 文件来配置。</p><h4 id="大部分成员赋初值"><a href="#大部分成员赋初值" class="headerlink" title="大部分成员赋初值"></a>大部分成员赋初值</h4><p>比如：</p><table><thead><tr><th>server 字段</th><th>含义</th></tr></thead><tbody><tr><td>runid</td><td>节点标识占用 40B</td></tr><tr><td>port</td><td>启动端口默认为 6379</td></tr><tr><td>tcp_backlog</td><td>默认 511B</td></tr><tr><td>aof_fsync</td><td>默认 aof 每秒刷盘，但是 aof 默认关闭</td></tr><tr><td>aof_filename</td><td>默认 aof 文件名为 appendonly.aof</td></tr><tr><td>rdb_filename</td><td>默认 rdb 文件名为 dump.rdb</td></tr><tr><td>cluster_node_timeout</td><td>默认 15s，默认 cluster 模式关闭</td></tr></tbody></table><h4 id="默认-rdb-触发条件"><a href="#默认-rdb-触发条件" class="headerlink" title="默认 rdb 触发条件"></a>默认 rdb 触发条件</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">appendServerSaveParams(<span class="number">60</span> * <span class="number">60</span>,<span class="number">1</span>);  <span class="comment">/* save after 1 hour and 1 change */</span></span><br><span class="line">appendServerSaveParams(<span class="number">300</span>,<span class="number">100</span>);    <span class="comment">/* save after 5 minutes and 100 changes */</span></span><br><span class="line">appendServerSaveParams(<span class="number">60</span>,<span class="number">10000</span>);   <span class="comment">/* save after 1 minute and 10000 changes */</span></span><br></pre></td></tr></table></figure><h4 id="Replication-related"><a href="#Replication-related" class="headerlink" title="Replication related"></a>Replication related</h4><p>包含对 backlog 的相关设置。</p><h4 id="Double-constants-initialization"><a href="#Double-constants-initialization" class="headerlink" title="Double constants initialization"></a>Double constants initialization</h4><p>浮点数据精度设置。</p><h4 id="client-output-buffer-limit"><a href="#client-output-buffer-limit" class="headerlink" title="client output buffer limit"></a>client output buffer limit</h4><p>一共有三种类型，如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clientBufferLimitsConfig clientBufferLimitsDefaults[CLIENT_TYPE_OBUF_COUNT] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,                         <span class="comment">/* normal */</span></span><br><span class="line">    &#123;<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">256</span>, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">64</span>, <span class="number">60</span>&#125;, <span class="comment">/* slave */</span></span><br><span class="line">    &#123;<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">32</span>, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">8</span>, <span class="number">60</span>&#125;    <span class="comment">/* pubsub */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="redis-命令表"><a href="#redis-命令表" class="headerlink" title="redis 命令表"></a>redis 命令表</h4><p>初始化 redis 命令表放到 <code>server.commands</code>中，这主要是在 <code>populateCommandTable</code> 函数中完成的。</p><p><strong>注意</strong>：考虑到在 redis.conf 配置文件中可以使用 rename-command 来对 Command 进行重命名（通常是为了安全考虑而禁用某些命令），因此命令表保存了<strong>两份</strong>，即 <code>server.commands</code> 和 <code>server.orig_commands</code>。</p><p>同时还对一些经常查询的命令单独提出来，分别放到以下变量中，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">delCommand</span>, *<span class="title">multiCommand</span>, *<span class="title">lpushCommand</span>, *<span class="title">lpopCommand</span>,</span></span><br><span class="line"><span class="class">                    *<span class="title">rpopCommand</span>, *<span class="title">sremCommand</span>, *<span class="title">execCommand</span>;</span></span><br></pre></td></tr></table></figure><h4 id="Slow-log"><a href="#Slow-log" class="headerlink" title="Slow log"></a>Slow log</h4><p>默认时间为 <strong>10ms</strong>。</p><h3 id="sentinel-模式"><a href="#sentinel-模式" class="headerlink" title="sentinel 模式"></a>sentinel 模式</h3><p>以下方式进行该模式的开启：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkForSentinelMode</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>],<span class="string">"redis-sentinel"</span>) != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[j],<span class="string">"--sentinel"</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令行参数 <code>--sentinel</code>，或者直接使用二进制文件 <code>redis-sentinel</code>。</p><p><strong>如果开启</strong>了该模式，那么进行相应的初始，没开启就跳过。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">    initSentinelConfig(); <span class="comment">// sentinel 默认端口 26379</span></span><br><span class="line">    initSentinel(); <span class="comment">// sentinel 变量赋初值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令行参数解析并载入配置文件"><a href="#命令行参数解析并载入配置文件" class="headerlink" title="命令行参数解析并载入配置文件"></a>命令行参数解析并载入配置文件</h3><p>主要还是获得配置文件的<strong>绝对路径</strong> <code>server.configfile = getAbsolutePath(configfile)</code>。</p><p>配置文件的载入有专门的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadServerConfig</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">char</span> *options)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>载入配置文件后，会覆盖之前对于 server 的某些默认配置。实际上，当 redis-server 启动后，一些配置可以通过 <code>config get</code> 命令查看，也可以通过 <code>config set</code> 命令进行修改，修改后 <code>config rewrite</code> 刷盘。</p><h3 id="initServer-函数"><a href="#initServer-函数" class="headerlink" title="initServer 函数"></a>initServer 函数</h3><p>不同于 <code>initServerConfig</code> 函数，该函数主要初始化一些 redis-server 运行中的成员。</p><h4 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h4><p>通过 redis 来复习下信号处理。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 忽略SIGHUP和SIGPIPE信号</span></span><br><span class="line">signal(SIGHUP, SIG_IGN);</span><br><span class="line">signal(SIGPIPE, SIG_IGN);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupSignalHandlers</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = sigShutdownHandler;</span><br><span class="line">    sigaction(SIGTERM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是程序退出的善后工作。</p><h4 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.syslog_enabled) &#123;</span><br><span class="line">    openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,</span><br><span class="line">            server.syslog_facility);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前提是使用到了系统的 rsyslog。</p><h4 id="createSharedObjects-函数"><a href="#createSharedObjects-函数" class="headerlink" title="createSharedObjects 函数"></a>createSharedObjects 函数</h4><p>该函数把一些常用的字符串保存起来，目的就是为了减少不断申请释放时CPU时间，内存碎片等等。</p><p>比如 <code>shared.ok = createObject(OBJ_STRING,sdsnew(&quot;+OK\r\n&quot;))</code>。</p><p><strong>额外说明的是</strong>，这里还初始化了一个很大的共享数字对象，0 到 999。因此在设置 value 时可以使用这些数字可以减少内存的使用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SHARED_INTEGERS 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; OBJ_SHARED_INTEGERS; j++) &#123; <span class="comment">// 10000 个数字</span></span><br><span class="line">    shared.integers[j] = createObject(OBJ_STRING,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)j);</span><br><span class="line">    shared.integers[j]-&gt;encoding = OBJ_ENCODING_INT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>struct sharedObjectsStruct shared</code> 也是一个全局变量。</p><h4 id="adjustOpenFilesLimit-函数"><a href="#adjustOpenFilesLimit-函数" class="headerlink" title="adjustOpenFilesLimit 函数"></a>adjustOpenFilesLimit 函数</h4><p>该函数根据配置文件中配置的最大 client 数量增大可以打开的最多文件数。</p><h4 id="创建-eventLoop"><a href="#创建-eventLoop" class="headerlink" title="创建 eventLoop"></a>创建 eventLoop</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR)</span><br></pre></td></tr></table></figure><p>这里假设 io 多路复用使用的是 epoll，这也是用的最多的。</p><h4 id="初始化数据库对象"><a href="#初始化数据库对象" class="headerlink" title="初始化数据库对象"></a>初始化数据库对象</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server.db = zmalloc(<span class="keyword">sizeof</span>(redisDb)*server.dbnum);</span><br></pre></td></tr></table></figure><p>数据库对象 <code>struct redisDb</code>，有 16 个。</p><h4 id="监听-port-端口"><a href="#监听-port-端口" class="headerlink" title="监听 port 端口"></a>监听 port 端口</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">    listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>监听 <code>server.port</code>，并把返回的 fd 存储在 <code>server.ipfd</code> 中，有报错就返回。</p><h4 id="创建系统-cron-定时器"><a href="#创建系统-cron-定时器" class="headerlink" title="创建系统 cron 定时器"></a>创建系统 cron 定时器</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">    serverPanic(<span class="string">"Can't create the serverCron time event."</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册定时时间，绑定回调函数 <code>serverCron</code>，在该函数中我们可以看到，执行周期为 <code>1000/server.hz</code> ms，因此每秒会执行<code>server.hz</code>（该值用户可配）。</p><p>那为什么是这个频率呢？redis 中对于事件处理在之前的一篇博客中写过，可以参考下 <a href="http://tech-happen.site/85f7b0b4.html" target="_blank" rel="noopener">Redis 中的事件</a>，这里也可以简单回顾下。</p><p>时间事件处理函数 <code>ae.c</code>-&gt; <code>processTimeEvents</code> 中，会根据时间事件的回调返回值来决定这时一个周期事件还是一次性事件，即</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    id = te-&gt;id;</span><br><span class="line">    retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</span><br><span class="line">    processed++;</span><br><span class="line">    <span class="keyword">if</span> (retval != AE_NOMORE) &#123;</span><br><span class="line">        aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        te-&gt;id = AE_DELETED_EVENT_ID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="监听-接收用户请求"><a href="#监听-接收用户请求" class="headerlink" title="监听/接收用户请求"></a>监听/接收用户请求</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE, <span class="comment">// 监听可读事件</span></span><br><span class="line">                          acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        serverPanic(</span><br><span class="line">            <span class="string">"Unrecoverable error creating server.ipfd file event."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收用户请求（用户连接会从这里进来），监听可读事件，注册回调函数 <code>acceptTcpHandler</code>。</p><h4 id="cluster-初始化"><a href="#cluster-初始化" class="headerlink" title="cluster 初始化"></a>cluster 初始化</h4><p>如果开启了 cluster mode，会进行相应的初始化。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.cluster_enabled) clusterInit();</span><br></pre></td></tr></table></figure><h4 id="其他环境初始化"><a href="#其他环境初始化" class="headerlink" title="其他环境初始化"></a>其他环境初始化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">replicationScriptCacheInit();</span><br><span class="line">scriptingInit(<span class="number">1</span>);</span><br><span class="line">slowlogInit();</span><br><span class="line">latencyMonitorInit();</span><br><span class="line">bioInit();</span><br></pre></td></tr></table></figure><h3 id="设置进程名"><a href="#设置进程名" class="headerlink" title="设置进程名"></a>设置进程名</h3><p>这个函数很实用的，方便 ps 看到良好格式的进程名。一起来复习下。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redisSetProcTitle</span><span class="params">(<span class="keyword">char</span> *title)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_SETPROCTITLE</span></span><br><span class="line">    <span class="keyword">char</span> *server_mode = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) server_mode = <span class="string">" [cluster]"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (server.sentinel_mode) server_mode = <span class="string">" [sentinel]"</span>;</span><br><span class="line"></span><br><span class="line">    setproctitle(<span class="string">"%s %s:%d%s"</span>,</span><br><span class="line">        title,</span><br><span class="line">        server.bindaddr_count ? server.bindaddr[<span class="number">0</span>] : <span class="string">"*"</span>,</span><br><span class="line">        server.port,</span><br><span class="line">        server_mode);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    UNUSED(title);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载持久化数据"><a href="#加载持久化数据" class="headerlink" title="加载持久化数据"></a>加载持久化数据</h3><p>如果不是以 sentinel 模式启动的，那么会加载持久化的数据，处理函数为 <code>loadDataFromDisk</code>。</p><p>如果开启了 aof，那么就加载 aof 文件，否则加载 rdb 文件。</p><h5 id="loadAppendOnlyFile"><a href="#loadAppendOnlyFile" class="headerlink" title="loadAppendOnlyFile"></a>loadAppendOnlyFile</h5><p>该函数用来记载 aof 文件，主要流程就是创建一个伪客户端，从 aof 文件中解析出来命令，让 server 重新执行一遍。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">'*'</span>) <span class="keyword">goto</span> fmterr;   <span class="comment">// 判断协议是否正确</span></span><br><span class="line"><span class="keyword">if</span> (buf[<span class="number">1</span>] == <span class="string">'\0'</span>) <span class="keyword">goto</span> readerr; <span class="comment">// 判断数据完整判断</span></span><br><span class="line">argc = atoi(buf+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">1</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line"></span><br><span class="line">argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*argc); <span class="comment">// argc 个 robj 对象</span></span><br><span class="line">fakeClient-&gt;argc = argc;</span><br><span class="line">fakeClient-&gt;argv = argv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fgets(buf,<span class="keyword">sizeof</span>(buf),fp) == <span class="literal">NULL</span>) &#123; <span class="comment">// 每行最多 128B</span></span><br><span class="line">        fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">        freeFakeClientArgv(fakeClient);</span><br><span class="line">        <span class="keyword">goto</span> readerr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">'$'</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line">    len = strtol(buf+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>); <span class="comment">// 命令的长度</span></span><br><span class="line">    argsds = sdsnewlen(<span class="literal">NULL</span>,len);</span><br><span class="line">    <span class="keyword">if</span> (len &amp;&amp; fread(argsds,len,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123;</span><br><span class="line">        sdsfree(argsds);</span><br><span class="line">        fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">        freeFakeClientArgv(fakeClient);</span><br><span class="line">        <span class="keyword">goto</span> readerr;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[j] = createObject(OBJ_STRING,argsds);</span><br><span class="line">    <span class="keyword">if</span> (fread(buf,<span class="number">2</span>,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123; <span class="comment">// \r\n</span></span><br><span class="line">        fakeClient-&gt;argc = j+<span class="number">1</span>; <span class="comment">/* Free up to j. */</span></span><br><span class="line">        freeFakeClientArgv(fakeClient);</span><br><span class="line">        <span class="keyword">goto</span> readerr; <span class="comment">/* discard CRLF */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmd = lookupCommand(argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line"><span class="keyword">if</span> (!cmd) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Unknown command '%s' reading the append only file"</span>, (<span class="keyword">char</span>*)argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 fakeClient 执行命令</span></span><br><span class="line">cmd-&gt;proc(fakeClient);</span><br></pre></td></tr></table></figure><p>以上函数就是 aof 文件解析过程。</p><p>附上一段 redis 协议数据，方便分析函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*<span class="number">3</span></span><br><span class="line">$<span class="number">3</span></span><br><span class="line">SET</span><br><span class="line">$<span class="number">2</span></span><br><span class="line">xx</span><br><span class="line">$<span class="number">2</span></span><br><span class="line">yy</span><br><span class="line">*<span class="number">3</span></span><br></pre></td></tr></table></figure><p> <strong>注意</strong>：在加载 aof 文件过程中，会暂时关闭 aof。</p><h5 id="rdbLoad"><a href="#rdbLoad" class="headerlink" title="rdbLoad"></a>rdbLoad</h5><p>该函数用来加载 rdb 文件。与 aof 加载不同的是，解析 rdb 文件后直接放入内存中。</p><h3 id="事件循环初始化"><a href="#事件循环初始化" class="headerlink" title="事件循环初始化"></a>事件循环初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进入事件循环之前执行 beforeSleep() 函数</span></span><br><span class="line">aeSetBeforeSleepProc(server.el,beforeSleep);</span><br><span class="line"><span class="comment">// 开始事件循环</span></span><br><span class="line">aeMain(server.el);</span><br><span class="line"><span class="comment">// 服务器关闭，删除事件循环</span></span><br><span class="line">aeDeleteEventLoop(server.el);</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>画了一个流程图，可以很好的体现以上流程。<br><img src="http://ww1.sinaimg.cn/large/71ca8e3cly1fxz66ssdg9j209a0pdac8.jpg" alt="redis server setup"></p></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="social-share" data-disabled="google,facebook,qzone,twitter,diandian,linkedin,qzone,tencent"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/c62267d.html"><i class="fa fa-chevron-left"></i><span>Redis 源码之 cluster meet</span></a></div><div class="next-post pull-right"><a href="/9ceee0f6.html"><span>Redis 源码之 Bio</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script>!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script></div></div></div><footer class="footer-bg" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;&nbsp;2016 - 2019 By Happen</div><div class="framework-info"><span>Powered by</span> <a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>