<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Redis 基本数据结构之 dict"><meta name="keywords" content="redis"><meta name="author" content="Happen"><meta name="copyright" content="Happen"><title>Redis 基本数据结构之 dict | Happen's Memo</title><link rel="shortcut icon" href="/images/dolphin.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?882b48640075e00a238ae94a7eec0d40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,c,g,o){e.GoogleAnalyticsObject=c,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,g=a.createElement(t),o=a.getElementsByTagName(t)[0],g.async=1,g.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(g,o)}(window,document,"script",0,"ga"),ga("create","RRBput3V2WYVZd2lq058Z4IwJEhViOwuMElqkWh6bcA","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#dict-的定义"><span class="toc-number">1.</span> <span class="toc-text">dict 的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希相关"><span class="toc-number">2.</span> <span class="toc-text">哈希相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#哈希函数"><span class="toc-number">2.1.</span> <span class="toc-text">哈希函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哈希冲突"><span class="toc-number">2.2.</span> <span class="toc-text">哈希冲突</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rehash"><span class="toc-number">3.</span> <span class="toc-text">rehash</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#是否需要-rehash"><span class="toc-number">3.1.</span> <span class="toc-text">是否需要 rehash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何-rehash"><span class="toc-number">3.2.</span> <span class="toc-text">如何 rehash</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#扩容操作"><span class="toc-number">3.2.1.</span> <span class="toc-text">扩容操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缩容操作"><span class="toc-number">3.2.2.</span> <span class="toc-text">缩容操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#渐进式-rehash"><span class="toc-number">3.2.3.</span> <span class="toc-text">渐进式 rehash</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数实现"><span class="toc-number">3.3.</span> <span class="toc-text">函数实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#创建-dict"><span class="toc-number">3.3.1.</span> <span class="toc-text">创建 dict</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#扩容-创建hash-table"><span class="toc-number">3.3.2.</span> <span class="toc-text">扩容/创建hash table</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#添加元素"><span class="toc-number">3.3.3.</span> <span class="toc-text">添加元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Replace-元素"><span class="toc-number">3.3.4.</span> <span class="toc-text">Replace 元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#删除元素"><span class="toc-number">3.3.5.</span> <span class="toc-text">删除元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#遍历元素"><span class="toc-number">3.3.6.</span> <span class="toc-text">遍历元素</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.png"></div><div class="author-info__name text-center">Happen</div><div class="author-info__description text-center">浮生若梦，为欢几何</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">37</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://renrenlove.me/" target="_blank" rel="noopener">Galway</a><a class="author-info-links__name text-center" href="http://kvguru.com/" target="_blank" rel="noopener">Wangbin</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div id="page-header"> <span class="pull-left"><a id="site-name" href="/">Happen's Memo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Redis 基本数据结构之 dict</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a><div class="post-meta-wordcount"><span>字数总计:</span> <span class="word-count">3.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 14 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote><p>字典，又称为符号表(symbol table)、关联数组(associative array)或者映射(map)，是一种用于保存键值对(key-value pair) 的抽象数据结构。</p></blockquote><p>dict 是一种非常常用的数据结构，因为 c 语言里没有内置这种数据结构，所以 redis 内部实现了自己的 dict 数据结构。</p><a id="more"></a><p>dict 在 redis 中被广泛使用，如 redis 的数据库就是使用 dict 来作为底层实现的，对数据库的增删改查操作也是构建在对 dict 的操作之上的。此外，dict 还是哈希键的底层实现之一。</p><p>redis 源码中关于 dict 的部分，主要在 <code>dict.h</code> 和 <code>dict.c</code> 这两个文件中。</p><h3 id="dict-的定义"><a href="#dict-的定义" class="headerlink" title="dict 的定义"></a>dict 的定义</h3><p>首先在 <code>dict.h</code> 中找到定义，主要分为以下三个部分：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;   <span class="comment">// 类型特定函数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;  <span class="comment">// 私有数据，保存着 dictType 结构中函数的参数</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];  <span class="comment">// 哈希表，2个</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* 标记 rehash 进度，没有的话为 -1 */</span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;  <span class="comment">// 哈希节点数组，一个个 hash 桶</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;  <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">// 哈希表大小掩码，计算索引值，= size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;  <span class="comment">// 该哈希表已有节点（ k-v 对 ）的数量</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 链表法解决 hash 冲突</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>将以上三个结构体使用如下图片进行表示，可能会更清楚一些。</p><p><img src="https://s1.ax1x.com/2018/09/08/iPRjfg.jpg" alt="redis-dict"></p><p><code>dict</code> 结构包含两个哈希表 <code>dictht</code>，每一个哈希表都有很多个哈希桶 <code>dictEntry</code>，<code>table</code> 是一个指针数组类型变量。每一个哈希桶是一个链表，以<strong>链表法</strong>解决哈希冲突问题。</p><p>一般情况下，只使用 <code>ht[0]</code>，当发生 rehash 的时候才会用到 <code>ht[1]</code>，此时 <code>rehashidx</code> 变量会记录 rehash 目前的进度，不进行 rehash 时，值为 -1。</p><p><code>dictType</code> 结构体定义了一些操作 <code>dict</code> 时要用到的函数指针。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;  <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key); <span class="comment">// 复制 key 的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj); <span class="comment">// 复制 val 的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2); <span class="comment">// 比较 key 的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key); <span class="comment">// 销毁 key 的析构函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj); <span class="comment">// 销毁 val 的析构函数</span></span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><p>定义了一些宏，可以更方便地使用这些函数指针，比如，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeVal(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;valDestructor((d)-&gt;privdata, (entry)-&gt;v.val)</span><br></pre></td></tr></table></figure><p>另外，还定义了一个 dict 迭代器</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d; <span class="comment">//被迭代的 dict</span></span><br><span class="line">    <span class="keyword">long</span> index; <span class="comment">//迭代器当前所指向的哈希表索引位置</span></span><br><span class="line">    <span class="comment">// table表示正迭代的哈希表号码，ht[0]或ht[1]。safe表示这个迭代器是否安全</span></span><br><span class="line">    <span class="keyword">int</span> table, safe;</span><br><span class="line">    <span class="comment">// entry指向当前迭代的哈希表节点，nextEntry 则指向当前节点的下一个节点</span></span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure><h3 id="哈希相关"><a href="#哈希相关" class="headerlink" title="哈希相关"></a>哈希相关</h3><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>我们知道，当要往 hash 表中插入元素的时候，必须要先计算相应 key 的 hash 值。</p><p>在 redis 中定义了三种哈希函数。</p><p>【1】Thomas Wang’s 32 bit Mix Function</p><p>【2】djb 哈希算法</p><p>【3】MurmurHash2，最新版本为 MurmurHash3</p><p>当字典被用作数据库的底层实现时，或者哈希 key 的底层实现时， redis 使用 MurmurHash2 算法来计算 key 的哈希值。</p><p>hash 值使用 hash 函数进行计算，然后与 <code>dictht</code> 的 <code>sizemask</code> 取模，就得到了哈希桶的索引。</p><h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>redis 使用链地址法解决哈希冲突。</p><p>因为 <code>dictEntry</code> 节点组成的链表没有指向链表表尾的指针，考虑到添加节点的成本，总是将新节点添加到链表的表头位置，使得复杂度从 <code>O(n)</code> 降低为 <code>O(1)</code>。</p><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>随着操作的不断执行，hash 表中保存的元素数量会动态变化，为了让哈希表的负载因子维持在一个合理的范围，需要对哈希表的大小多<strong>动态</strong>调整。</p><p>大小调整过程中就涉及到哈希桶的分拆或合并，这个过程叫做 rehash。</p><p>当负载因子过高时，产生 hash 冲突的几率就增大了，也就是说某些哈希桶中的链表会越来越长，这样时查找元素的时间复杂度趋于 <code>O(n)</code>，这个时候对 hash 表扩容。</p><p>否则，其中元素太小，浪费空间，就先释放，要用的话再申请。</p><h4 id="是否需要-rehash"><a href="#是否需要-rehash" class="headerlink" title="是否需要 rehash"></a>是否需要 rehash</h4><p>对于是否需要进行 rehash，有一个私有函数来尽进行判断。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 hash table 是看的，那么把它收缩成出初始化 size (= 4)</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].<span class="built_in">size</span> == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].<span class="built_in">size</span> &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].<span class="built_in">size</span> &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上函数自动判断的。</p><p>还有一个需要手动发起 rehash 的函数，用来对哈希表进行缩容操作。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minimal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 dict_can_resize = 0 或者 dict 正在做 rehash 时</span></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE) <span class="comment">// 小于 4 的话按照 4 来算</span></span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal); <span class="comment">// 用 minimal 调整字典 d 的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dict_can_resize</code> 这个变量做了标记，说明 server 在做 <code>BGSAVE</code> 命令或者 <code>BGREWRITEAOF</code>。</p><h4 id="如何-rehash"><a href="#如何-rehash" class="headerlink" title="如何 rehash"></a>如何 rehash</h4><h5 id="扩容操作"><a href="#扩容操作" class="headerlink" title="扩容操作"></a>扩容操作</h5><p>在 <code>ht[0].size == 0</code>时，即空哈希表，这时候把哈希表缩容到 size 为初始值 <strong>4</strong>。</p><p>在<code>used &gt; size</code> 的情况下，即这个时候肯定出现了哈希冲突，</p><p>如果允许 rehash，进行哈希表扩容操作，size 为 第一个 <strong>&gt;=</strong> <code>ht[0].used*2</code></p><p>即使不允许，在 <code>used:size &gt; 5</code>的情况下也必须做强制 rehash。</p><p>这时，新的哈希表，即 <code>ht[1]</code> 大小为第一个 &gt;= <code>ht[0].used*2</code>的 2 的 n 次幂。</p><h5 id="缩容操作"><a href="#缩容操作" class="headerlink" title="缩容操作"></a>缩容操作</h5><p>即执行上面的 <code>dictResize</code>操作，这个需要<strong>手动触发</strong>。</p><p><code>ht[1]</code> 大小为第一个 &gt;= <code>ht[0].used</code>的 2 的 n 次幂，最小不能小于 4。</p><p>根据计算得到的新哈希表的大小，为 <code>ht[1]</code>分配内存，将 <code>ht[0]</code> 上的数据都迁移到 <code>ht[1]</code>。</p><p>然后将原来 <code>ht[0]</code>的指针指向 <code>ht[1]</code>，释放旧的 <code>ht[0]</code> 内存，重置各个成员变量，留着下次备用。</p><h5 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h5><p>如果是一次性完成如上的 rehash 操作，那元素很多的话，可以预见，性能会很差。所以 redis 里采用了一个叫渐进式 rehash 的方案来做这件事情，把一次性要做的事情分为多步。</p><p> 主要由 <code>_dictRehashStep</code> 和 <code>dictRehashMilliseconds</code> 两个函数负责。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);<span class="comment">// 没有迭代器，进行1步rehash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dictRehashStep</code> 为被动 rehash ，每次只迁移一个哈希桶。dict 在做其他操作时会查询一下是不是在做 rehash，是的话，就会调用该函数。</p><p>如下：<br><img src="https://s1.ax1x.com/2018/09/09/iPzIIS.jpg" alt="dict-rehash"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();</span><br><span class="line">    <span class="keyword">int</span> rehashes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123; <span class="comment">// 直到 rehash 完或者时间到了</span></span><br><span class="line">        rehashes += <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rehashes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dictRehashMilliseconds</code> 在给定的<strong>毫秒</strong>时间内进行 rehash，每次步长为 100 个 hash 桶，返回值为 move 了多少个 哈希桶。它是在 redis 的 <code>serverCron</code> 里主动触发的，这是一个 1ms 的定时任务。</p><h4 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h4><p><strong>注意</strong>：</p><ul><li>因为在 rehash 时，字典会同时使用两个哈希表，所以在这期间的所有查找、删除等操作，除了在 <code>ht[0]</code> 上进行，还需要在 <code>ht[1]</code> 上进行。</li><li>在执行添加操作时，新的节点会直接添加到 <code>ht[1]</code> 而不是 <code>ht[0]</code> ，这样保证 <code>ht[0]</code> 的节点数量在整个 rehash 过程中都只减不增。</li></ul><h5 id="创建-dict"><a href="#创建-dict" class="headerlink" title="创建 dict"></a>创建 dict</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的 dict 结构</span></span><br><span class="line"><span class="function">dict *<span class="title">dictCreate</span><span class="params">(dictType *type, <span class="keyword">void</span> *privDataPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dict *d = zmalloc(<span class="keyword">sizeof</span>(*d)); <span class="comment">// 分配内存</span></span><br><span class="line">    _dictInit(d,type,privDataPtr);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize the hash table */</span></span><br><span class="line"><span class="keyword">int</span> _dictInit(dict *d, dictType *type,</span><br><span class="line">        <span class="keyword">void</span> *privDataPtr)</span><br><span class="line">&#123;</span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">0</span>]); <span class="comment">// 两个 hashtable 的初始化</span></span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">    d-&gt;type = type;</span><br><span class="line">    d-&gt;privdata = privDataPtr;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">-1</span>;  <span class="comment">// 初始化为 -1</span></span><br><span class="line">    d-&gt;iterators = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个 <code>dict</code>，主要就是分配内存，初始化变量。</p><h5 id="扩容-创建hash-table"><a href="#扩容-创建hash-table" class="headerlink" title="扩容/创建hash table"></a>扩容/创建hash table</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictht n; <span class="comment">// 新的 dictht，用于替换</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 dict 正在 rehash 或者 size 小于现在的 ht[0].used，说明这个 size 是不合法的，返回错误 DICT_ERR</span></span><br><span class="line">    <span class="comment">// 要包含现在 dict 所有元素，那么 size 一定要 &gt;= ht[0].used</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; <span class="built_in">size</span>)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要 rehash 的 dictht 大小跟现在 dictht 大小相等，就没必要做 rehash 了，返回错误 DICT_ERR</span></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].<span class="built_in">size</span>) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    n.<span class="built_in">size</span> = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是第一次初始化吗？如果真是这样，那这就不是一个 rehash</span></span><br><span class="line">    <span class="comment">// 仅设置第一个 hash 表，以便接收 keys</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非首次初始化，那就设置第二个 hash 表，设置 rehashidx 标记，</span></span><br><span class="line">    <span class="comment">// 现在可以进行 rehash 了</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>; <span class="comment">// rehash 进度为 0</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *entry = dictAddRaw(d,key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dictAddRaw</code>函数只是增加了 key，而 value 需要 key 增加成功后再次设置。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否在 rehash</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获得这个新元素需要加到哪个 hash 桶，</span></span><br><span class="line"><span class="comment">     * 若返回 -1 表示已经存在这个 key 了，直接返回 NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为新的 key 分配内存并存到 ht 中</span></span><br><span class="line"><span class="comment">     * 把新的 key 放到 hash 桶里 list 的第一个，假定在数据库系统中新加入的 key 会更频繁访问到，这会减少查询时间</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">// dict 在做 rehash 的话，直接把新 key 加到 ht[1]，否则加到 ht[0]</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    dictSetKey(d, entry, key); <span class="comment">// 为 key 设置 value</span></span><br><span class="line">    <span class="keyword">return</span> entry; <span class="comment">// 返回新加入的 entry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Replace-元素"><a href="#Replace-元素" class="headerlink" title="Replace 元素"></a>Replace 元素</h5><p>这里有两个函数 <code>dictReplace</code> 和 <code>dictReplaceRaw</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *entry, auxentry;</span><br><span class="line">    <span class="comment">// 要添加的 key 在 dict 中不存在，那么直接添加成功</span></span><br><span class="line">    <span class="keyword">if</span> (dictAdd(d, key, val) == DICT_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 运行到这里，说明键 key 已经存在，找到它</span></span><br><span class="line">    entry = dictFind(d, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的 value，释放旧的。</span></span><br><span class="line">    auxentry = *entry;</span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    dictFreeVal(d, &amp;auxentry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictReplaceRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    dictEntry *entry = dictFind(d,key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回已经存在的 key ，或者新加的</span></span><br><span class="line">    <span class="keyword">return</span> entry ? entry : dictAddRaw(d,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDeleteNoFree</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个函数的区别在于删除 key 的时候是否调用 key 和 value 的释放函数。而真正的删除函数是 <code>dictGenericDelete</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dictGenericDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> nofree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx;</span><br><span class="line">    dictEntry *he, *prevHe;</span><br><span class="line">    <span class="keyword">int</span> table;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* d-&gt;ht[0].table is NULL */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].<span class="built_in">size</span> == <span class="number">0</span>) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d); <span class="comment">// 执行渐进式 rehash</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        prevHe = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123; <span class="comment">// 找到这个 key</span></span><br><span class="line">                <span class="keyword">if</span> (prevHe) <span class="comment">// 是不是该 hash slot 的第一个元素</span></span><br><span class="line">                    prevHe-&gt;next = he-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!nofree) &#123;</span><br><span class="line">                    dictFreeKey(d, he);</span><br><span class="line">                    dictFreeVal(d, he);</span><br><span class="line">                &#125;</span><br><span class="line">                zfree(he);</span><br><span class="line">                d-&gt;ht[table].used--;</span><br><span class="line">                <span class="keyword">return</span> DICT_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            prevHe = he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_ERR; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h5><p><code>dictScan</code> 这个函数是 <code>dict</code> 结构最有特色的一个函数。用来遍历 <code>dict</code>，主要是要考虑扩缩容的情况。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">long</span> v,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanFunction *fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *privdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictht *t0, *t1;</span><br><span class="line">    <span class="keyword">const</span> dictEntry *de;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> m0, m1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) &#123; <span class="comment">// 不在 rehash，直接扫描 ht[0] 就好了</span></span><br><span class="line">        t0 = &amp;(d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123; <span class="comment">// 扫描完这个 slot，因为可能是链表</span></span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = de-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 正在rehashing，就存在两个哈希表ht[0]、ht[1]</span></span><br><span class="line">        t0 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        t1 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保 t0 比 t1 小</span></span><br><span class="line">        <span class="keyword">if</span> (t0-&gt;<span class="built_in">size</span> &gt; t1-&gt;<span class="built_in">size</span>) &#123;</span><br><span class="line">            t0 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">            t1 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line">        m1 = t1-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        de = t0-&gt;table[v &amp; m0];<span class="comment">// 扫描 t0 的某个 slot</span></span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = de-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代(大表)t1 中所有节点，循环迭代，会把小表没有覆盖的slot全部扫描一遍</span></span><br><span class="line">        <span class="comment">// 同模的 slot</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">            de = t1-&gt;table[v &amp; m1];</span><br><span class="line">            <span class="keyword">while</span> (de) &#123;</span><br><span class="line">                fn(privdata, de);</span><br><span class="line">                de = de-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Increment bits not covered by the smaller mask */</span></span><br><span class="line">            <span class="comment">// 新增加的bits 位每次加一</span></span><br><span class="line">            v = (((v | m0) + <span class="number">1</span>) &amp; ~m0) | (v &amp; m0);</span><br><span class="line">        &#125; <span class="keyword">while</span> (v &amp; (m0 ^ m1)); <span class="comment">// 直到新加的 bits 都遍处理完了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v |= ~m0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Increment the reverse cursor */</span></span><br><span class="line">    v = rev(v);</span><br><span class="line">    v++;</span><br><span class="line">    v = rev(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis 采用了一种高位进位的方式来遍历哈希桶，而不是传统的加1。以 size 为8为例，遍历顺序是这样的：000 -&gt; 100 -&gt; 010 -&gt; 110 -&gt; 001 -&gt; 101 -&gt; 011 -&gt; 111。可以看到，每次都是最到位加1，向低位去进位，正好跟我们平常的运算相反，因此，这也叫<strong>反向二进制位迭代</strong>。</p><p>具体原理可以参考 <a href="https://tech.meituan.com/Redis_Rehash_Practice_Optimization.html" target="_blank" rel="noopener">《美团针对Redis Rehash机制的探索和实践》</a>，同时该文章也指出了该算法的一个 bug，并提供的修复方案。</p></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="social-share" data-disabled="google,facebook,qzone,twitter,diandian,linkedin,qzone,tencent"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/9ceee0f6.html"><i class="fa fa-chevron-left"></i><span>Redis 源码之 Bio</span></a></div><div class="next-post pull-right"><a href="/85f7b0b4.html"><span>Redis 中的事件</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script>!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script></div></div></div><footer class="footer-bg" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;&nbsp;2016 - 2019 By Happen</div><div class="framework-info"><span>Powered by</span> <a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>