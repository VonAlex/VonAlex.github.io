<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/dolphin.png"><link rel="icon" type="image/png" href="/images/dolphin.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="Happen"><meta name="keywords" content=""><title>Redis 基本数据结构之 dict - Happen&#39;s Memo</title><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css"><link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"><link rel="stylesheet" href="/css/main.css"><link defer="defer" rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="/css/custom.css"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"> <a class="navbar-brand" href="/">&nbsp;<strong>Happen's Memo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="fa fa-home" aria-hidden="true"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="fa fa-archive" aria-hidden="true"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="fa fa-map-signs" aria-hidden="true"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="fa fa-tags" aria-hidden="true"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="fa fa-child" aria-hidden="true"></i> 关于</a></li><li class="nav-item" id="search-btn"> <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" parallax="true" style="background:url(/images/about-banner.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask rgba-black-light flex-center"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><p class="mt-3 post-meta"><i class="fas fa-calendar-alt" aria-hidden="true"></i> 2018/09/08, 星期六, 14:04</p><p class="mt-1"><span class="post-meta"><i class="far fa-chart-bar"></i> 3.3k 字</span><span class="post-meta"><i class="far fa-clock"></i> 14 分钟</span><span id="busuanzi_container_page_pv" class="post-meta" style="display:none"><i class="far fa-eye" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span> 次</span></p></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5 z-depth-3" id="board"><div class="post-content mx-auto" id="post"><p class="note note-warning">本文最后更新于：2020/04/03, 星期五, 01:47</p><div class="markdown-body"><blockquote><p>字典，又称为符号表 (symbol table)、关联数组(associative array) 或者映射(map)，是一种用于保存键值对(key-value pair) 的抽象数据结构。</p></blockquote><p>dict 是一种非常常用的数据结构，因为 c 语言里没有内置这种数据结构，所以 redis 内部实现了自己的 dict 数据结构。</p><a id="more"></a><p>dict 在 redis 中被广泛使用，如 redis 的数据库就是使用 dict 来作为底层实现的，对数据库的增删改查操作也是构建在对 dict 的操作之上的。此外，dict 还是哈希键的底层实现之一。</p><p>redis 源码中关于 dict 的部分，主要在 <code>dict.h</code> 和 <code>dict.c</code> 这两个文件中。</p><h3 id="dict- 的定义">dict 的定义</h3><p>首先在 <code>dict.h</code> 中找到定义，主要分为以下三个部分：</p><pre><code class="language-c">typedef struct dict {
    dictType *type;   // 类型特定函数
    void *privdata;  // 私有数据，保存着 dictType 结构中函数的参数
    dictht ht[2];  // 哈希表，2 个
    long rehashidx; /* 标记 rehash 进度，没有的话为 -1 */
    int iterators; /* number of iterators currently running */
} dict;
</code></pre><pre><code class="language-c">typedef struct dictht {
    dictEntry **table;  // 哈希节点数组，一个个 hash 桶
    unsigned long size;  // 哈希表大小
    unsigned long sizemask; // 哈希表大小掩码，计算索引值，= size-1
    unsigned long used;  // 该哈希表已有节点（ k-v 对 ）的数量
} dictht;
</code></pre><pre><code class="language-c">typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next; // 链表法解决 hash 冲突
} dictEntry;
</code></pre><p>将以上三个结构体使用如下图片进行表示，可能会更清楚一些。</p><p><img src="https://s1.ax1x.com/2018/09/08/iPRjfg.jpg" srcset="/img/loading.gif" alt="redis-dict"></p><p><code>dict</code> 结构包含两个哈希表 <code>dictht</code>，每一个哈希表都有很多个哈希桶 <code>dictEntry</code>，<code>table</code> 是一个指针数组类型变量。每一个哈希桶是一个链表，以 <strong>链表法</strong> 解决哈希冲突问题。</p><p>一般情况下，只使用 <code>ht[0]</code>，当发生 rehash 的时候才会用到 <code>ht[1]</code>，此时 <code>rehashidx</code> 变量会记录 rehash 目前的进度，不进行 rehash 时，值为 -1。</p><p><code>dictType</code> 结构体定义了一些操作 <code>dict</code> 时要用到的函数指针。</p><pre><code class="language-c">typedef struct dictType {unsigned int (*hashFunction)(const void *key);  // 计算哈希值的函数
    void *(*keyDup)(void *privdata, const void *key); // 复制 key 的函数
    void *(*valDup)(void *privdata, const void *obj); // 复制 val 的函数
    int (*keyCompare)(void *privdata, const void *key1, const void *key2); // 比较 key 的函数
    void (*keyDestructor)(void *privdata, void *key); // 销毁 key 的析构函数
    void (*valDestructor)(void *privdata, void *obj); // 销毁 val 的析构函数
} dictType;
</code></pre><p>定义了一些宏，可以更方便地使用这些函数指针，比如，</p><pre><code class="language-c">#define dictFreeVal(d, entry) \
    if ((d)-&gt;type-&gt;valDestructor) \
        (d)-&gt;type-&gt;valDestructor((d)-&gt;privdata, (entry)-&gt;v.val)
</code></pre><p>另外，还定义了一个 dict 迭代器</p><pre><code class="language-c">typedef struct dictIterator {
    dict *d; // 被迭代的 dict
    long index; // 迭代器当前所指向的哈希表索引位置
    // table 表示正迭代的哈希表号码，ht[0]或 ht[1]。safe 表示这个迭代器是否安全
    int table, safe;
    // entry 指向当前迭代的哈希表节点，nextEntry 则指向当前节点的下一个节点
    dictEntry *entry, *nextEntry;
    /* unsafe iterator fingerprint for misuse detection. */
    long long fingerprint;
} dictIterator;
</code></pre><h3 id="哈希相关">哈希相关</h3><h4 id="哈希函数">哈希函数</h4><p>我们知道，当要往 hash 表中插入元素的时候，必须要先计算相应 key 的 hash 值。</p><p>在 redis 中定义了三种哈希函数。</p><p>【1】Thomas Wang’s 32 bit Mix Function</p><p>【2】djb 哈希算法</p><p>【3】MurmurHash2，最新版本为 MurmurHash3</p><p>当字典被用作数据库的底层实现时，或者哈希 key 的底层实现时， redis 使用 MurmurHash2 算法来计算 key 的哈希值。</p><p>hash 值使用 hash 函数进行计算，然后与 <code>dictht</code> 的 <code>sizemask</code> 取模，就得到了哈希桶的索引。</p><h4 id="哈希冲突">哈希冲突</h4><p>redis 使用链地址法解决哈希冲突。</p><p>因为 <code>dictEntry</code> 节点组成的链表没有指向链表表尾的指针，考虑到添加节点的成本，总是将新节点添加到链表的表头位置，使得复杂度从 <code>O(n)</code> 降低为 <code>O(1)</code>。</p><h3 id="rehash">rehash</h3><p>随着操作的不断执行，hash 表中保存的元素数量会动态变化，为了让哈希表的负载因子维持在一个合理的范围，需要对哈希表的大小多 <strong>动态</strong> 调整。</p><p>大小调整过程中就涉及到哈希桶的分拆或合并，这个过程叫做 rehash。</p><p>当负载因子过高时，产生 hash 冲突的几率就增大了，也就是说某些哈希桶中的链表会越来越长，这样时查找元素的时间复杂度趋于 <code>O(n)</code>，这个时候对 hash 表扩容。</p><p>否则，其中元素太小，浪费空间，就先释放，要用的话再申请。</p><h4 id="是否需要 -rehash">是否需要 rehash</h4><p>对于是否需要进行 rehash，有一个私有函数来尽进行判断。</p><pre><code class="language-c">static int _dictExpandIfNeeded(dict *d)
{
    /* Incremental rehashing already in progress. Return. */
    if (dictIsRehashing(d)) return DICT_OK;


    // 如果 hash table 是看的，那么把它收缩成出初始化 size (= 4)
    if (d-&gt;ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);

    if (d-&gt;ht[0].used &gt;= d-&gt;ht[0].size &amp;&amp;
        (dict_can_resize ||
         d-&gt;ht[0].used/d-&gt;ht[0].size &gt; dict_force_resize_ratio))
    {return dictExpand(d, d-&gt;ht[0].used*2);
    }
    return DICT_OK;
}
</code></pre><p>以上函数自动判断的。</p><p>还有一个需要手动发起 rehash 的函数，用来对哈希表进行缩容操作。</p><pre><code class="language-c">int dictResize(dict *d)
{
    int minimal;

    // 当 dict_can_resize = 0 或者 dict 正在做 rehash 时
    if (!dict_can_resize || dictIsRehashing(d)) return DICT_ERR;
    minimal = d-&gt;ht[0].used;
    if (minimal &lt; DICT_HT_INITIAL_SIZE) // 小于 4 的话按照 4 来算
        minimal = DICT_HT_INITIAL_SIZE;
    return dictExpand(d, minimal); // 用 minimal 调整字典 d 的大小
}
</code></pre><p><code>dict_can_resize</code> 这个变量做了标记，说明 server 在做 <code>BGSAVE</code> 命令或者 <code>BGREWRITEAOF</code>。</p><h4 id="如何 -rehash">如何 rehash</h4><h5 id="扩容操作">扩容操作</h5><p>在 <code>ht[0].size == 0</code>时，即空哈希表，这时候把哈希表缩容到 size 为初始值 <strong>4</strong>。</p><p>在<code>used &gt; size</code> 的情况下，即这个时候肯定出现了哈希冲突，</p><p>如果允许 rehash，进行哈希表扩容操作，size 为 第一个 <strong>&gt;=</strong> <code>ht[0].used*2</code></p><p>即使不允许，在 <code>used:size &gt; 5</code>的情况下也必须做强制 rehash。</p><p>这时，新的哈希表，即 <code>ht[1]</code> 大小为第一个 &gt;= <code>ht[0].used*2</code>的 2 的 n 次幂。</p><h5 id="缩容操作">缩容操作</h5><p>即执行上面的 <code>dictResize</code>操作，这个需要 <strong>手动触发</strong>。</p><p><code>ht[1]</code> 大小为第一个 &gt;= <code>ht[0].used</code>的 2 的 n 次幂，最小不能小于 4。</p><p>根据计算得到的新哈希表的大小，为 <code>ht[1]</code>分配内存，将 <code>ht[0]</code> 上的数据都迁移到 <code>ht[1]</code>。</p><p>然后将原来 <code>ht[0]</code>的指针指向 <code>ht[1]</code>，释放旧的 <code>ht[0]</code> 内存，重置各个成员变量，留着下次备用。</p><h5 id="渐进式 -rehash">渐进式 rehash</h5><p>如果是一次性完成如上的 rehash 操作，那元素很多的话，可以预见，性能会很差。所以 redis 里采用了一个叫渐进式 rehash 的方案来做这件事情，把一次性要做的事情分为多步。</p><p>主要由 <code>_dictRehashStep</code> 和 <code>dictRehashMilliseconds</code> 两个函数负责。</p><pre><code class="language-c">static void _dictRehashStep(dict *d) {if (d-&gt;iterators == 0) dictRehash(d,1);// 没有迭代器，进行 1 步 rehash
}
</code></pre><p><code>_dictRehashStep</code> 为被动 rehash ，每次只迁移一个哈希桶。dict 在做其他操作时会查询一下是不是在做 rehash，是的话，就会调用该函数。</p><p>如下：<br> <img src="https://s1.ax1x.com/2018/09/09/iPzIIS.jpg" srcset="/img/loading.gif" alt="dict-rehash"></p><pre><code class="language-c">int dictRehashMilliseconds(dict *d, int ms) {long long start = timeInMilliseconds();
    int rehashes = 0;

    while(dictRehash(d,100)) { // 直到 rehash 完或者时间到了
        rehashes += 100;
        if (timeInMilliseconds()-start &gt; ms) break;
    }
    return rehashes;
}
</code></pre><p><code>dictRehashMilliseconds</code> 在给定的 <strong>毫秒</strong> 时间内进行 rehash，每次步长为 100 个 hash 桶，返回值为 move 了多少个 哈希桶。它是在 redis 的 <code>serverCron</code> 里主动触发的，这是一个 1ms 的定时任务。</p><h4 id="函数实现">函数实现</h4><p><strong>注意</strong>：</p><ul><li>因为在 rehash 时，字典会同时使用两个哈希表，所以在这期间的所有查找、删除等操作，除了在 <code>ht[0]</code> 上进行，还需要在 <code>ht[1]</code> 上进行。</li><li>在执行添加操作时，新的节点会直接添加到 <code>ht[1]</code> 而不是 <code>ht[0]</code> ，这样保证 <code>ht[0]</code> 的节点数量在整个 rehash 过程中都只减不增。</li></ul><h5 id="创建 -dict">创建 dict</h5><pre><code class="language-c">// 创建一个新的 dict 结构
dict *dictCreate(dictType *type, void *privDataPtr)
{dict *d = zmalloc(sizeof(*d)); // 分配内存
    _dictInit(d,type,privDataPtr);
    return d;
}

/* Initialize the hash table */
int _dictInit(dict *d, dictType *type,
        void *privDataPtr)
{_dictReset(&amp;d-&gt;ht[0]); // 两个 hashtable 的初始化
    _dictReset(&amp;d-&gt;ht[1]);
    d-&gt;type = type;
    d-&gt;privdata = privDataPtr;
    d-&gt;rehashidx = -1;  // 初始化为 -1
    d-&gt;iterators = 0;
    return DICT_OK;
}
</code></pre><p>创建一个 <code>dict</code>，主要就是分配内存，初始化变量。</p><h5 id="扩容 - 创建 hash-table">扩容 / 创建 hash table</h5><pre><code class="language-c">int dictExpand(dict *d, unsigned long size)
{
    dictht n; // 新的 dictht，用于替换
    unsigned long realsize = _dictNextPower(size);

    // 当 dict 正在 rehash 或者 size 小于现在的 ht[0].used，说明这个 size 是不合法的，返回错误 DICT_ERR
    // 要包含现在 dict 所有元素，那么 size 一定要 &gt;= ht[0].used
    if (dictIsRehashing(d) || d-&gt;ht[0].used &gt; size)
        return DICT_ERR;

    // 要 rehash 的 dictht 大小跟现在 dictht 大小相等，就没必要做 rehash 了，返回错误 DICT_ERR
    if (realsize == d-&gt;ht[0].size) return DICT_ERR;

    n.size = realsize;
    n.sizemask = realsize-1;
    n.table = zcalloc(realsize*sizeof(dictEntry*));
    n.used = 0;

    // 这是第一次初始化吗？如果真是这样，那这就不是一个 rehash
    // 仅设置第一个 hash 表，以便接收 keys
    if (d-&gt;ht[0].table == NULL) {d-&gt;ht[0] = n;
        return DICT_OK;
    }

    // 非首次初始化，那就设置第二个 hash 表，设置 rehashidx 标记，
    // 现在可以进行 rehash 了
    d-&gt;ht[1] = n;
    d-&gt;rehashidx = 0; // rehash 进度为 0
    return DICT_OK;
}
</code></pre><h5 id="添加元素">添加元素</h5><pre><code class="language-c">int dictAdd(dict *d, void *key, void *val)
{dictEntry *entry = dictAddRaw(d,key);

    if (!entry) return DICT_ERR;
    dictSetVal(d, entry, val);
    return DICT_OK;
}
</code></pre><p><code>dictAddRaw</code> 函数只是增加了 key，而 value 需要 key 增加成功后再次设置。</p><pre><code class="language-c">dictEntry *dictAddRaw(dict *d, void *key)
{
    int index;
    dictEntry *entry;
    dictht *ht;

    // 检查是否在 rehash
    if (dictIsRehashing(d)) _dictRehashStep(d);

    /* 获得这个新元素需要加到哪个 hash 桶，
     * 若返回 -1 表示已经存在这个 key 了，直接返回 NULL
     */
    if ((index = _dictKeyIndex(d, key)) == -1)
        return NULL;

    /* 为新的 key 分配内存并存到 ht 中
     * 把新的 key 放到 hash 桶里 list 的第一个，假定在数据库系统中新加入的 key 会更频繁访问到，这会减少查询时间
     * */
    // dict 在做 rehash 的话，直接把新 key 加到 ht[1]，否则加到 ht[0]
    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0];
    entry = zmalloc(sizeof(*entry));
    entry-&gt;next = ht-&gt;table[index];
    ht-&gt;table[index] = entry;
    ht-&gt;used++;

    dictSetKey(d, entry, key); // 为 key 设置 value
    return entry; // 返回新加入的 entry
}
</code></pre><h5 id="Replace- 元素">Replace 元素</h5><p>这里有两个函数 <code>dictReplace</code> 和 <code>dictReplaceRaw</code>。</p><pre><code class="language-c">int dictReplace(dict *d, void *key, void *val)
{
    dictEntry *entry, auxentry;
    // 要添加的 key 在 dict 中不存在，那么直接添加成功
    if (dictAdd(d, key, val) == DICT_OK)
        return 1;

   // 运行到这里，说明键 key 已经存在，找到它
    entry = dictFind(d, key);

    // 设置新的 value，释放旧的。
    auxentry = *entry;
    dictSetVal(d, entry, val);
    dictFreeVal(d, &amp;auxentry);
    return 0;
}
</code></pre><pre><code class="language-c">dictEntry *dictReplaceRaw(dict *d, void *key) {dictEntry *entry = dictFind(d,key);

    // 返回已经存在的 key ，或者新加的
    return entry ? entry : dictAddRaw(d,key);
}
</code></pre><h5 id="删除元素">删除元素</h5><pre><code class="language-c">int dictDelete(dict *ht, const void *key) {return dictGenericDelete(ht,key,0);
}

int dictDeleteNoFree(dict *ht, const void *key) {return dictGenericDelete(ht,key,1);
}
</code></pre><p>上面两个函数的区别在于删除 key 的时候是否调用 key 和 value 的释放函数。而真正的删除函数是 <code>dictGenericDelete</code>。</p><pre><code class="language-c">static int dictGenericDelete(dict *d, const void *key, int nofree)
{
    unsigned int h, idx;
    dictEntry *he, *prevHe;
    int table;

     /* d-&gt;ht[0].table is NULL */
    if (d-&gt;ht[0].size == 0) return DICT_ERR;
    if (dictIsRehashing(d)) _dictRehashStep(d); // 执行渐进式 rehash
    h = dictHashKey(d, key);

    for (table = 0; table &lt;= 1; table++) {idx = h &amp; d-&gt;ht[table].sizemask;
        he = d-&gt;ht[table].table[idx];
        prevHe = NULL;
        while(he) {if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) { // 找到这个 key
                if (prevHe) // 是不是该 hash slot 的第一个元素
                    prevHe-&gt;next = he-&gt;next;
                else
                    d-&gt;ht[table].table[idx] = he-&gt;next;
                if (!nofree) {dictFreeKey(d, he);
                    dictFreeVal(d, he);
                }
                zfree(he);
                d-&gt;ht[table].used--;
                return DICT_OK;
            }
            prevHe = he;
            he = he-&gt;next;
        }
        if (!dictIsRehashing(d)) break;
    }
    return DICT_ERR; /* not found */
}
</code></pre><h5 id="遍历元素">遍历元素</h5><p><code>dictScan</code> 这个函数是 <code>dict</code> 结构最有特色的一个函数。用来遍历 <code>dict</code>，主要是要考虑扩缩容的情况。</p><pre><code class="language-c">unsigned long dictScan(dict *d,
                       unsigned long v,
                       dictScanFunction *fn,
                       void *privdata)
{
    dictht *t0, *t1;
    const dictEntry *de;
    unsigned long m0, m1;

    if (dictSize(d) == 0) return 0;

    if (!dictIsRehashing(d)) {// 不在 rehash，直接扫描 ht[0] 就好了
        t0 = &amp;(d-&gt;ht[0]);
        m0 = t0-&gt;sizemask;

        /* Emit entries at cursor */
        de = t0-&gt;table[v &amp; m0];
        while (de) { // 扫描完这个 slot，因为可能是链表
            fn(privdata, de);
            de = de-&gt;next;
        }

    } else {// 正在 rehashing，就存在两个哈希表 ht[0]、ht[1]
        t0 = &amp;d-&gt;ht[0];
        t1 = &amp;d-&gt;ht[1];

        // 确保 t0 比 t1 小
        if (t0-&gt;size &gt; t1-&gt;size) {t0 = &amp;d-&gt;ht[1];
            t1 = &amp;d-&gt;ht[0];
        }

        m0 = t0-&gt;sizemask;
        m1 = t1-&gt;sizemask;

        de = t0-&gt;table[v &amp; m0];// 扫描 t0 的某个 slot
        while (de) {fn(privdata, de);
            de = de-&gt;next;
        }

        // 迭代(大表)t1 中所有节点，循环迭代，会把小表没有覆盖的 slot 全部扫描一遍
        // 同模的 slot
        do {
            /* Emit entries at cursor */
            de = t1-&gt;table[v &amp; m1];
            while (de) {fn(privdata, de);
                de = de-&gt;next;
            }

            /* Increment bits not covered by the smaller mask */
            // 新增加的 bits 位每次加一
            v = (((v | m0) + 1) &amp; ~m0) | (v &amp; m0);
        } while (v &amp; (m0 ^ m1)); // 直到新加的 bits 都遍处理完了
    }

    v |= ~m0;

    /* Increment the reverse cursor */
    v = rev(v);
    v++;
    v = rev(v);

    return v;
}
</code></pre><p>redis 采用了一种高位进位的方式来遍历哈希桶，而不是传统的加 1。以 size 为 8 为例，遍历顺序是这样的：000 -&gt; 100 -&gt; 010 -&gt; 110 -&gt; 001 -&gt; 101 -&gt; 011 -&gt; 111。可以看到，每次都是最到位加 1，向低位去进位，正好跟我们平常的运算相反，因此，这也叫 <strong>反向二进制位迭代</strong>。</p><p>具体原理可以参考 <a href="https://tech.meituan.com/Redis_Rehash_Practice_Optimization.html" target="_blank" rel="noopener">《美团针对 Redis Rehash 机制的探索和实践》</a>，同时该文章也指出了该算法的一个 bug，并提供的修复方案。</p></div><hr><div><p><span><i class="iconfont icon-inbox"></i> <a class="hover-with-bg" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a> &nbsp;</span> &nbsp;&nbsp;<span><i class="iconfont icon-tag"></i> <a class="hover-with-bg" href="/tags/redis/">redis</a></span></p><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="post-prevnext row"><div class="post-prev col-6"><a href="/9ceee0f6.html"><i class="fa fa-chevron-left"></i> <span class="hidden-mobile">Redis 源码之 Bio</span> <span class="visible-mobile">上一篇</span></a></div><div class="post-next col-6"> <a href="/85f7b0b4.html"><span class="hidden-mobile">Redis 中的事件</span> <span class="visible-mobile">下一篇</span><i class="fa fa-chevron-right"></i></a></div></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script type="text/javascript">!function(e,t){var r,n=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((r=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",r.defer=!0,n.parentNode.insertBefore(r,n))}(document,"script")</script><noscript> 为正常使用来必力评论功能请激活JavaScript</noscript></div></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc-start"></div><div id="toc"><p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-md"><div class="container custom post-content mx-auto"> <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px;height:150px"></div></div></main><a class="z-depth-1" id="scroll-top-button" href="#" role="button"><i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4> <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"> <span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"> <input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a><i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><b>Fluid</b></a></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script><script>$(document).ready(function(){var s=$("#navbar").height(),c=$("#toc"),t=$("#board-ctn"),o=t.offset().top,i=2*o+t.height();$(window).scroll(function(){var t=$("#toc-start").offset().top-s,o=document.body.scrollTop+document.documentElement.scrollTop;t<=o&&o<=i?c.css({display:"block",position:"fixed",top:s}):o<=t?c.css({position:"",top:""}):i<o&&c.css("display","none")}),tocbot.init({tocSelector:"#tocbot",contentSelector:".post-content",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,headingsOffset:-o}),0<$(".toc-list-item").length&&$("#toc > p").css("visibility","visible");var l=t.css("margin-right");$("#toc-ctn").css({right:l})})</script><script defer="defer" src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer="defer" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script defer="defer">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?882b48640075e00a238ae94a7eec0d40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script defer="defer">var _mtac={};!function(){var t=document.createElement("script");t.src="//pingjs.qq.com/h5/stats.js?v2.0.4",t.setAttribute("name","MTAH5"),t.setAttribute("sid","");var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js"></script><script>$(document).ready(function(){$("pre").addClass("prettyprint  "),prettyPrint()})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","Redis 基本数据结构之 dict&nbsp;"],cursorChar:"_",typeSpeed:80,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){getSearchFile(path),this.onclick=null}</script><script defer="defer" src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><script>$("#post img:not(.no-zoom img, img[no-zoom])").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>