<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/dolphin.png"><link rel="icon" type="image/png" href="/images/dolphin.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#433d3c"><meta name="description" content=""><meta name="author" content="Happen"><meta name="keywords" content=""><title>Redis 源码之 cluster meet - HappenのMemo</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/monokai.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body><header style="height:60vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>HappenのMemo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(/images/about-banner.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"><span class="h2" id="subtitle"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Happen </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2018-12-10 00:02" pubdate>2018-12-10 00:02</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 47 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">Redis 源码之 cluster meet</h1><p class="note note-info">本文最后更新于：2018-12-10 00:02</p><div class="markdown-body" id="post-body"><p>Redis cluster 是 redis 官方提出的分布式集群解决方案，在此之前，有一些第三方的可选方案，如 codis、Twemproxy 等。cluster 内部使用了 gossip 协议进行通信，以达到数据的最终一致性。详细介绍可参考官网 <a target="_blank" rel="noopener" href="https://redis.io/topics/cluster-tutorial">Redis cluster tutorial</a>。</p><p>本文试图借着<code>cluster meet</code> 命令的实现来对其中的一些通信细节一探究竟。</p><!--more----><p>我们都知道，当 redis server 以 cluster mode 启动时，节点 B 想加入节点 A 所在的集群，只需要执行 <code>CLUSTER MEET ip port</code> 这个命令即可，通过 gossip 通信，最终 A 所在集群的其他节点也都会认识到 B。大概流程图如下：</p><h2 id="cluster- 初始化">cluster 初始化</h2><p>当 redis server 以 cluster mode 启动时，即配置文件中的 <code>cluster-enabled</code> 选项设置为 <code>true</code>，此时在服务启动时，会有一个 cluster 初始化的流程，这个在之前的文章 《<a target="_blank" rel="noopener" href="http://tech-happen.site/e74c6d55.html">Redis 启动流程</a>》中有提到过，即执行函数 <code>clusterInit</code>。在 cluster 中有三个数据结构很重要， <code>clusterState</code> 、 <code>clusterNode</code> 和 <code>clusterLink</code>。</p><p>每个节点都保存着一个 <code>clusterState</code> 结构，这个结构记录了在当前节点的视角下，集群目前所处的状态，即“我看到的世界是什么样子”。</p><p>每个节点都会使用一个 <code>clusterNode</code> 结构来记录自己的状态， 并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的 <code>clusterNode</code> 结构， 以此来记录其他节点的状态。</p><p><code>clusterNode</code> 结构的 <code>link</code> 属性是一个 <code>clusterLink</code> 结构， 该结构保存了连接节点所需的有关信息， 比如套接字描述符， 输入缓冲区和输出缓冲区。</p><p>更多的细节可以通过网页 《<a target="_blank" rel="noopener" href="http://redisbook.com/preview/cluster/node.html">redis 设计与实现 - 节点</a>》进行了解。</p><p>该初始化很简单，首先是创建一个 <code>clusterState</code> 结构，并初始化一些成员，如下：</p><div class="hljs"><pre><code class="hljs c">server.cluster = zmalloc(<span class="hljs-keyword">sizeof</span>(clusterState));
server.cluster-&gt;myself = <span class="hljs-literal">NULL</span>;
server.cluster-&gt;currentEpoch = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 新节点的 currentEpoch = 0</span>
server.cluster-&gt;state = CLUSTER_FAIL; <span class="hljs-comment">// 初始状态置为 FAIL</span>
server.cluster-&gt;size = <span class="hljs-number">1</span>;
server.cluster-&gt;todo_before_sleep = <span class="hljs-number">0</span>;
server.cluster-&gt;nodes = dictCreate(&amp;clusterNodesDictType,<span class="hljs-literal">NULL</span>);
server.cluster-&gt;nodes_black_list = dictCreate(&amp;clusterNodesBlackListDictType,<span class="hljs-literal">NULL</span>);
server.cluster-&gt;failover_auth_time = <span class="hljs-number">0</span>;
server.cluster-&gt;failover_auth_count = <span class="hljs-number">0</span>;
server.cluster-&gt;failover_auth_rank = <span class="hljs-number">0</span>;
server.cluster-&gt;failover_auth_epoch = <span class="hljs-number">0</span>;
server.cluster-&gt;cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;
server.cluster-&gt;lastVoteEpoch = <span class="hljs-number">0</span>;
server.cluster-&gt;stats_bus_messages_sent = <span class="hljs-number">0</span>;
server.cluster-&gt;stats_bus_messages_received = <span class="hljs-number">0</span>;
<span class="hljs-built_in">memset</span>(server.cluster-&gt;slots,<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(server.cluster-&gt;slots));
clusterCloseAllSlots(); <span class="hljs-comment">// Clear the migrating/importing state for all the slots</span></code></pre></div><p>然后给 node.conf 文件加锁，确保每个节点使用自己的 cluster 配置文件。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (clusterLockConfig(server.cluster_configfile) == C_ERR)
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);</code></pre></div><p>借着这个机会学习下 redis 如何使用的文件锁。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> fd = open(filename,O_WRONLY|O_CREAT,<span class="hljs-number">0644</span>);
<span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;
    serverLog(LL_WARNING,
              <span class="hljs-string">&quot;Can&#x27;t open %s in order to acquire a lock: %s&quot;</span>,
              filename, strerror(errno));
    <span class="hljs-keyword">return</span> C_ERR;
&#125;

<span class="hljs-keyword">if</span> (flock(fd,LOCK_EX|LOCK_NB) == <span class="hljs-number">-1</span>) &#123;
    <span class="hljs-keyword">if</span> (errno == EWOULDBLOCK) &#123;
        serverLog(LL_WARNING,
                  <span class="hljs-string">&quot;Sorry, the cluster configuration file %s is already used &quot;</span>
                  <span class="hljs-string">&quot;by a different Redis Cluster node. Please make sure that &quot;</span>
                  <span class="hljs-string">&quot;different nodes use different cluster configuration &quot;</span>
                  <span class="hljs-string">&quot;files.&quot;</span>, filename);
    &#125; <span class="hljs-keyword">else</span> &#123;
        serverLog(LL_WARNING,
                  <span class="hljs-string">&quot;Impossible to lock %s: %s&quot;</span>, filename, strerror(errno));
    &#125;
    close(fd);
    <span class="hljs-keyword">return</span> C_ERR;
&#125;</code></pre></div><p>然后加载 node.conf 文件，这个过程还会检查这个文件是否合理。</p><p>如果加载失败（或者配置文件不存在），则以 <code>REDIS_NODE_MYSELF|REDIS_NODE_MASTER</code> 为标记，创建一个 clusterNode 结构表示自己本身，置为主节点，并设置自己的名字为一个 40 字节的随机串；然后将该节点添加到 server.cluster-&gt;nodes 中，这说明这是个新启动的节点，生成的配置文件进行刷盘。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (clusterLoadConfig(server.cluster_configfile) == C_ERR) &#123;
    myself = server.cluster-&gt;myself =
        createClusterNode(<span class="hljs-literal">NULL</span>,CLUSTER_NODE_MYSELF|CLUSTER_NODE_MASTER);
    serverLog(LL_NOTICE,<span class="hljs-string">&quot;No cluster configuration found, I&#x27;m %.40s&quot;</span>,
              myself-&gt;name);
    clusterAddNode(myself);
    saveconf = <span class="hljs-number">1</span>;
&#125;
<span class="hljs-keyword">if</span> (saveconf) clusterSaveConfigOrDie(<span class="hljs-number">1</span>); <span class="hljs-comment">// 新节点，将配置刷到配置文件中，fsync</span></code></pre></div><p>接下来，调用 <code>listenToPort</code> 函数，在集群 gossip 通信端口上创建 socket fd 进行监听。集群内 gossip 通信端口是在 <strong>Redis 监听端口基础上加 10000</strong>，比如如果 Redis 监听客户端的端口为 6379，则集群监听端口就是 16379，该监听端口用于接收其他集群节点发送过来的 gossip 消息。</p><p>然后注册监听端口上的可读事件，事件回调函数为 <code>clusterAcceptHandler</code>。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLUSTER_PORT_INCR 10000</span>

<span class="hljs-keyword">if</span> (listenToPort(server.port+CLUSTER_PORT_INCR,
                 server.cfd,&amp;server.cfd_count) == C_ERR)
&#123;
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
&#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-keyword">int</span> j;
    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; server.cfd_count; j++) &#123;
        <span class="hljs-keyword">if</span> (aeCreateFileEvent(server.el, server.cfd[j], AE_READABLE,
                              clusterAcceptHandler, <span class="hljs-literal">NULL</span>) == AE_ERR)
            serverPanic(<span class="hljs-string">&quot;Unrecoverable error creating Redis Cluster &quot;</span>
                        <span class="hljs-string">&quot;file event.&quot;</span>);
    &#125;
&#125;</code></pre></div><p>当前节点收到其他集群节点发来的 TCP 建链请求之后，就会调用 <code>clusterAcceptHandler</code> 函数 accept 连接。在 <code>clusterAcceptHandler</code>函数中，对于每个已经 accept 的链接，都会创建一个<code>clusterLink</code> 结构表示该链接，并注册 socket fd 上的可读事件，事件回调函数为 <code>clusterReadHandler</code>。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_CLUSTER_ACCEPTS_PER_CALL 1000</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clusterAcceptHandler</span><span class="hljs-params">(aeEventLoop *el, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">int</span> mask)</span> </span>&#123;
    <span class="hljs-keyword">int</span> cport, cfd;
    <span class="hljs-keyword">int</span> max = MAX_CLUSTER_ACCEPTS_PER_CALL;
    <span class="hljs-keyword">char</span> cip[NET_IP_STR_LEN];
    clusterLink *link;
    ... ...
    <span class="hljs-comment">// 如果服务器正在启动，不要接受其他节点的连接, 因为 UPDATE 消息可能会干扰数据库内容</span>
    <span class="hljs-keyword">if</span> (server.masterhost == <span class="hljs-literal">NULL</span> &amp;&amp; server.loading) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">while</span>(max--) &#123;
        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="hljs-keyword">sizeof</span>(cip), &amp;cport);
        <span class="hljs-keyword">if</span> (cfd == ANET_ERR) &#123;
            <span class="hljs-keyword">if</span> (errno != EWOULDBLOCK)
                serverLog(LL_VERBOSE,
                    <span class="hljs-string">&quot;Error accepting cluster node: %s&quot;</span>, server.neterr);
            <span class="hljs-keyword">return</span>;
        &#125;
        anetNonBlock(<span class="hljs-literal">NULL</span>,cfd);
        anetEnableTcpNoDelay(<span class="hljs-literal">NULL</span>,cfd);
        ... ...
        <span class="hljs-comment">// 创建一个 link 结构来处理连接</span>
        <span class="hljs-comment">// 刚开始的时候， link-&gt;node 被设置成 null，因为现在我们不知道是哪个节点</span>
        link = createClusterLink(<span class="hljs-literal">NULL</span>);
        link-&gt;fd = cfd;
        aeCreateFileEvent(server.el,cfd,AE_READABLE,clusterReadHandler,link);
    &#125;
&#125;</code></pre></div><p>最后是 reset mf 相关的参数。</p><h2 id="CLUSTER-MEET">CLUSTER MEET</h2><h3 id="一、A- 节点接收 -CLUSTER-MEET- 命令">一、A 节点接收 CLUSTER MEET 命令</h3><p>A 节点在<code>cluster.c</code> -&gt; <code>clusterCommand</code> 函数中，接收到 <code>CLUSTER MEET</code> 命令，即</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="hljs-number">1</span>]-&gt;ptr,<span class="hljs-string">&quot;meet&quot;</span>) &amp;&amp; c-&gt;argc == <span class="hljs-number">4</span>) &#123;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> port;

    <span class="hljs-comment">// CLUSTER MEET &lt;ip&gt; &lt;port&gt;</span>
    <span class="hljs-keyword">if</span> (getLongLongFromObject(c-&gt;argv[<span class="hljs-number">3</span>], &amp;port) != C_OK) &#123;
        addReplyErrorFormat(c,<span class="hljs-string">&quot;Invalid TCP port specified: %s&quot;</span>, (<span class="hljs-keyword">char</span>*)c-&gt;argv[<span class="hljs-number">3</span>]-&gt;ptr);
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">if</span> (clusterStartHandshake(c-&gt;argv[<span class="hljs-number">2</span>]-&gt;ptr,port) == <span class="hljs-number">0</span> &amp;&amp; errno == EINVAL)
    &#123;
        addReplyErrorFormat(c,<span class="hljs-string">&quot;Invalid node address specified: %s:%s&quot;</span>,
                            (<span class="hljs-keyword">char</span>*)c-&gt;argv[<span class="hljs-number">2</span>]-&gt;ptr, (<span class="hljs-keyword">char</span>*)c-&gt;argv[<span class="hljs-number">3</span>]-&gt;ptr);
    &#125; <span class="hljs-keyword">else</span> &#123;
        addReply(c,shared.ok);
    &#125;
&#125;</code></pre></div><p>可以看到重点在 <code>clusterStartHandshake</code> 这个函数。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">clusterStartHandshake</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *ip, <span class="hljs-keyword">int</span> port)</span> </span>&#123;
    clusterNode *n;
    <span class="hljs-keyword">char</span> norm_ip[NET_IP_STR_LEN];
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">sa</span>;</span>
    <span class="hljs-comment">/* IP and Port sanity check */</span>
    ... ...

    <span class="hljs-comment">// 检查节点(flag) norm_ip:port 是否正在握手</span>
    <span class="hljs-keyword">if</span> (clusterHandshakeInProgress(norm_ip,port)) &#123;
        errno = EAGAIN;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-comment">// 创建一个含随机名字的 node，type 为 CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_MEET</span>
    <span class="hljs-comment">// 相关信息会在 handshake 过程中被修复</span>
    n = createClusterNode(<span class="hljs-literal">NULL</span>,CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_MEET);
    <span class="hljs-built_in">memcpy</span>(n-&gt;ip,norm_ip,<span class="hljs-keyword">sizeof</span>(n-&gt;ip));
    n-&gt;port = port;
    clusterAddNode(n);
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
&#125;</code></pre></div><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">clusterNode *<span class="hljs-title">createClusterNode</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *nodename, <span class="hljs-keyword">int</span> flags)</span> </span>&#123;
    clusterNode *node = zmalloc(<span class="hljs-keyword">sizeof</span>(*node));
    <span class="hljs-keyword">if</span> (nodename)
        <span class="hljs-built_in">memcpy</span>(node-&gt;name, nodename, CLUSTER_NAMELEN);
    <span class="hljs-keyword">else</span>
        <span class="hljs-comment">// 在本地新建一个 nodename 节点，节点名字随机，跟它通信时它会告诉我真实名字</span>
        getRandomHexChars(node-&gt;name, CLUSTER_NAMELEN);
    node-&gt;ctime = mstime(); <span class="hljs-comment">// mstime</span>
    node-&gt;configEpoch = <span class="hljs-number">0</span>;
    node-&gt;flags = flags;
    <span class="hljs-built_in">memset</span>(node-&gt;slots,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(node-&gt;slots));
    node-&gt;slaveof = <span class="hljs-literal">NULL</span>;
    ... ...
    node-&gt;link = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// link 为空, 在 clusterCron 中能检查的到</span>
    <span class="hljs-built_in">memset</span>(node-&gt;ip,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(node-&gt;ip));
    node-&gt;port = <span class="hljs-number">0</span>;
    node-&gt;fail_reports = listCreate();
    ... ...
    listSetFreeMethod(node-&gt;fail_reports,zfree);
    <span class="hljs-keyword">return</span> node;
&#125;</code></pre></div><p>这个函数会首先进行一些 ip 和 port 的合理性检查，然后去遍历所看到的 nodes，这个 ip:port 对应的 node 是不是正处于 <code>CLUSTER_NODE_HANDSHAKE</code> 状态，是的话，就说明这是重复 meet，没必要往下走。之后，通过 <code>createClusterNode</code> 函数创建一个带有 <code>CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_MEET</code> 标记的节点，名字为一个 <strong>随机 </strong>的 40 字节字符串（因为此时对 A 来说，B 是一个陌生的节点，信息除了 ip 和 port，其他都不知道），通过 <code>clusterAddNode</code> 函数加到自己的 nodes 中。</p><p>这个过程成功后，就返回给客户端 OK 了，其他事情需要通过 gossip 通信去做。</p><h3 id="二、A- 节点发送 -MEET- 消息给 -B- 节点">二、A 节点发送 MEET 消息给 B 节点</h3><p>A 节点在定时任务 <code>clusterCron</code> 中，会做一些事情。</p><div class="hljs"><pre><code class="hljs c">handshake_timeout = server.cluster_node_timeout;
<span class="hljs-keyword">if</span> (handshake_timeout &lt; <span class="hljs-number">1000</span>) handshake_timeout = <span class="hljs-number">1000</span>;

<span class="hljs-comment">// 检查是否有 disconnected nodes 并且重新建立连接</span>
di = dictGetSafeIterator(server.cluster-&gt;nodes); <span class="hljs-comment">// 遍历所有节点</span>
<span class="hljs-keyword">while</span>((de = dictNext(di)) != <span class="hljs-literal">NULL</span>) &#123;
    clusterNode *node = dictGetVal(de);

     <span class="hljs-comment">// 忽略掉 myself 和 noaddr 状态的节点</span>
    <span class="hljs-keyword">if</span> (node-&gt;flags &amp; (CLUSTER_NODE_MYSELF|CLUSTER_NODE_NOADDR)) <span class="hljs-keyword">continue</span>;

    <span class="hljs-comment">// 节点处于 handshake 状态，且状态维持时间超过 handshake_timeout，那么从 nodes 中删掉它</span>
    <span class="hljs-keyword">if</span> (nodeInHandshake(node) &amp;&amp; now - node-&gt;ctime &gt; handshake_timeout) &#123;
        clusterDelNode(node);
        <span class="hljs-keyword">continue</span>;
    &#125;

    <span class="hljs-comment">// 刚刚收到 cluster meet 命令创建的新 node ，或是 server 刚启动，或是由于某种原因断开了</span>
    <span class="hljs-keyword">if</span> (node-&gt;link == <span class="hljs-literal">NULL</span>) &#123;
        <span class="hljs-keyword">int</span> fd;
        <span class="hljs-keyword">mstime_t</span> old_ping_sent;
        clusterLink *link;

        <span class="hljs-comment">// 对端 gossip 通信端口为 node 端口 + 10000，创建 tcp 连接, 本节点相当于 client</span>
        fd = anetTcpNonBlockBindConnect(server.neterr, node-&gt;ip, node-&gt;port+CLUSTER_PORT_INCR, NET_FIRST_BIND_ADDR);
        ... ...
        link = createClusterLink(node);
        link-&gt;fd = fd;
        node-&gt;link = link;

        <span class="hljs-comment">// 注册 link-&gt;fd 上的可读事件，事件回调函数为 clusterReadHandler</span>
        aeCreateFileEvent(server.el,link-&gt;fd,AE_READABLE, clusterReadHandler,link);
        ... ...

        <span class="hljs-comment">// 如果 node 带有 MEET flag，我们发送一个 MEET 包而不是 PING,</span>
        <span class="hljs-comment">// 这是为了强制让接收者把我们加到它的 nodes 中</span>
        clusterSendPing(link, node-&gt;flags &amp; CLUSTER_NODE_MEET ? CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING);
        ... ...
        node-&gt;flags &amp;= ~CLUSTER_NODE_MEET;
        ... ...
    &#125;
&#125;
dictReleaseIterator(di);</code></pre></div><p>可以看到，遍历自己看到的 nodes，当遍历到 B 节点时，由于 <code>node-&gt;link == NULL</code>，因此会监听 B 的启动端口号 +10000，即 gossip 通信端口，然后注册可读事件，处理函数为 <code>clusterReadHandler</code>。接着会发送 <strong>CLUSTER_NODE_MEET</strong> 消息给 B 节点，消除掉 B 节点的 <strong>meet</strong> 状态。</p><h3 id="三、B- 节点处理 -A- 发来的 -MEET- 消息">三、B 节点处理 A 发来的 MEET 消息</h3><p>当 B 节点接收到 A 节点发送 gossip 时，回调函数 <code>clusterAcceptHandler</code> 进行处理，然后会 accept 对端的 connect（B 作为 server，对端作为 client），注册可读事件，回调函数为 <code>clusterReadHandler</code>，基本逻辑如下，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clusterAcceptHandler</span><span class="hljs-params">(aeEventLoop *el, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">int</span> mask)</span> </span>&#123;
    <span class="hljs-keyword">int</span> cport, cfd;
    <span class="hljs-keyword">int</span> max = MAX_CLUSTER_ACCEPTS_PER_CALL;
    <span class="hljs-keyword">char</span> cip[NET_IP_STR_LEN];
    clusterLink *link;
    UNUSED(el);
    UNUSED(mask);
    UNUSED(privdata);

    <span class="hljs-comment">// 如果服务器正在启动，不要接受其他节点的链接，因为 UPDATE 消息可能会干扰数据库内容</span>
    <span class="hljs-keyword">if</span> (server.masterhost == <span class="hljs-literal">NULL</span> &amp;&amp; server.loading) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">while</span>(max--) &#123; <span class="hljs-comment">// 1000 个请求</span>
        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="hljs-keyword">sizeof</span>(cip), &amp;cport);
        <span class="hljs-keyword">if</span> (cfd == ANET_ERR) &#123;
            <span class="hljs-keyword">if</span> (errno != EWOULDBLOCK)
                serverLog(LL_VERBOSE,
                    <span class="hljs-string">&quot;Error accepting cluster node: %s&quot;</span>, server.neterr);
            <span class="hljs-keyword">return</span>;
        &#125;
        anetNonBlock(<span class="hljs-literal">NULL</span>,cfd);
        anetEnableTcpNoDelay(<span class="hljs-literal">NULL</span>,cfd);
        serverLog(LL_VERBOSE,<span class="hljs-string">&quot;Accepted cluster node %s:%d&quot;</span>, cip, cport);

        <span class="hljs-comment">// 创建一个 link 结构来处理连接</span>
        <span class="hljs-comment">// 刚开始的时候， link-&gt;node 被设置成 null，因为现在我们不知道是哪个节点</span>
        link = createClusterLink(<span class="hljs-literal">NULL</span>);
        link-&gt;fd = cfd;
        aeCreateFileEvent(server.el,cfd,AE_READABLE,clusterReadHandler,link);
    &#125;
&#125;</code></pre></div><p>可以看到每次 accept 对端 connect 时，都会创建一个 <code>clusterLink</code> 结构用来接收数据，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clusterLink</span> &#123;</span>
    <span class="hljs-keyword">mstime_t</span> ctime;             <span class="hljs-comment">/* Link creation time */</span>
    <span class="hljs-keyword">int</span> fd;                     <span class="hljs-comment">/* TCP socket file descriptor */</span>
    sds sndbuf;                 <span class="hljs-comment">/* Packet send buffer */</span>
    sds rcvbuf;                 <span class="hljs-comment">/* Packet reception buffer */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clusterNode</span> *<span class="hljs-title">node</span>;</span>   <span class="hljs-comment">/* Node related to this link if any, or NULL */</span>
&#125; clusterLink;</code></pre></div><p><code>clusterLink</code> 有一个指针是指向 node 自身的。</p><p>B 节点接收到 A 节点发送过来的信息，放到 <code>clusterLink</code> 的 <code>rcvbuf</code> 字段，然后使用 <code>clusterProcessPacket</code> 函数来处理（接收数据过程很简单，不做分析）。</p><p>所以 <code>clusterProcessPacket</code> 函数的作用是处理别人发过来的 gossip 包。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!sender &amp;&amp; type == CLUSTERMSG_TYPE_MEET) &#123;
    clusterNode *node;

    <span class="hljs-comment">// 创建一个带有 CLUSTER_NODE_HANDSHAKE 标记的 cluster node，名字随机</span>
    node = createClusterNode(<span class="hljs-literal">NULL</span>,CLUSTER_NODE_HANDSHAKE);
    nodeIp2String(node-&gt;ip,link); <span class="hljs-comment">// ip 和 port 信息均从 link 中获得</span>
    node-&gt;port = ntohs(hdr-&gt;port);

    clusterAddNode(node);
    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
&#125;
.....
clusterSendPing(link,CLUSTERMSG_TYPE_PONG);</code></pre></div><p>由于这时 B 节点还不认识 A 节点，因此 B 节点从自己的 nodes 中找 A 节点是找不到的，所以 sender 是空，因此会走进如上的这段逻辑。同样以随机的名字，CLUSTER_NODE_HANDSHAKE 为 flag 创建一个 node，加入自己的 nodes 中。</p><p><strong>在这个逻辑末尾会给 A 节点回复一个 PONG 消息</strong>。</p><h3 id="四、A- 节点处理 -B- 节点回复的 -PONG- 消息">四、A 节点处理 B 节点回复的 PONG 消息</h3><p>同样是在 <code>clusterProcessPacket</code> 中处理 gossip 消息。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_PONG || type == CLUSTERMSG_TYPE_MEET) &#123;
    ... ...
    <span class="hljs-keyword">if</span> (link-&gt;node) &#123;
        <span class="hljs-keyword">if</span> (nodeInHandshake(link-&gt;node)) &#123; <span class="hljs-comment">// node 处于握手状态</span>
            ... ...
            clusterRenameNode(link-&gt;node, hdr-&gt;sender); <span class="hljs-comment">// 修正节点名</span>
            link-&gt;node-&gt;flags &amp;= ~CLUSTER_NODE_HANDSHAKE; <span class="hljs-comment">// 消除 handshake 状态</span>
            link-&gt;node-&gt;flags |= flags&amp;(CLUSTER_NODE_MASTER|CLUSTER_NODE_SLAVE);
            clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
        &#125;
&#125;</code></pre></div><p>这个时候 A 节点会根据 B 节点发来的消息，更正 A 节点 nodes 中关于 B 节点的名字，以及消除 <strong>handshake</strong> 状态。</p><h3 id="五、B- 节点发送 -PING- 消息给 -A- 节点">五、B 节点发送 PING 消息给 A 节点</h3><p>当 B 节点在做 <code>clusterCron</code> 时，发现自己看到的 A 节点中的 link 为空，即 <code>node-&gt;link == NULL</code>，这与上面讲的 A 节点给 B 节点发 MEET 消息类似，不过在 B 节点看了 A 节点没有 meet flag，因此发送的是 PING 消息。</p><h3 id="六、A- 节点处理 -B- 节点发来的 -PING- 消息">六、A 节点处理 B 节点发来的 PING 消息</h3><p>做一些逻辑，不过跟这次要讨论的事情无关，后面会详写。</p><p><strong>对于 PING 和 MEET 消息，无论如何都是会回复一个 PONG 消息的</strong>。</p><h3 id="七、B- 节点处理 -A- 节点回复的 -PONG- 消息">七、B 节点处理 A 节点回复的 PONG 消息</h3><p>逻辑同上，将 B 节点的 nodes 中 A 节点的名字进行更正，然后去掉 A 节点的 handshake flag。</p><h3 id="补充">补充</h3><p>上面流程的 <strong>第四步 </strong>之后，在 A 看来 B 节点就已经是个完好的节点了，且建立了 A 到 B 的 link。实际上，上面的 <strong>第五至七步 </strong>是不确定的，可能存在如下并行逻辑，即，</p><p>A 节点恰好选中了 B 节点发送 PING 消息，当 B 节点接收到这个 PING 消息后，填充自己看到的 A 节点，消除掉 handshake 状态，但是此时 B 节点的 <code>server.cluster-&gt;nodes</code> 中到 A 节点的 link 仍然是空，即，没办法给 A 发 gossip 消息。</p><p>这两个逻辑哪个先发生不一定，但是最终的状态都是，A 节点与 B 节点之间有两条 link，一条是 A 节点创建的到 B 节点的 link，一条是 B 节点创建的到 A 节点的 link。两个节点地位一样，可以同时给对方发信息，如果只保留一条 link 其实也是可以的，不过逻辑会复杂很多，不方便。</p><h2 id="小结">小结</h2><p>至此，一个 <code>cluster meet</code> 命令执行的完整过程就解释清楚了，画了一个流程图可以帮助更好的理解这个流程。</p><p><img src="http://ww1.sinaimg.cn/mw690/71ca8e3cly1fycksh2170j20pu0nbjst.jpg" srcset="/img/loading.gif" alt="cluster meet"></p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/redis/">redis</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext row"><article class="post-prev col-6"><a href="/3581d0f0.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">golang 中下划线的使用</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/35a9decf.html"><span class="hidden-mobile">Redis 源码之启动流程</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script type="text/javascript">function loadLivere(){addScript("https://cdn-city.livere.com/js/embed.dist.js")}waitElementVisible("lv-container",loadLivere)</script><noscript>为正常使用来必力评论功能请允许 JavaScript 运行</noscript></div></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:3,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","Redis 源码之 cluster meet&nbsp;"],cursorChar:"|",typeSpeed:72,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "§"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>