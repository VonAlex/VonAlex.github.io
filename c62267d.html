<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Redis 源码之 cluster meet"><meta name="keywords" content="redis"><meta name="author" content="Happen"><meta name="copyright" content="Happen"><title>Redis 源码之 cluster meet | Happen's Memo</title><link rel="shortcut icon" href="/images/dolphin.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?882b48640075e00a238ae94a7eec0d40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,c,g,o){e.GoogleAnalyticsObject=c,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,g=a.createElement(t),o=a.getElementsByTagName(t)[0],g.async=1,g.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(g,o)}(window,document,"script",0,"ga"),ga("create","RRBput3V2WYVZd2lq058Z4IwJEhViOwuMElqkWh6bcA","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#cluster-初始化"><span class="toc-number">1.</span> <span class="toc-text">cluster 初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CLUSTER-MEET"><span class="toc-number">2.</span> <span class="toc-text">CLUSTER MEET</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、A-节点接收-CLUSTER-MEET-命令"><span class="toc-number">2.1.</span> <span class="toc-text">一、A 节点接收 CLUSTER MEET 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、A-节点发送-MEET-消息给-B-节点"><span class="toc-number">2.2.</span> <span class="toc-text">二、A 节点发送 MEET 消息给 B 节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、B-节点处理-A-发来的-MEET-消息"><span class="toc-number">2.3.</span> <span class="toc-text">三、B 节点处理 A 发来的 MEET 消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、A-节点处理-B-节点回复的-PONG-消息"><span class="toc-number">2.4.</span> <span class="toc-text">四、A 节点处理 B 节点回复的 PONG 消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、B-节点发送-PING-消息给-A-节点"><span class="toc-number">2.5.</span> <span class="toc-text">五、B 节点发送 PING 消息给 A 节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六、A-节点处理-B-节点发来的-PING-消息"><span class="toc-number">2.6.</span> <span class="toc-text">六、A 节点处理 B 节点发来的 PING 消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#七、B-节点处理-A-节点回复的-PONG-消息"><span class="toc-number">2.7.</span> <span class="toc-text">七、B 节点处理 A 节点回复的 PONG 消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#补充"><span class="toc-number">2.8.</span> <span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.png"></div><div class="author-info__name text-center">Happen</div><div class="author-info__description text-center">浮生若梦，为欢几何</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">39</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://renrenlove.me/" target="_blank" rel="noopener">Galway</a><a class="author-info-links__name text-center" href="http://kvguru.com/" target="_blank" rel="noopener">Wangbin</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div id="page-header"> <span class="pull-left"><a id="site-name" href="/">Happen's Memo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Redis 源码之 cluster meet</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a><div class="post-meta-wordcount"><span>字数总计:</span> <span class="word-count">3.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 13 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>Redis cluster 是 redis 官方提出的分布式集群解决方案，在此之前，有一些第三方的可选方案，如 codis、Twemproxy等。cluster 内部使用了 gossip 协议进行通信，以达到数据的最终一致性。详细介绍可参考官网 <a href="https://redis.io/topics/cluster-tutorial" target="_blank" rel="noopener">Redis cluster tutorial</a>。</p><p>本文试图借着<code>cluster meet</code> 命令的实现来对其中的一些通信细节一探究竟。</p><a id="more"></a><p>我们都知道，当 redis server 以 cluster mode 启动时，节点 B 想加入节点 A 所在的集群，只需要执行 <code>CLUSTER MEET ip port</code> 这个命令即可，通过 gossip 通信，最终 A 所在集群的其他节点也都会认识到 B。大概流程图如下：</p><h2 id="cluster-初始化"><a href="#cluster-初始化" class="headerlink" title="cluster 初始化"></a>cluster 初始化</h2><p>当 redis server 以 cluster mode 启动时，即配置文件中的 <code>cluster-enabled</code> 选项设置为 <code>true</code>，此时在服务启动时，会有一个 cluster 初始化的流程，这个在之前的文章 《<a href="http://tech-happen.site/e74c6d55.html" target="_blank" rel="noopener">Redis 启动流程</a>》中有提到过，即执行函数 <code>clusterInit</code>。在 cluster 中有三个数据结构很重要， <code>clusterState</code> 、 <code>clusterNode</code> 和 <code>clusterLink</code>。</p><p>每个节点都保存着一个 <code>clusterState</code> 结构，这个结构记录了在当前节点的视角下，集群目前所处的状态，即“我看到的世界是什么样子”。</p><p>每个节点都会使用一个 <code>clusterNode</code> 结构来记录自己的状态， 并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的 <code>clusterNode</code> 结构， 以此来记录其他节点的状态。</p><p><code>clusterNode</code> 结构的 <code>link</code> 属性是一个 <code>clusterLink</code> 结构， 该结构保存了连接节点所需的有关信息， 比如套接字描述符， 输入缓冲区和输出缓冲区。</p><p>更多的细节可以通过网页 《<a href="http://redisbook.com/preview/cluster/node.html" target="_blank" rel="noopener">redis 设计与实现 - 节点</a>》进行了解。</p><p>该初始化很简单，首先是创建一个 <code>clusterState</code> 结构，并初始化一些成员，如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server.cluster = zmalloc(<span class="keyword">sizeof</span>(clusterState));</span><br><span class="line">server.cluster-&gt;myself = <span class="literal">NULL</span>;</span><br><span class="line">server.cluster-&gt;currentEpoch = <span class="number">0</span>;     <span class="comment">// 新节点的 currentEpoch = 0</span></span><br><span class="line">server.cluster-&gt;state = CLUSTER_FAIL; <span class="comment">// 初始状态置为 FAIL</span></span><br><span class="line">server.cluster-&gt;<span class="built_in">size</span> = <span class="number">1</span>;</span><br><span class="line">server.cluster-&gt;todo_before_sleep = <span class="number">0</span>;</span><br><span class="line">server.cluster-&gt;nodes = dictCreate(&amp;clusterNodesDictType,<span class="literal">NULL</span>);</span><br><span class="line">server.cluster-&gt;nodes_black_list = dictCreate(&amp;clusterNodesBlackListDictType,<span class="literal">NULL</span>);</span><br><span class="line">server.cluster-&gt;failover_auth_time = <span class="number">0</span>;</span><br><span class="line">server.cluster-&gt;failover_auth_count = <span class="number">0</span>;</span><br><span class="line">server.cluster-&gt;failover_auth_rank = <span class="number">0</span>;</span><br><span class="line">server.cluster-&gt;failover_auth_epoch = <span class="number">0</span>;</span><br><span class="line">server.cluster-&gt;cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;</span><br><span class="line">server.cluster-&gt;lastVoteEpoch = <span class="number">0</span>;</span><br><span class="line">server.cluster-&gt;stats_bus_messages_sent = <span class="number">0</span>;</span><br><span class="line">server.cluster-&gt;stats_bus_messages_received = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(server.cluster-&gt;slots,<span class="number">0</span>, <span class="keyword">sizeof</span>(server.cluster-&gt;slots));</span><br><span class="line">clusterCloseAllSlots(); <span class="comment">// Clear the migrating/importing state for all the slots</span></span><br></pre></td></tr></table></figure><p>然后给 node.conf 文件加锁，确保每个节点使用自己的 cluster 配置文件。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (clusterLockConfig(server.cluster_configfile) == C_ERR)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>借着这个机会学习下 redis 如何使用的文件锁。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = <span class="built_in">open</span>(filename,O_WRONLY|O_CREAT,<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">              <span class="string">"Can't open %s in order to acquire a lock: %s"</span>,</span><br><span class="line">              filename, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flock(fd,LOCK_EX|LOCK_NB) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EWOULDBLOCK) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">"Sorry, the cluster configuration file %s is already used "</span></span><br><span class="line">                  <span class="string">"by a different Redis Cluster node. Please make sure that "</span></span><br><span class="line">                  <span class="string">"different nodes use different cluster configuration "</span></span><br><span class="line">                  <span class="string">"files."</span>, filename);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">"Impossible to lock %s: %s"</span>, filename, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后加载 node.conf 文件，这个过程还会检查这个文件是否合理。</p><p>如果加载失败（或者配置文件不存在），则以 <code>REDIS_NODE_MYSELF|REDIS_NODE_MASTER</code> 为标记，创建一个clusterNode 结构表示自己本身，置为主节点，并设置自己的名字为一个40字节的随机串；然后将该节点添加到server.cluster-&gt;nodes中，这说明这是个新启动的节点，生成的配置文件进行刷盘。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (clusterLoadConfig(server.cluster_configfile) == C_ERR) &#123;</span><br><span class="line">    myself = server.cluster-&gt;myself =</span><br><span class="line">        createClusterNode(<span class="literal">NULL</span>,CLUSTER_NODE_MYSELF|CLUSTER_NODE_MASTER);</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"No cluster configuration found, I'm %.40s"</span>,</span><br><span class="line">              myself-&gt;name);</span><br><span class="line">    clusterAddNode(myself);</span><br><span class="line">    saveconf = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (saveconf) clusterSaveConfigOrDie(<span class="number">1</span>); <span class="comment">// 新节点，将配置刷到配置文件中，fsync</span></span><br></pre></td></tr></table></figure><p>接下来，调用 <code>listenToPort</code> 函数，在集群 gossip 通信端口上创建 socket fd 进行监听。集群内 gossip 通信端口是在 <strong>Redis 监听端口基础上加 10000</strong>，比如如果Redis监听客户端的端口为 6379，则集群监听端口就是16379，该监听端口用于接收其他集群节点发送过来的 gossip 消息。</p><p>然后注册监听端口上的可读事件，事件回调函数为 <code>clusterAcceptHandler</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLUSTER_PORT_INCR 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (listenToPort(server.port+CLUSTER_PORT_INCR,</span><br><span class="line">                 server.cfd,&amp;server.cfd_count) == C_ERR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.cfd_count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.cfd[j], AE_READABLE,</span><br><span class="line">                              clusterAcceptHandler, <span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">            serverPanic(<span class="string">"Unrecoverable error creating Redis Cluster "</span></span><br><span class="line">                        <span class="string">"file event."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前节点收到其他集群节点发来的TCP建链请求之后，就会调用 <code>clusterAcceptHandler</code> 函数 accept 连接。在 <code>clusterAcceptHandler</code>函数中，对于每个已经 accept 的链接，都会创建一个<code>clusterLink</code> 结构表示该链接，并注册 socket fd上的可读事件，事件回调函数为 <code>clusterReadHandler</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CLUSTER_ACCEPTS_PER_CALL 1000</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterAcceptHandler</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cport, cfd;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = MAX_CLUSTER_ACCEPTS_PER_CALL;</span><br><span class="line">    <span class="keyword">char</span> cip[NET_IP_STR_LEN];</span><br><span class="line">    clusterLink *link;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// 如果服务器正在启动，不要接受其他节点的连接, 因为 UPDATE 消息可能会干扰数据库内容</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp; server.loading) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">max</span>--) &#123;</span><br><span class="line">        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="keyword">sizeof</span>(cip), &amp;cport);</span><br><span class="line">        <span class="keyword">if</span> (cfd == ANET_ERR) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">                serverLog(LL_VERBOSE,</span><br><span class="line">                    <span class="string">"Error accepting cluster node: %s"</span>, server.neterr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>,cfd);</span><br><span class="line">        anetEnableTcpNoDelay(<span class="literal">NULL</span>,cfd);</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="comment">// 创建一个 link 结构来处理连接</span></span><br><span class="line">        <span class="comment">// 刚开始的时候， link-&gt;node 被设置成 null，因为现在我们不知道是哪个节点</span></span><br><span class="line">        link = createClusterLink(<span class="literal">NULL</span>);</span><br><span class="line">        link-&gt;fd = cfd;</span><br><span class="line">        aeCreateFileEvent(server.el,cfd,AE_READABLE,clusterReadHandler,link);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是 reset mf 相关的参数。</p><h2 id="CLUSTER-MEET"><a href="#CLUSTER-MEET" class="headerlink" title="CLUSTER MEET"></a>CLUSTER MEET</h2><h3 id="一、A-节点接收-CLUSTER-MEET-命令"><a href="#一、A-节点接收-CLUSTER-MEET-命令" class="headerlink" title="一、A 节点接收 CLUSTER MEET 命令"></a>一、A 节点接收 CLUSTER MEET 命令</h3><p>A 节点在<code>cluster.c</code> -&gt; <code>clusterCommand</code> 函数中，接收到 <code>CLUSTER MEET</code> 命令，即</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"meet"</span>) &amp;&amp; c-&gt;argc == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CLUSTER MEET &lt;ip&gt; &lt;port&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObject(c-&gt;argv[<span class="number">3</span>], &amp;port) != C_OK) &#123;</span><br><span class="line">        addReplyErrorFormat(c,<span class="string">"Invalid TCP port specified: %s"</span>, (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">3</span>]-&gt;ptr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clusterStartHandshake(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,port) == <span class="number">0</span> &amp;&amp; errno == EINVAL)</span><br><span class="line">    &#123;</span><br><span class="line">        addReplyErrorFormat(c,<span class="string">"Invalid node address specified: %s:%s"</span>,</span><br><span class="line">                            (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">2</span>]-&gt;ptr, (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">3</span>]-&gt;ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到重点在 <code>clusterStartHandshake</code> 这个函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clusterStartHandshake</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    clusterNode *n;</span><br><span class="line">    <span class="keyword">char</span> norm_ip[NET_IP_STR_LEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="comment">/* IP and Port sanity check */</span></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查节点(flag) norm_ip:port 是否正在握手</span></span><br><span class="line">    <span class="keyword">if</span> (clusterHandshakeInProgress(norm_ip,port)) &#123;</span><br><span class="line">        errno = EAGAIN;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个含随机名字的 node，type 为 CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_MEET</span></span><br><span class="line">    <span class="comment">// 相关信息会在 handshake 过程中被修复</span></span><br><span class="line">    n = createClusterNode(<span class="literal">NULL</span>,CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_MEET);</span><br><span class="line">    <span class="built_in">memcpy</span>(n-&gt;ip,norm_ip,<span class="keyword">sizeof</span>(n-&gt;ip));</span><br><span class="line">    n-&gt;port = port;</span><br><span class="line">    clusterAddNode(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">clusterNode *<span class="title">createClusterNode</span><span class="params">(<span class="keyword">char</span> *nodename, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    clusterNode *node = zmalloc(<span class="keyword">sizeof</span>(*node));</span><br><span class="line">    <span class="keyword">if</span> (nodename)</span><br><span class="line">        <span class="built_in">memcpy</span>(node-&gt;name, nodename, CLUSTER_NAMELEN);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 在本地新建一个 nodename 节点，节点名字随机，跟它通信时它会告诉我真实名字</span></span><br><span class="line">        getRandomHexChars(node-&gt;name, CLUSTER_NAMELEN);</span><br><span class="line">    node-&gt;ctime = mstime(); <span class="comment">// mstime</span></span><br><span class="line">    node-&gt;configEpoch = <span class="number">0</span>;</span><br><span class="line">    node-&gt;flags = flags;</span><br><span class="line">    <span class="built_in">memset</span>(node-&gt;slots,<span class="number">0</span>,<span class="keyword">sizeof</span>(node-&gt;slots));</span><br><span class="line">    node-&gt;slaveof = <span class="literal">NULL</span>;</span><br><span class="line">    ... ...</span><br><span class="line">    node-&gt;link = <span class="literal">NULL</span>; <span class="comment">// link 为空, 在 clusterCron 中能检查的到</span></span><br><span class="line">    <span class="built_in">memset</span>(node-&gt;ip,<span class="number">0</span>,<span class="keyword">sizeof</span>(node-&gt;ip));</span><br><span class="line">    node-&gt;port = <span class="number">0</span>;</span><br><span class="line">    node-&gt;fail_reports = listCreate();</span><br><span class="line">    ... ...</span><br><span class="line">    listSetFreeMethod(node-&gt;fail_reports,zfree);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数会首先进行一些 ip 和 port 的合理性检查，然后去遍历所看到的 nodes，这个 ip:port 对应的 node 是不是正处于 <code>CLUSTER_NODE_HANDSHAKE</code> 状态，是的话，就说明这是重复 meet，没必要往下走。之后，通过 <code>createClusterNode</code> 函数创建一个带有 <code>CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_MEET</code> 标记的节点，名字为一个<strong>随机</strong>的 40 字节字符串（因为此时对 A 来说，B 是一个陌生的节点，信息除了 ip 和 port，其他都不知道），通过 <code>clusterAddNode</code> 函数加到自己的 nodes 中。</p><p>这个过程成功后，就返回给客户端 OK 了，其他事情需要通过 gossip 通信去做。</p><h3 id="二、A-节点发送-MEET-消息给-B-节点"><a href="#二、A-节点发送-MEET-消息给-B-节点" class="headerlink" title="二、A 节点发送 MEET 消息给 B 节点"></a>二、A 节点发送 MEET 消息给 B 节点</h3><p>A 节点在定时任务 <code>clusterCron</code> 中，会做一些事情。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">handshake_timeout = server.cluster_node_timeout;</span><br><span class="line"><span class="keyword">if</span> (handshake_timeout &lt; <span class="number">1000</span>) handshake_timeout = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否有 disconnected nodes 并且重新建立连接</span></span><br><span class="line">di = dictGetSafeIterator(server.cluster-&gt;nodes); <span class="comment">// 遍历所有节点</span></span><br><span class="line"><span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    clusterNode *node = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 忽略掉 myself 和 noaddr 状态的节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;flags &amp; (CLUSTER_NODE_MYSELF|CLUSTER_NODE_NOADDR)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点处于 handshake 状态，且状态维持时间超过 handshake_timeout，那么从 nodes中删掉它</span></span><br><span class="line">    <span class="keyword">if</span> (nodeInHandshake(node) &amp;&amp; now - node-&gt;ctime &gt; handshake_timeout) &#123;</span><br><span class="line">        clusterDelNode(node);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刚刚收到 cluster meet 命令创建的新 node ，或是 server 刚启动，或是由于某种原因断开了</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;link == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">mstime_t</span> old_ping_sent;</span><br><span class="line">        clusterLink *link;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对端 gossip 通信端口为 node 端口 + 10000，创建 tcp 连接, 本节点相当于 client</span></span><br><span class="line">        fd = anetTcpNonBlockBindConnect(server.neterr, node-&gt;ip, node-&gt;port+CLUSTER_PORT_INCR, NET_FIRST_BIND_ADDR);</span><br><span class="line">        ... ...</span><br><span class="line">        link = createClusterLink(node);</span><br><span class="line">        link-&gt;fd = fd;</span><br><span class="line">        node-&gt;link = link;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册 link-&gt;fd 上的可读事件，事件回调函数为 clusterReadHandler</span></span><br><span class="line">        aeCreateFileEvent(server.el,link-&gt;fd,AE_READABLE, clusterReadHandler,link);</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 node 带有 MEET flag，我们发送一个 MEET 包而不是 PING,</span></span><br><span class="line">        <span class="comment">// 这是为了强制让接收者把我们加到它的 nodes 中</span></span><br><span class="line">        clusterSendPing(link, node-&gt;flags &amp; CLUSTER_NODE_MEET ? CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING);</span><br><span class="line">        ... ...</span><br><span class="line">        node-&gt;flags &amp;= ~CLUSTER_NODE_MEET;</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dictReleaseIterator(di);</span><br></pre></td></tr></table></figure><p>可以看到，遍历自己看到的 nodes，当遍历到 B 节点时，由于 <code>node-&gt;link == NULL</code>，因此会监听 B 的启动端口号+10000，即 gossip 通信端口，然后注册可读事件，处理函数为 <code>clusterReadHandler</code>。接着会发送 <strong>CLUSTER_NODE_MEET</strong> 消息给 B 节点，消除掉 B 节点的 <strong>meet</strong> 状态。</p><h3 id="三、B-节点处理-A-发来的-MEET-消息"><a href="#三、B-节点处理-A-发来的-MEET-消息" class="headerlink" title="三、B 节点处理 A 发来的 MEET  消息"></a>三、B 节点处理 A 发来的 MEET 消息</h3><p>当 B 节点接收到 A 节点发送 gossip 时，回调函数 <code>clusterAcceptHandler</code> 进行处理，然后会 accept 对端的 connect（B 作为 server，对端作为 client），注册可读事件，回调函数为 <code>clusterReadHandler</code>，基本逻辑如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterAcceptHandler</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cport, cfd;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = MAX_CLUSTER_ACCEPTS_PER_CALL;</span><br><span class="line">    <span class="keyword">char</span> cip[NET_IP_STR_LEN];</span><br><span class="line">    clusterLink *link;</span><br><span class="line">    UNUSED(el);</span><br><span class="line">    UNUSED(mask);</span><br><span class="line">    UNUSED(privdata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果服务器正在启动，不要接受其他节点的链接，因为 UPDATE 消息可能会干扰数据库内容</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp; server.loading) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">max</span>--) &#123; <span class="comment">// 1000 个请求</span></span><br><span class="line">        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="keyword">sizeof</span>(cip), &amp;cport);</span><br><span class="line">        <span class="keyword">if</span> (cfd == ANET_ERR) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">                serverLog(LL_VERBOSE,</span><br><span class="line">                    <span class="string">"Error accepting cluster node: %s"</span>, server.neterr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>,cfd);</span><br><span class="line">        anetEnableTcpNoDelay(<span class="literal">NULL</span>,cfd);</span><br><span class="line">        serverLog(LL_VERBOSE,<span class="string">"Accepted cluster node %s:%d"</span>, cip, cport);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 link 结构来处理连接</span></span><br><span class="line">        <span class="comment">// 刚开始的时候， link-&gt;node 被设置成 null，因为现在我们不知道是哪个节点</span></span><br><span class="line">        link = createClusterLink(<span class="literal">NULL</span>);</span><br><span class="line">        link-&gt;fd = cfd;</span><br><span class="line">        aeCreateFileEvent(server.el,cfd,AE_READABLE,clusterReadHandler,link);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到每次 accept 对端connect时，都会创建一个 <code>clusterLink</code> 结构用来接收数据，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterLink</span> &#123;</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;             <span class="comment">/* Link creation time */</span></span><br><span class="line">    <span class="keyword">int</span> fd;                     <span class="comment">/* TCP socket file descriptor */</span></span><br><span class="line">    sds sndbuf;                 <span class="comment">/* Packet send buffer */</span></span><br><span class="line">    sds rcvbuf;                 <span class="comment">/* Packet reception buffer */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span>   <span class="comment">/* Node related to this link if any, or NULL */</span></span><br><span class="line">&#125; clusterLink;</span><br></pre></td></tr></table></figure><p><code>clusterLink</code> 有一个指针是指向 node 自身的。</p><p>B 节点接收到 A 节点发送过来的信息，放到 <code>clusterLink</code> 的 <code>rcvbuf</code> 字段，然后使用 <code>clusterProcessPacket</code> 函数来处理（接收数据过程很简单，不做分析）。</p><p>所以 <code>clusterProcessPacket</code> 函数的作用是处理别人发过来的 gossip 包。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!sender &amp;&amp; type == CLUSTERMSG_TYPE_MEET) &#123;</span><br><span class="line">    clusterNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个带有 CLUSTER_NODE_HANDSHAKE 标记的 cluster node，名字随机</span></span><br><span class="line">    node = createClusterNode(<span class="literal">NULL</span>,CLUSTER_NODE_HANDSHAKE);</span><br><span class="line">    nodeIp2String(node-&gt;ip,link); <span class="comment">// ip 和 port 信息均从 link 中获得</span></span><br><span class="line">    node-&gt;port = ntohs(hdr-&gt;port);</span><br><span class="line"></span><br><span class="line">    clusterAddNode(node);</span><br><span class="line">    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line">clusterSendPing(link,CLUSTERMSG_TYPE_PONG);</span><br></pre></td></tr></table></figure><p>由于这时 B 节点还不认识 A 节点，因此 B 节点从自己的 nodes 中找 A 节点是找不到的，所以 sender 是空，因此会走进如上的这段逻辑。同样以随机的名字，CLUSTER_NODE_HANDSHAKE 为 flag 创建一个 node，加入自己的 nodes 中。</p><p><strong>在这个逻辑末尾会给 A 节点回复一个 PONG 消息</strong>。</p><h3 id="四、A-节点处理-B-节点回复的-PONG-消息"><a href="#四、A-节点处理-B-节点回复的-PONG-消息" class="headerlink" title="四、A 节点处理 B 节点回复的 PONG 消息"></a>四、A 节点处理 B 节点回复的 PONG 消息</h3><p>同样是在 <code>clusterProcessPacket</code> 中处理 gossip 消息。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_PONG || type == CLUSTERMSG_TYPE_MEET) &#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">if</span> (link-&gt;node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeInHandshake(link-&gt;node)) &#123; <span class="comment">// node 处于握手状态</span></span><br><span class="line">            ... ...</span><br><span class="line">            clusterRenameNode(link-&gt;node, hdr-&gt;sender); <span class="comment">// 修正节点名</span></span><br><span class="line">            link-&gt;node-&gt;flags &amp;= ~CLUSTER_NODE_HANDSHAKE; <span class="comment">// 消除 handshake 状态</span></span><br><span class="line">            link-&gt;node-&gt;flags |= flags&amp;(CLUSTER_NODE_MASTER|CLUSTER_NODE_SLAVE);</span><br><span class="line">            clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候 A 节点会根据 B 节点发来的消息，更正 A 节点 nodes 中关于 B 节点的名字，以及消除 <strong>handshake</strong> 状态。</p><h3 id="五、B-节点发送-PING-消息给-A-节点"><a href="#五、B-节点发送-PING-消息给-A-节点" class="headerlink" title="五、B 节点发送 PING 消息给 A 节点"></a>五、B 节点发送 PING 消息给 A 节点</h3><p>当 B 节点在做 <code>clusterCron</code> 时，发现自己看到的 A 节点中的 link 为空，即 <code>node-&gt;link == NULL</code>，这与上面讲的 A 节点给 B 节点发 MEET 消息类似，不过在 B 节点看了 A 节点没有 meet flag，因此发送的是 PING 消息。</p><h3 id="六、A-节点处理-B-节点发来的-PING-消息"><a href="#六、A-节点处理-B-节点发来的-PING-消息" class="headerlink" title="六、A 节点处理 B 节点发来的 PING 消息"></a>六、A 节点处理 B 节点发来的 PING 消息</h3><p>做一些逻辑，不过跟这次要讨论的事情无关，后面会详写。</p><p><strong>对于 PING 和 MEET 消息，无论如何都是会回复一个 PONG 消息的</strong>。</p><h3 id="七、B-节点处理-A-节点回复的-PONG-消息"><a href="#七、B-节点处理-A-节点回复的-PONG-消息" class="headerlink" title="七、B 节点处理 A 节点回复的 PONG 消息"></a>七、B 节点处理 A 节点回复的 PONG 消息</h3><p>逻辑同上，将 B 节点的 nodes 中 A 节点的名字进行更正，然后去掉 A 节点的 handshake flag。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>上面流程的<strong>第四步</strong>之后，在 A 看来 B 节点就已经是个完好的节点了，且建立了 A 到 B 的 link。实际上，上面的<strong>第五至七步</strong>是不确定的，可能存在如下并行逻辑，即，</p><p>A 节点恰好选中了 B 节点发送 PING 消息，当 B 节点接收到这个 PING 消息后，填充自己看到的 A 节点，消除掉 handshake 状态，但是此时 B 节点的 <code>server.cluster-&gt;nodes</code> 中到 A 节点的 link 仍然是空，即，没办法给 A 发 gossip 消息。</p><p>这两个逻辑哪个先发生不一定，但是最终的状态都是，A 节点与 B 节点之间有两条 link，一条是 A 节点创建的到 B 节点的 link，一条是 B 节点创建的到 A 节点的 link。两个节点地位一样，可以同时给对方发信息，如果只保留一条 link 其实也是可以的，不过逻辑会复杂很多，不方便。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，一个 <code>cluster meet</code> 命令执行的完整过程就解释清楚了，画了一个流程图可以帮助更好的理解这个流程。</p><p><img src="http://ww1.sinaimg.cn/mw690/71ca8e3cly1fycksh2170j20pu0nbjst.jpg" alt="cluster meet"></p></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="social-share" data-disabled="google,facebook,qzone,twitter,diandian,linkedin,qzone,tencent"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/3581d0f0.html"><i class="fa fa-chevron-left"></i><span>golang 中下划线的使用</span></a></div><div class="next-post pull-right"><a href="/35a9decf.html"><span>Redis 源码之启动流程</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script>!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script></div></div></div><footer class="footer-bg" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;&nbsp;2016 - 2020 By Happen</div><div class="framework-info"><span>Powered by</span> <a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>