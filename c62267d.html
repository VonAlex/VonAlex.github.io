<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/dolphin.png"><link rel="icon" type="image/png" href="/images/dolphin.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="Happen"><meta name="keywords" content=""><title>Redis 源码之 cluster meet - Happen&#39;s Memo</title><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css"><link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"><link rel="stylesheet" href="/css/main.css"><link defer="defer" rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="/css/custom.css"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"> <a class="navbar-brand" href="/">&nbsp;<strong>Happen's Memo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"> <a class="nav-link" href="/">首页</a></li><li class="nav-item"> <a class="nav-link" href="/archives/">归档</a></li><li class="nav-item"> <a class="nav-link" href="/categories/">分类</a></li><li class="nav-item"> <a class="nav-link" href="/tags/">标签</a></li><li class="nav-item"> <a class="nav-link" href="/about/">关于</a></li><li class="nav-item" id="search-btn"> <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" parallax="true" style="background:url(/images/about-banner.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask rgba-black-light flex-center"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><p class="mt-3 post-meta"><i class="fas fa-calendar-alt" aria-hidden="true"></i> 2018/12/10, 星期一, 00:02</p><p class="mt-1"><span class="post-meta"><i class="far fa-chart-bar"></i> 3.4k 字</span><span class="post-meta"><i class="far fa-clock"></i> 14 分钟</span><span id="busuanzi_container_page_pv" class="post-meta" style="display:none"><i class="far fa-eye" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span> 次</span></p></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5 z-depth-3" id="board"><div class="post-content mx-auto" id="post"><p class="note note-warning">本文最后更新于：2020/04/03, 星期五, 01:46</p><div class="markdown-body"><p>Redis cluster 是 redis 官方提出的分布式集群解决方案，在此之前，有一些第三方的可选方案，如 codis、Twemproxy 等。cluster 内部使用了 gossip 协议进行通信，以达到数据的最终一致性。详细介绍可参考官网 <a href="https://redis.io/topics/cluster-tutorial" target="_blank" rel="noopener">Redis cluster tutorial</a>。</p><p>本文试图借着<code>cluster meet</code> 命令的实现来对其中的一些通信细节一探究竟。</p><a id="more"></a><p>我们都知道，当 redis server 以 cluster mode 启动时，节点 B 想加入节点 A 所在的集群，只需要执行 <code>CLUSTER MEET ip port</code> 这个命令即可，通过 gossip 通信，最终 A 所在集群的其他节点也都会认识到 B。大概流程图如下：</p><h2 id="cluster- 初始化">cluster 初始化</h2><p>当 redis server 以 cluster mode 启动时，即配置文件中的 <code>cluster-enabled</code> 选项设置为 <code>true</code>，此时在服务启动时，会有一个 cluster 初始化的流程，这个在之前的文章 《<a href="http://tech-happen.site/e74c6d55.html" target="_blank" rel="noopener">Redis 启动流程</a>》中有提到过，即执行函数 <code>clusterInit</code>。在 cluster 中有三个数据结构很重要， <code>clusterState</code> 、 <code>clusterNode</code> 和 <code>clusterLink</code>。</p><p>每个节点都保存着一个 <code>clusterState</code> 结构，这个结构记录了在当前节点的视角下，集群目前所处的状态，即“我看到的世界是什么样子”。</p><p>每个节点都会使用一个 <code>clusterNode</code> 结构来记录自己的状态， 并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的 <code>clusterNode</code> 结构， 以此来记录其他节点的状态。</p><p><code>clusterNode</code> 结构的 <code>link</code> 属性是一个 <code>clusterLink</code> 结构， 该结构保存了连接节点所需的有关信息， 比如套接字描述符， 输入缓冲区和输出缓冲区。</p><p>更多的细节可以通过网页 《<a href="http://redisbook.com/preview/cluster/node.html" target="_blank" rel="noopener">redis 设计与实现 - 节点</a>》进行了解。</p><p>该初始化很简单，首先是创建一个 <code>clusterState</code> 结构，并初始化一些成员，如下：</p><pre><code class="language-c">server.cluster = zmalloc(sizeof(clusterState));
server.cluster-&gt;myself = NULL;
server.cluster-&gt;currentEpoch = 0;     // 新节点的 currentEpoch = 0
server.cluster-&gt;state = CLUSTER_FAIL; // 初始状态置为 FAIL
server.cluster-&gt;size = 1;
server.cluster-&gt;todo_before_sleep = 0;
server.cluster-&gt;nodes = dictCreate(&amp;clusterNodesDictType,NULL);
server.cluster-&gt;nodes_black_list = dictCreate(&amp;clusterNodesBlackListDictType,NULL);
server.cluster-&gt;failover_auth_time = 0;
server.cluster-&gt;failover_auth_count = 0;
server.cluster-&gt;failover_auth_rank = 0;
server.cluster-&gt;failover_auth_epoch = 0;
server.cluster-&gt;cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;
server.cluster-&gt;lastVoteEpoch = 0;
server.cluster-&gt;stats_bus_messages_sent = 0;
server.cluster-&gt;stats_bus_messages_received = 0;
memset(server.cluster-&gt;slots,0, sizeof(server.cluster-&gt;slots));
clusterCloseAllSlots(); // Clear the migrating/importing state for all the slots
</code></pre><p>然后给 node.conf 文件加锁，确保每个节点使用自己的 cluster 配置文件。</p><pre><code class="language-c">if (clusterLockConfig(server.cluster_configfile) == C_ERR)
    exit(1);
</code></pre><p>借着这个机会学习下 redis 如何使用的文件锁。</p><pre><code class="language-c">int fd = open(filename,O_WRONLY|O_CREAT,0644);
if (fd == -1) {
    serverLog(LL_WARNING,
              &quot;Can't open %s in order to acquire a lock: %s&quot;,
              filename, strerror(errno));
    return C_ERR;
}

if (flock(fd,LOCK_EX|LOCK_NB) == -1) {if (errno == EWOULDBLOCK) {
        serverLog(LL_WARNING,
                  &quot;Sorry, the cluster configuration file %s is already used &quot;
                  &quot;by a different Redis Cluster node. Please make sure that &quot;
                  &quot;different nodes use different cluster configuration &quot;
                  &quot;files.&quot;, filename);
    } else {
        serverLog(LL_WARNING,
                  &quot;Impossible to lock %s: %s&quot;, filename, strerror(errno));
    }
    close(fd);
    return C_ERR;
}
</code></pre><p>然后加载 node.conf 文件，这个过程还会检查这个文件是否合理。</p><p>如果加载失败（或者配置文件不存在），则以 <code>REDIS_NODE_MYSELF|REDIS_NODE_MASTER</code> 为标记，创建一个 clusterNode 结构表示自己本身，置为主节点，并设置自己的名字为一个 40 字节的随机串；然后将该节点添加到 server.cluster-&gt;nodes 中，这说明这是个新启动的节点，生成的配置文件进行刷盘。</p><pre><code class="language-c">if (clusterLoadConfig(server.cluster_configfile) == C_ERR) {
    myself = server.cluster-&gt;myself =
        createClusterNode(NULL,CLUSTER_NODE_MYSELF|CLUSTER_NODE_MASTER);
    serverLog(LL_NOTICE,&quot;No cluster configuration found, I'm %.40s&quot;,
              myself-&gt;name);
    clusterAddNode(myself);
    saveconf = 1;
}
if (saveconf) clusterSaveConfigOrDie(1); // 新节点，将配置刷到配置文件中，fsync
</code></pre><p>接下来，调用 <code>listenToPort</code> 函数，在集群 gossip 通信端口上创建 socket fd 进行监听。集群内 gossip 通信端口是在 <strong>Redis 监听端口基础上加 10000</strong>，比如如果 Redis 监听客户端的端口为 6379，则集群监听端口就是 16379，该监听端口用于接收其他集群节点发送过来的 gossip 消息。</p><p>然后注册监听端口上的可读事件，事件回调函数为 <code>clusterAcceptHandler</code>。</p><pre><code class="language-c">#define CLUSTER_PORT_INCR 10000

if (listenToPort(server.port+CLUSTER_PORT_INCR,
                 server.cfd,&amp;server.cfd_count) == C_ERR)
{exit(1);
} else {
    int j;
    for (j = 0; j &lt; server.cfd_count; j++) {if (aeCreateFileEvent(server.el, server.cfd[j], AE_READABLE,
                              clusterAcceptHandler, NULL) == AE_ERR)
            serverPanic(&quot;Unrecoverable error creating Redis Cluster &quot;
                        &quot;file event.&quot;);
    }
}
</code></pre><p>当前节点收到其他集群节点发来的 TCP 建链请求之后，就会调用 <code>clusterAcceptHandler</code> 函数 accept 连接。在 <code>clusterAcceptHandler</code>函数中，对于每个已经 accept 的链接，都会创建一个<code>clusterLink</code> 结构表示该链接，并注册 socket fd 上的可读事件，事件回调函数为 <code>clusterReadHandler</code>。</p><pre><code class="language-c">#define MAX_CLUSTER_ACCEPTS_PER_CALL 1000
void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    int cport, cfd;
    int max = MAX_CLUSTER_ACCEPTS_PER_CALL;
    char cip[NET_IP_STR_LEN];
    clusterLink *link;
    ... ...
    // 如果服务器正在启动，不要接受其他节点的连接, 因为 UPDATE 消息可能会干扰数据库内容
    if (server.masterhost == NULL &amp;&amp; server.loading) return;
    while(max--) {cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &amp;cport);
        if (cfd == ANET_ERR) {if (errno != EWOULDBLOCK)
                serverLog(LL_VERBOSE,
                    &quot;Error accepting cluster node: %s&quot;, server.neterr);
            return;
        }
        anetNonBlock(NULL,cfd);
        anetEnableTcpNoDelay(NULL,cfd);
        ... ...
        // 创建一个 link 结构来处理连接
        // 刚开始的时候， link-&gt;node 被设置成 null，因为现在我们不知道是哪个节点
        link = createClusterLink(NULL);
        link-&gt;fd = cfd;
        aeCreateFileEvent(server.el,cfd,AE_READABLE,clusterReadHandler,link);
    }
}
</code></pre><p>最后是 reset mf 相关的参数。</p><h2 id="CLUSTER-MEET">CLUSTER MEET</h2><h3 id="一、A- 节点接收 -CLUSTER-MEET- 命令">一、A 节点接收 CLUSTER MEET 命令</h3><p>A 节点在<code>cluster.c</code> -&gt; <code>clusterCommand</code> 函数中，接收到 <code>CLUSTER MEET</code> 命令，即</p><pre><code class="language-c">if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;meet&quot;) &amp;&amp; c-&gt;argc == 4) {
    long long port;

    // CLUSTER MEET &lt;ip&gt; &lt;port&gt;
    if (getLongLongFromObject(c-&gt;argv[3], &amp;port) != C_OK) {addReplyErrorFormat(c,&quot;Invalid TCP port specified: %s&quot;, (char*)c-&gt;argv[3]-&gt;ptr);
        return;
    }
    if (clusterStartHandshake(c-&gt;argv[2]-&gt;ptr,port) == 0 &amp;&amp; errno == EINVAL)
    {
        addReplyErrorFormat(c,&quot;Invalid node address specified: %s:%s&quot;,
                            (char*)c-&gt;argv[2]-&gt;ptr, (char*)c-&gt;argv[3]-&gt;ptr);
    } else {addReply(c,shared.ok);
    }
}
</code></pre><p>可以看到重点在 <code>clusterStartHandshake</code> 这个函数。</p><pre><code class="language-c">int clusterStartHandshake(char *ip, int port) {
    clusterNode *n;
    char norm_ip[NET_IP_STR_LEN];
    struct sockaddr_storage sa;
    /* IP and Port sanity check */
    ... ...

    // 检查节点(flag) norm_ip:port 是否正在握手
    if (clusterHandshakeInProgress(norm_ip,port)) {
        errno = EAGAIN;
        return 0;
    }
    // 创建一个含随机名字的 node，type 为 CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_MEET
    // 相关信息会在 handshake 过程中被修复
    n = createClusterNode(NULL,CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_MEET);
    memcpy(n-&gt;ip,norm_ip,sizeof(n-&gt;ip));
    n-&gt;port = port;
    clusterAddNode(n);
    return 1;
}
</code></pre><pre><code class="language-c">clusterNode *createClusterNode(char *nodename, int flags) {clusterNode *node = zmalloc(sizeof(*node));
    if (nodename)
        memcpy(node-&gt;name, nodename, CLUSTER_NAMELEN);
    else
        // 在本地新建一个 nodename 节点，节点名字随机，跟它通信时它会告诉我真实名字
        getRandomHexChars(node-&gt;name, CLUSTER_NAMELEN);
    node-&gt;ctime = mstime(); // mstime
    node-&gt;configEpoch = 0;
    node-&gt;flags = flags;
    memset(node-&gt;slots,0,sizeof(node-&gt;slots));
    node-&gt;slaveof = NULL;
    ... ...
    node-&gt;link = NULL; // link 为空, 在 clusterCron 中能检查的到
    memset(node-&gt;ip,0,sizeof(node-&gt;ip));
    node-&gt;port = 0;
    node-&gt;fail_reports = listCreate();
    ... ...
    listSetFreeMethod(node-&gt;fail_reports,zfree);
    return node;
}
</code></pre><p>这个函数会首先进行一些 ip 和 port 的合理性检查，然后去遍历所看到的 nodes，这个 ip:port 对应的 node 是不是正处于 <code>CLUSTER_NODE_HANDSHAKE</code> 状态，是的话，就说明这是重复 meet，没必要往下走。之后，通过 <code>createClusterNode</code> 函数创建一个带有 <code>CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_MEET</code> 标记的节点，名字为一个 <strong>随机</strong> 的 40 字节字符串（因为此时对 A 来说，B 是一个陌生的节点，信息除了 ip 和 port，其他都不知道），通过 <code>clusterAddNode</code> 函数加到自己的 nodes 中。</p><p>这个过程成功后，就返回给客户端 OK 了，其他事情需要通过 gossip 通信去做。</p><h3 id="二、A- 节点发送 -MEET- 消息给 -B- 节点">二、A 节点发送 MEET 消息给 B 节点</h3><p>A 节点在定时任务 <code>clusterCron</code> 中，会做一些事情。</p><pre><code class="language-c">handshake_timeout = server.cluster_node_timeout;
if (handshake_timeout &lt; 1000) handshake_timeout = 1000;

// 检查是否有 disconnected nodes 并且重新建立连接
di = dictGetSafeIterator(server.cluster-&gt;nodes); // 遍历所有节点
while((de = dictNext(di)) != NULL) {clusterNode *node = dictGetVal(de);

     // 忽略掉 myself 和 noaddr 状态的节点
    if (node-&gt;flags &amp; (CLUSTER_NODE_MYSELF|CLUSTER_NODE_NOADDR)) continue;

    // 节点处于 handshake 状态，且状态维持时间超过 handshake_timeout，那么从 nodes 中删掉它
    if (nodeInHandshake(node) &amp;&amp; now - node-&gt;ctime &gt; handshake_timeout) {clusterDelNode(node);
        continue;
    }

    // 刚刚收到 cluster meet 命令创建的新 node ，或是 server 刚启动，或是由于某种原因断开了
    if (node-&gt;link == NULL) {
        int fd;
        mstime_t old_ping_sent;
        clusterLink *link;

        // 对端 gossip 通信端口为 node 端口 + 10000，创建 tcp 连接, 本节点相当于 client
        fd = anetTcpNonBlockBindConnect(server.neterr, node-&gt;ip, node-&gt;port+CLUSTER_PORT_INCR, NET_FIRST_BIND_ADDR);
        ... ...
        link = createClusterLink(node);
        link-&gt;fd = fd;
        node-&gt;link = link;

        // 注册 link-&gt;fd 上的可读事件，事件回调函数为 clusterReadHandler
        aeCreateFileEvent(server.el,link-&gt;fd,AE_READABLE, clusterReadHandler,link);
        ... ...

        // 如果 node 带有 MEET flag，我们发送一个 MEET 包而不是 PING,
        // 这是为了强制让接收者把我们加到它的 nodes 中
        clusterSendPing(link, node-&gt;flags &amp; CLUSTER_NODE_MEET ? CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING);
        ... ...
        node-&gt;flags &amp;= ~CLUSTER_NODE_MEET;
        ... ...
    }
}
dictReleaseIterator(di);
</code></pre><p>可以看到，遍历自己看到的 nodes，当遍历到 B 节点时，由于 <code>node-&gt;link == NULL</code>，因此会监听 B 的启动端口号 +10000，即 gossip 通信端口，然后注册可读事件，处理函数为 <code>clusterReadHandler</code>。接着会发送 <strong>CLUSTER_NODE_MEET</strong> 消息给 B 节点，消除掉 B 节点的 <strong>meet</strong> 状态。</p><h3 id="三、B- 节点处理 -A- 发来的 -MEET- 消息">三、B 节点处理 A 发来的 MEET 消息</h3><p>当 B 节点接收到 A 节点发送 gossip 时，回调函数 <code>clusterAcceptHandler</code> 进行处理，然后会 accept 对端的 connect（B 作为 server，对端作为 client），注册可读事件，回调函数为 <code>clusterReadHandler</code>，基本逻辑如下，</p><pre><code class="language-c">void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    int cport, cfd;
    int max = MAX_CLUSTER_ACCEPTS_PER_CALL;
    char cip[NET_IP_STR_LEN];
    clusterLink *link;
    UNUSED(el);
    UNUSED(mask);
    UNUSED(privdata);

    // 如果服务器正在启动，不要接受其他节点的链接，因为 UPDATE 消息可能会干扰数据库内容
    if (server.masterhost == NULL &amp;&amp; server.loading) return;
    while(max--) { // 1000 个请求
        cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &amp;cport);
        if (cfd == ANET_ERR) {if (errno != EWOULDBLOCK)
                serverLog(LL_VERBOSE,
                    &quot;Error accepting cluster node: %s&quot;, server.neterr);
            return;
        }
        anetNonBlock(NULL,cfd);
        anetEnableTcpNoDelay(NULL,cfd);
        serverLog(LL_VERBOSE,&quot;Accepted cluster node %s:%d&quot;, cip, cport);

        // 创建一个 link 结构来处理连接
        // 刚开始的时候， link-&gt;node 被设置成 null，因为现在我们不知道是哪个节点
        link = createClusterLink(NULL);
        link-&gt;fd = cfd;
        aeCreateFileEvent(server.el,cfd,AE_READABLE,clusterReadHandler,link);
    }
}
</code></pre><p>可以看到每次 accept 对端 connect 时，都会创建一个 <code>clusterLink</code> 结构用来接收数据，</p><pre><code class="language-c">typedef struct clusterLink {
    mstime_t ctime;             /* Link creation time */
    int fd;                     /* TCP socket file descriptor */
    sds sndbuf;                 /* Packet send buffer */
    sds rcvbuf;                 /* Packet reception buffer */
    struct clusterNode *node;   /* Node related to this link if any, or NULL */
} clusterLink;
</code></pre><p><code>clusterLink</code> 有一个指针是指向 node 自身的。</p><p>B 节点接收到 A 节点发送过来的信息，放到 <code>clusterLink</code> 的 <code>rcvbuf</code> 字段，然后使用 <code>clusterProcessPacket</code> 函数来处理（接收数据过程很简单，不做分析）。</p><p>所以 <code>clusterProcessPacket</code> 函数的作用是处理别人发过来的 gossip 包。</p><pre><code class="language-c">if (!sender &amp;&amp; type == CLUSTERMSG_TYPE_MEET) {
    clusterNode *node;

    // 创建一个带有 CLUSTER_NODE_HANDSHAKE 标记的 cluster node，名字随机
    node = createClusterNode(NULL,CLUSTER_NODE_HANDSHAKE);
    nodeIp2String(node-&gt;ip,link); // ip 和 port 信息均从 link 中获得
    node-&gt;port = ntohs(hdr-&gt;port);

    clusterAddNode(node);
    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
}
.....
clusterSendPing(link,CLUSTERMSG_TYPE_PONG);
</code></pre><p>由于这时 B 节点还不认识 A 节点，因此 B 节点从自己的 nodes 中找 A 节点是找不到的，所以 sender 是空，因此会走进如上的这段逻辑。同样以随机的名字，CLUSTER_NODE_HANDSHAKE 为 flag 创建一个 node，加入自己的 nodes 中。</p><p><strong>在这个逻辑末尾会给 A 节点回复一个 PONG 消息</strong>。</p><h3 id="四、A- 节点处理 -B- 节点回复的 -PONG- 消息">四、A 节点处理 B 节点回复的 PONG 消息</h3><p>同样是在 <code>clusterProcessPacket</code> 中处理 gossip 消息。</p><pre><code class="language-c">if (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_PONG || type == CLUSTERMSG_TYPE_MEET) {
    ... ...
    if (link-&gt;node) {if (nodeInHandshake(link-&gt;node)) { // node 处于握手状态
            ... ...
            clusterRenameNode(link-&gt;node, hdr-&gt;sender); // 修正节点名
            link-&gt;node-&gt;flags &amp;= ~CLUSTER_NODE_HANDSHAKE; // 消除 handshake 状态
            link-&gt;node-&gt;flags |= flags&amp;(CLUSTER_NODE_MASTER|CLUSTER_NODE_SLAVE);
            clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
        }
}
</code></pre><p>这个时候 A 节点会根据 B 节点发来的消息，更正 A 节点 nodes 中关于 B 节点的名字，以及消除 <strong>handshake</strong> 状态。</p><h3 id="五、B- 节点发送 -PING- 消息给 -A- 节点">五、B 节点发送 PING 消息给 A 节点</h3><p>当 B 节点在做 <code>clusterCron</code> 时，发现自己看到的 A 节点中的 link 为空，即 <code>node-&gt;link == NULL</code>，这与上面讲的 A 节点给 B 节点发 MEET 消息类似，不过在 B 节点看了 A 节点没有 meet flag，因此发送的是 PING 消息。</p><h3 id="六、A- 节点处理 -B- 节点发来的 -PING- 消息">六、A 节点处理 B 节点发来的 PING 消息</h3><p>做一些逻辑，不过跟这次要讨论的事情无关，后面会详写。</p><p><strong>对于 PING 和 MEET 消息，无论如何都是会回复一个 PONG 消息的</strong>。</p><h3 id="七、B- 节点处理 -A- 节点回复的 -PONG- 消息">七、B 节点处理 A 节点回复的 PONG 消息</h3><p>逻辑同上，将 B 节点的 nodes 中 A 节点的名字进行更正，然后去掉 A 节点的 handshake flag。</p><h3 id="补充">补充</h3><p>上面流程的 <strong>第四步</strong> 之后，在 A 看来 B 节点就已经是个完好的节点了，且建立了 A 到 B 的 link。实际上，上面的 <strong>第五至七步</strong> 是不确定的，可能存在如下并行逻辑，即，</p><p>A 节点恰好选中了 B 节点发送 PING 消息，当 B 节点接收到这个 PING 消息后，填充自己看到的 A 节点，消除掉 handshake 状态，但是此时 B 节点的 <code>server.cluster-&gt;nodes</code> 中到 A 节点的 link 仍然是空，即，没办法给 A 发 gossip 消息。</p><p>这两个逻辑哪个先发生不一定，但是最终的状态都是，A 节点与 B 节点之间有两条 link，一条是 A 节点创建的到 B 节点的 link，一条是 B 节点创建的到 A 节点的 link。两个节点地位一样，可以同时给对方发信息，如果只保留一条 link 其实也是可以的，不过逻辑会复杂很多，不方便。</p><h2 id="小结">小结</h2><p>至此，一个 <code>cluster meet</code> 命令执行的完整过程就解释清楚了，画了一个流程图可以帮助更好的理解这个流程。</p><p><img src="http://ww1.sinaimg.cn/mw690/71ca8e3cly1fycksh2170j20pu0nbjst.jpg" srcset="/img/loading.gif" alt="cluster meet"></p></div><hr><div><p><span><i class="iconfont icon-inbox"></i> <a class="hover-with-bg" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a> &nbsp;</span> &nbsp;&nbsp;<span><i class="iconfont icon-tag"></i> <a class="hover-with-bg" href="/tags/redis/">redis</a></span></p><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="post-prevnext row"><div class="post-prev col-6"><a href="/3581d0f0.html"><i class="fa fa-chevron-left"></i> <span class="hidden-mobile">golang 中下划线的使用</span> <span class="visible-mobile">上一篇</span></a></div><div class="post-next col-6"> <a href="/35a9decf.html"><span class="hidden-mobile">Redis 源码之启动流程</span> <span class="visible-mobile">下一篇</span><i class="fa fa-chevron-right"></i></a></div></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script type="text/javascript">!function(e,t){var r,n=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((r=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",r.defer=!0,n.parentNode.insertBefore(r,n))}(document,"script")</script><noscript> 为正常使用来必力评论功能请激活JavaScript</noscript></div></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc-start"></div><div id="toc"><p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-md"><div class="container custom post-content mx-auto"> <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px;height:150px"></div></div></main><a class="z-depth-1" id="scroll-top-button" href="#" role="button"><i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4> <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"> <span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"> <input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a><i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><b>Fluid</b></a></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script><script>$(document).ready(function(){var s=$("#navbar").height(),c=$("#toc"),t=$("#board-ctn"),o=t.offset().top,i=2*o+t.height();$(window).scroll(function(){var t=$("#toc-start").offset().top-s,o=document.body.scrollTop+document.documentElement.scrollTop;t<=o&&o<=i?c.css({display:"block",position:"fixed",top:s}):o<=t?c.css({position:"",top:""}):i<o&&c.css("display","none")}),tocbot.init({tocSelector:"#tocbot",contentSelector:".post-content",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,headingsOffset:-o}),0<$(".toc-list-item").length&&$("#toc > p").css("visibility","visible");var l=t.css("margin-right");$("#toc-ctn").css({right:l})})</script><script defer="defer" src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer="defer" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script defer="defer">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?882b48640075e00a238ae94a7eec0d40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script defer="defer">var _mtac={};!function(){var t=document.createElement("script");t.src="//pingjs.qq.com/h5/stats.js?v2.0.4",t.setAttribute("name","MTAH5"),t.setAttribute("sid","");var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js"></script><script>$(document).ready(function(){$("pre").addClass("prettyprint  "),prettyPrint()})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","Redis 源码之 cluster meet&nbsp;"],cursorChar:"_",typeSpeed:75,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){getSearchFile(path),this.onclick=null}</script><script defer="defer" src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><script>$("#post img:not(.no-zoom img, img[no-zoom])").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>