<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/dolphin.png"><link rel="icon" type="image/png" href="/images/dolphin.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#433d3c"><meta name="description" content=""><meta name="author" content="Happen"><meta name="keywords" content=""><title>Redigo 源码分析 - HappenのMemo</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/monokai.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body><header style="height:60vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>HappenのMemo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(https://gitee.com/happencc/pics/raw/master/images/about-banner.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"><span class="h2" id="subtitle"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Happen </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2019-06-23 16:08" pubdate>2019-06-23 16:08</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.2k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 64 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">Redigo 源码分析</h1><p class="note note-info">本文最后更新于：2019-06-23 16:08</p><div class="markdown-body" id="post-body"><p>使用 golang 开发项目时经常会使用到 redis 服务，这时就需要一个趁手的 sdk，所以就在 github 中找了一个 star 较多的项目，这就是本篇的主角 <strong>redigo</strong>，同时这也是 redis 的 <a target="_blank" rel="noopener" href="https://redis.io/clients#go">官方推荐</a>。</p><p>不过在使用过程中遇到了一些小问题，因此就去了解了一下源码，以下作为一个笔记。</p><!--more----><p>redigo 项目代码量较少，且注释明确，适合阅读学习。<br>redigo 主要完成了以下功能:</p><ul><li><p>与 redis server 建立连接</p></li><li><p>按照 <a target="_blank" rel="noopener" href="https://redis.io/topics/protocol">RESP</a> 协议进行命令组装</p></li><li><p>向 Redis server 发送组装好的命令</p></li><li><p>接收 Redis server 返回的数据</p></li><li><p>将返回数据解析成 go 的数据类型</p></li><li><p>提供连接池的使用方式</p></li></ul><h2 id="1- 代码结构">1. 代码结构</h2><div class="hljs"><pre><code class="hljs shell">redis
├── conn.go  // 实现 redis.go 中定义的接口，完成以上主要功能
├── conn_test.go
├── doc.go
├── go17.go
├── log.go
├── pool.go // pool 相关代码
├── pool_test.go
├── pre_go17.go
├── pubsub.go
├── pubsub_test.go
├── redis.go // 定义接口
├── reply.go // 返回数据的类型转换
├── reply_test.go
├── scan.go
├── scan_test.go
├── script.go // lua 脚本相关代码
├── script_test.go
├── test_test.go
└── zpop_example_test.go</code></pre></div><p>项目主体主要有以上代码组成。</p><h2 id="2- 创建连接">2. 创建连接</h2><p>代码位于文件 <code>conn.go</code>，要创建的连接是一个自定义的数据结构 <code>conn</code>，如下，</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// conn is the low-level implementation of Conn</span>
<span class="hljs-keyword">type</span> conn <span class="hljs-keyword">struct</span> &#123;
    <span class="hljs-comment">// Shared</span>
    mu      sync.Mutex
    pending <span class="hljs-keyword">int</span> <span class="hljs-comment">// 命令计数</span>
    err     error
    conn    net.Conn

    <span class="hljs-comment">// Read</span>
    readTimeout time.Duration
    br          *bufio.Reader

    <span class="hljs-comment">// Write</span>
    writeTimeout time.Duration
    bw           *bufio.Writer

    <span class="hljs-comment">// Scratch space for formatting argument length.</span>
    <span class="hljs-comment">// &#x27;*&#x27; or &#x27;$&#x27;, length, &quot;\r\n&quot;</span>
    lenScratch [<span class="hljs-number">32</span>]<span class="hljs-keyword">byte</span>

    <span class="hljs-comment">// Scratch space for formatting integers and floats.</span>
    numScratch [<span class="hljs-number">40</span>]<span class="hljs-keyword">byte</span>
&#125;</code></pre></div><p>创建连接所需要的参数统一封装到结构体 <code>dialOptions</code> 中，如下，</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> dialOptions <span class="hljs-keyword">struct</span> &#123;
    readTimeout  time.Duration
    writeTimeout time.Duration
    dial         <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(network, addr <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(net.Conn, error)</span></span>
    db           <span class="hljs-keyword">int</span>
    password     <span class="hljs-keyword">string</span>
    dialTLS      <span class="hljs-keyword">bool</span>
    skipVerify   <span class="hljs-keyword">bool</span>
    tlsConfig    *tls.Config
&#125;</code></pre></div><p>其中包含各种超时设置，创建连接使用的函数，以及 TLS 等。<br>参数设置则封装了一系列 <code>Dialxxxx</code> 函数，如 <code>DialWriteTimeout</code>,</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// DialWriteTimeout specifies the timeout for writing a single command.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DialWriteTimeout</span><span class="hljs-params">(d time.Duration)</span> <span class="hljs-title">DialOption</span></span> &#123;
    <span class="hljs-keyword">return</span> DialOption&#123;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(do *dialOptions)</span></span> &#123;
      do.writeTimeout = d
    &#125;&#125;
&#125;</code></pre></div><p>同时需要结合如下结构体完成，</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> DialOption <span class="hljs-keyword">struct</span> &#123;
  	f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*dialOptions)</span></span>
&#125;</code></pre></div><p>创建连接时使用的是 <code>Dial</code> 函数</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Dial connects to the Redis server at the given network and</span>
<span class="hljs-comment">// address using the specified options.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Dial</span><span class="hljs-params">(network, address <span class="hljs-keyword">string</span>, options ...DialOption)</span> <span class="hljs-params">(Conn, error)</span></span> &#123;
    do := dialOptions&#123;
      dial: net.Dial,
    &#125;
    <span class="hljs-keyword">for</span> _, option := <span class="hljs-keyword">range</span> options &#123; <span class="hljs-comment">// 设置</span>
      option.f(&amp;do)
    &#125;

    netConn, err := do.dial(network, address)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
    &#125;

    <span class="hljs-comment">// TLS 相关</span>
    <span class="hljs-comment">// ...</span>

    c := &amp;conn&#123;
      conn:         netConn,
      bw:           bufio.NewWriter(netConn),
      br:           bufio.NewReader(netConn),
      readTimeout:  do.readTimeout,
      writeTimeout: do.writeTimeout,
    &#125;

    <span class="hljs-keyword">if</span> do.password != <span class="hljs-string">&quot;&quot;</span> &#123;
      <span class="hljs-keyword">if</span> _, err := c.Do(<span class="hljs-string">&quot;AUTH&quot;</span>, do.password); err != <span class="hljs-literal">nil</span> &#123;
        netConn.Close()
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
      &#125;
    &#125;

    <span class="hljs-keyword">if</span> do.db != <span class="hljs-number">0</span> &#123;
      <span class="hljs-keyword">if</span> _, err := c.Do(<span class="hljs-string">&quot;SELECT&quot;</span>, do.db); err != <span class="hljs-literal">nil</span> &#123;
        netConn.Close()
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
      &#125;
    &#125;
    <span class="hljs-keyword">return</span> c, <span class="hljs-literal">nil</span>
&#125;</code></pre></div><p>还有一个类似的 <code>DialURL</code> 函数就不分析了。</p><h2 id="3- 请求与接收">3. 请求与接收</h2><p>非 pipeline 的形式，都是通过 <code>Do</code> 函数去触发这个流程的。</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span> <span class="hljs-title">Do</span><span class="hljs-params">(cmd <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;
    c.mu.Lock() <span class="hljs-comment">// 需要更新 pending 变量，加锁串行</span>
    pending := c.pending
    c.pending = <span class="hljs-number">0</span>
    c.mu.Unlock()

    <span class="hljs-keyword">if</span> cmd == <span class="hljs-string">&quot;&quot;</span> &amp;&amp; pending == <span class="hljs-number">0</span> &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>
    &#125;

    <span class="hljs-keyword">if</span> c.writeTimeout != <span class="hljs-number">0</span> &#123;
      c.conn.SetWriteDeadline(time.Now().Add(c.writeTimeout)) <span class="hljs-comment">// 设置写超时</span>
    &#125;

    <span class="hljs-keyword">if</span> cmd != <span class="hljs-string">&quot;&quot;</span> &#123;
      <span class="hljs-keyword">if</span> err := c.writeCommand(cmd, args); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 将要发送的命令以 RESP 协议写到写 buf 里</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, c.fatal(err)
      &#125;
    &#125;

    <span class="hljs-keyword">if</span> err := c.bw.Flush(); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// buff flush，发送命令</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, c.fatal(err)
    &#125;

    <span class="hljs-keyword">if</span> c.readTimeout != <span class="hljs-number">0</span> &#123;
      c.conn.SetReadDeadline(time.Now().Add(c.readTimeout)) <span class="hljs-comment">// 设置写超时</span>
    &#125;

    <span class="hljs-keyword">if</span> cmd == <span class="hljs-string">&quot;&quot;</span> &#123;
      reply := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, pending)
      <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> reply &#123;
        r, e := c.readReply()
        <span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, c.fatal(e)
        &#125;
        reply[i] = r
      &#125;
      <span class="hljs-keyword">return</span> reply, <span class="hljs-literal">nil</span>
    &#125;

    <span class="hljs-keyword">var</span> err error
    <span class="hljs-keyword">var</span> reply <span class="hljs-keyword">interface</span>&#123;&#125;
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= pending; i++ &#123;
      <span class="hljs-keyword">var</span> e error
      <span class="hljs-keyword">if</span> reply, e = c.readReply(); e != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 解析返回值</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, c.fatal(e)
      &#125;
      <span class="hljs-keyword">if</span> e, ok := reply.(Error); ok &amp;&amp; err == <span class="hljs-literal">nil</span> &#123;
        err = e
      &#125;
    &#125;
    <span class="hljs-keyword">return</span> reply, err
&#125;</code></pre></div><h3 id="3-1- 发送命令">3.1 发送命令</h3><p>发送命令前必须以 RESP 协议序列化，主要用到以下函数，</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span> <span class="hljs-title">writeCommand</span><span class="hljs-params">(cmd <span class="hljs-keyword">string</span>, args []<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(err error)</span></span> &#123;
    c.writeLen(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">1</span>+<span class="hljs-built_in">len</span>(args)) <span class="hljs-comment">// +1 是将 cmd 加上，将参数个数写入 buf， 如 *3\r\n</span>
    err = c.writeString(cmd)
    <span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> args &#123;
      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
        <span class="hljs-keyword">break</span>
      &#125;
      <span class="hljs-keyword">switch</span> arg := arg.(<span class="hljs-keyword">type</span>) &#123;
      <span class="hljs-keyword">case</span> <span class="hljs-keyword">string</span>:
        err = c.writeString(arg)
      <span class="hljs-keyword">case</span> []<span class="hljs-keyword">byte</span>:
        err = c.writeBytes(arg)
      <span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>:
        err = c.writeInt64(<span class="hljs-keyword">int64</span>(arg))
      <span class="hljs-keyword">case</span> <span class="hljs-keyword">int64</span>:
        err = c.writeInt64(arg)
      <span class="hljs-keyword">case</span> <span class="hljs-keyword">float64</span>:
        err = c.writeFloat64(arg)
      <span class="hljs-keyword">case</span> <span class="hljs-keyword">bool</span>:
        <span class="hljs-keyword">if</span> arg &#123;
          err = c.writeString(<span class="hljs-string">&quot;1&quot;</span>)
        &#125; <span class="hljs-keyword">else</span> &#123;
          err = c.writeString(<span class="hljs-string">&quot;0&quot;</span>)
        &#125;
      <span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:
        err = c.writeString(<span class="hljs-string">&quot;&quot;</span>)
      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">var</span> buf bytes.Buffer
        fmt.Fprint(&amp;buf, arg)
        err = c.writeBytes(buf.Bytes())
      &#125;
    &#125;
    <span class="hljs-keyword">return</span> err
&#125;</code></pre></div><div class="hljs"><pre><code class="hljs go"> <span class="hljs-comment">// 用来写参数长度和参数个数，通过前缀传入 * 还是 $ 决定, 如 *3\r\n 或者 $3\r\n</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span> <span class="hljs-title">writeLen</span><span class="hljs-params">(prefix <span class="hljs-keyword">byte</span>, n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">error</span></span> &#123;
    c.lenScratch[<span class="hljs-built_in">len</span>(c.lenScratch)<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;\n&#x27;</span>
    c.lenScratch[<span class="hljs-built_in">len</span>(c.lenScratch)<span class="hljs-number">-2</span>] = <span class="hljs-string">&#x27;\r&#x27;</span>
    i := <span class="hljs-built_in">len</span>(c.lenScratch) - <span class="hljs-number">3</span>
    <span class="hljs-keyword">for</span> &#123;
      c.lenScratch[i] = <span class="hljs-keyword">byte</span>(<span class="hljs-string">&#x27;0&#x27;</span> + n%<span class="hljs-number">10</span>)
      i -= <span class="hljs-number">1</span>
      n = n / <span class="hljs-number">10</span>
      <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;
        <span class="hljs-keyword">break</span>
      &#125;
    &#125;
    c.lenScratch[i] = prefix
    _, err := c.bw.Write(c.lenScratch[i:])
    <span class="hljs-keyword">return</span> err
&#125;</code></pre></div><p>循环复用 <code>lenScratch</code> 数组，是个好的设计，不会产生很多小的字符串。</p><p>拼接完了参数个数部分，在再拼接参数部分，项目中实现了一系列<code>writexxx</code> 函数，对不同的类型有不同的拼接方式，以 string 类型为例，</p><div class="hljs"><pre><code class="hljs go"> <span class="hljs-comment">// 用来拼接每个参数，比如 GET，写成 $3\r\nGET\r\n</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span> <span class="hljs-title">writeString</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;
truec.writeLen(<span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-built_in">len</span>(s))
truec.bw.WriteString(s)
true_, err := c.bw.WriteString(<span class="hljs-string">&quot;\r\n&quot;</span>)
true<span class="hljs-keyword">return</span> err
&#125;</code></pre></div><p>按照 RESP 协议的格式将命令拼接完以后需要发出去，通过 <code>bufio</code> 的 <code>Flush</code> 完成。<br>另外，redigo 还支持 pipeline 的返回方式发送请求，使用到的函数是 <code>Send</code> 和 <code>Flush</code>。在 <code>Send</code>中只是把命令写到 bufio 的 buff 里了，<code>Flush</code> 才会发到对端。</p><h3 id="3-2- 响应解析">3.2 响应解析</h3><p>发送命令成功后， redis server 那边处理完请求后，同样以 RESP 的格式回复。<br>解析函数是 <code>readReply</code>，对照着 RESP 协议看下就好了，还是很简单的。<br>multi bulk reply 可以反复调用 bulk reply 解析函数去递归完成解析。</p><h3 id="3-3- 关闭连接">3.3 关闭连接</h3><p>使用完毕连接以后，需要手动 close 掉，如下，</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;
    c.mu.Lock()
    err := c.err
    <span class="hljs-keyword">if</span> c.err == <span class="hljs-literal">nil</span> &#123;
      c.err = errors.New(<span class="hljs-string">&quot;redigo: closed&quot;</span>)
      err = c.conn.Close()
    &#125;
    c.mu.Unlock()
    <span class="hljs-keyword">return</span> err
&#125;</code></pre></div><h2 id="4-pool- 的分析">4. pool 的分析</h2><p>很多人在用 redigo 的时候会使用其连接池，因为使用该 sdk 时间较长，发现了 pool 的实现有两个版本。</p><h3 id="4-1- 老版本 -pool">4.1 老版本 pool</h3><p>主要数据结构为 <code>pool</code>，即</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">struct</span> &#123;

    <span class="hljs-comment">// Dial is an application supplied function for creating and configuring a</span>
    <span class="hljs-comment">// connection.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// The connection returned from Dial must not be in a special state</span>
    <span class="hljs-comment">// (subscribed to pubsub channel, transaction started, ...).</span>
    Dial <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-params">(Conn, error)</span></span>

    <span class="hljs-comment">// TestOnBorrow is an optional application supplied function for checking</span>
    <span class="hljs-comment">// the health of an idle connection before the connection is used again by</span>
    <span class="hljs-comment">// the application. Argument t is the time that the connection was returned</span>
    <span class="hljs-comment">// to the pool. If the function returns an error, then the connection is</span>
    <span class="hljs-comment">// closed.</span>
    <span class="hljs-comment">// 检测连接的可用性，从外部注入。如果返回 error 则直接关闭连接</span>
    TestOnBorrow <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c Conn, t time.Time)</span> <span class="hljs-title">error</span></span>

    <span class="hljs-comment">// Maximum number of idle connections in the pool.</span>
    <span class="hljs-comment">// 最大闲置连接数量</span>
    MaxIdle <span class="hljs-keyword">int</span>

    <span class="hljs-comment">// Maximum number of connections allocated by the pool at a given time.</span>
    <span class="hljs-comment">// When zero, there is no limit on the number of connections in the pool.</span>
    <span class="hljs-comment">// 最大活动连接数, 如果为 0，则表示没有限制</span>
    MaxActive <span class="hljs-keyword">int</span>

    <span class="hljs-comment">// Close connections after remaining idle for this duration. If the value</span>
    <span class="hljs-comment">// is zero, then idle connections are not closed. Applications should set</span>
    <span class="hljs-comment">// the timeout to a value less than the server&#x27;s timeout.</span>
    <span class="hljs-comment">// 闲置过期时间，在 get 函数中会有逻辑删除过期的连接</span>
    <span class="hljs-comment">// 如果不设置，连接就不会过期</span>
    IdleTimeout time.Duration

    <span class="hljs-comment">// If Wait is true and the pool is at the MaxActive limit, then Get() waits</span>
    <span class="hljs-comment">// for a connection to be returned to the pool before returning.</span>
    <span class="hljs-comment">// 设置如果活动连接达到上限 再获取时候是等待还是返回错误</span>
    <span class="hljs-comment">// 如果是 false 系统会返回 redigo: connection pool exhausted</span>
    <span class="hljs-comment">// 如果是 true 会让协程等待直到有连接释放出来</span>
    Wait <span class="hljs-keyword">bool</span>

    <span class="hljs-comment">// mu protects fields defined below.（主要是与状态相关）</span>
    mu     sync.Mutex
    cond   *sync.Cond
    closed <span class="hljs-keyword">bool</span>
    active <span class="hljs-keyword">int</span>

    <span class="hljs-comment">// Stack of idleConn with most recently used at the front.</span>
    idle list.List
&#125;</code></pre></div><p>该版本中使用了条件变量 <code>Cond</code>来协调多协程获取连接池中的连接<br><code>idle</code> 使用的是 go 标准库 container 中的 list 数据结构，其中存放的是池中的连接，每个连接的数据结构如下，</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> idleConn <span class="hljs-keyword">struct</span> &#123;
    c Conn
    t time.Time
&#125;</code></pre></div><p><code>pooledConnection</code> 结构实现了 <code>Conn</code> 接口的所有方法。</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> pooledConnection <span class="hljs-keyword">struct</span> &#123;
    p     *Pool <span class="hljs-comment">// pool</span>
    c     Conn  <span class="hljs-comment">// 当前连接</span>
    state <span class="hljs-keyword">int</span>
&#125;
</code></pre></div><h4 id="4-1-1- 从 -pool- 获取连接">4.1.1 从 pool 获取连接</h4><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span> <span class="hljs-title">Conn</span></span> &#123;
    c, err := p.get()
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
      <span class="hljs-keyword">return</span> errorConnection&#123;err&#125;
    &#125;
    <span class="hljs-keyword">return</span> &amp;pooledConnection&#123;p: p, c: c&#125;
&#125;</code></pre></div><p>当从连接池获取不到时就创建一个连接，所以还是重点看如何从连接池获取一个连接。</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-params">(Conn, error)</span></span> &#123;
    p.mu.Lock()

    <span class="hljs-comment">// Prune stale connections.(将过期连接的清理放到每次的 get 中)</span>
    <span class="hljs-comment">// 如果 idletime 没有设置，连接就不会过期，因此也就不必清理</span>
    <span class="hljs-keyword">if</span> timeout := p.IdleTimeout; timeout &gt; <span class="hljs-number">0</span> &#123;
      <span class="hljs-keyword">for</span> i, n := <span class="hljs-number">0</span>, p.idle.Len(); i &lt; n; i++ &#123;
        e := p.idle.Back() <span class="hljs-comment">// 取出最后一个连接</span>
        <span class="hljs-keyword">if</span> e == <span class="hljs-literal">nil</span> &#123;
          <span class="hljs-keyword">break</span>
        &#125;
        ic := e.Value.(idleConn)
        <span class="hljs-keyword">if</span> ic.t.Add(timeout).After(nowFunc()) &#123; <span class="hljs-comment">// 没有过期，立刻终止检查</span>
          <span class="hljs-keyword">break</span>
        &#125;
        p.idle.Remove(e)
        p.release() <span class="hljs-comment">// 需要操作 active 变量</span>
        p.mu.Unlock()
        ic.c.Close() <span class="hljs-comment">// 关闭连接</span>
        p.mu.Lock()
      &#125;
    &#125;

    <span class="hljs-keyword">for</span> &#123;
      <span class="hljs-comment">// Get idle connection.</span>
        <span class="hljs-keyword">for</span> i, n := <span class="hljs-number">0</span>, p.idle.Len(); i &lt; n; i++ &#123;
          e := p.idle.Front() <span class="hljs-comment">// 从最前面取一个连接</span>
          <span class="hljs-keyword">if</span> e == <span class="hljs-literal">nil</span> &#123;       <span class="hljs-comment">// idle 里是空的，先退出循环吧</span>
            <span class="hljs-keyword">break</span>
          &#125;
          ic := e.Value.(idleConn)
          p.idle.Remove(e)
          test := p.TestOnBorrow
          p.mu.Unlock()
          <span class="hljs-keyword">if</span> test == <span class="hljs-literal">nil</span> || test(ic.c, ic.t) == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 返回这个连接</span>
            <span class="hljs-keyword">return</span> ic.c, <span class="hljs-literal">nil</span>
          &#125;
          ic.c.Close() <span class="hljs-comment">// 取出来的连接不可用</span>
          p.mu.Lock()
          p.release()
        &#125;

        <span class="hljs-comment">// Check for pool closed before dialing a new connection.</span>

        <span class="hljs-keyword">if</span> p.closed &#123;
          p.mu.Unlock()
          <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;redigo: get on closed pool&quot;</span>)
        &#125;

        <span class="hljs-comment">// Dial new connection if under limit.</span>
        <span class="hljs-keyword">if</span> p.MaxActive == <span class="hljs-number">0</span> || p.active &lt; p.MaxActive &#123;
          dial := p.Dial
          p.active += <span class="hljs-number">1</span>
          p.mu.Unlock()
          c, err := dial()
          <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
            p.mu.Lock()
            p.release()
            p.mu.Unlock()
            c = <span class="hljs-literal">nil</span>
          &#125;
          <span class="hljs-keyword">return</span> c, err
        &#125;

        <span class="hljs-comment">// 到达连接池最大连接数了，要不要等呢？</span>
        <span class="hljs-keyword">if</span> !p.Wait &#123; <span class="hljs-comment">// 不 wait 的话就直接返回连接池资源耗尽的错误</span>
          p.mu.Unlock()
          <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrPoolExhausted
        &#125;

        <span class="hljs-keyword">if</span> p.cond == <span class="hljs-literal">nil</span> &#123;
          p.cond = sync.NewCond(&amp;p.mu)
        &#125;
        p.cond.Wait() <span class="hljs-comment">// wait 等待 release 和 put 后有新的连接可用</span>
      &#125;
&#125;</code></pre></div><p>当有设置 IdleTimeout 时，那么到了每次 <code>get</code> 连接的时候都会从队尾拿一个连接，检查时间是否过期，如果过期，那么把它删掉，然后 <code>release</code>，这个操作一直持久直至找到一个没有过期的连接。</p><p>然后从 <strong>队首 </strong>拿一个连接，拿到后检查可用后返回，不可用的连接处理方式同上面的过期连接。</p><p>如果这个 pool 的状态已经是 close 了，那么直接返回。把这个检查放在这里，使 closed pool 仍然可以清理一些过期连接，减少内存占用。</p><p>如果 pool 没有设置 MaxActive，或者当前 pool 中的 active 没到阈值，那么可以使用 <code>dial</code>函数创建一个新连接，active 值加 1。</p><p>如果逻辑走到这里还没有取到连接，说明现在 pool 里的连接都被用了，如果不想 <code>wait</code>，那么直接返回 pool 资源耗尽的错误 (<code>ErrPoolExhausted</code>)，否则使用 pool 的条件变量 <code>cond</code> 进行 <code>Wait</code>。我们都知道在 <code>Wait</code> 中 会先解锁，然后陷入阻塞等待唤醒。</p><p><code>cond</code>唤醒在 <code>release</code> 函数和 <code>put</code> 函数中，如下，</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// release decrements the active count and signals waiters. The caller must</span>
<span class="hljs-comment">// hold p.mu during the call.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span> <span class="hljs-title">release</span><span class="hljs-params">()</span></span> &#123;
    p.active -= <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> p.cond != <span class="hljs-literal">nil</span> &#123;
      p.cond.Signal() <span class="hljs-comment">// 通知 wait 的请求返回连接</span>
    &#125;
&#125;</code></pre></div><h4 id="4-1-2- 向 -pool-return- 连接">4.1.2 向 pool return 连接</h4><p>用完连接后要还回去，在调用连接的 <code>Close</code> 函数中会使用 <code>put</code>。</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span> <span class="hljs-title">put</span><span class="hljs-params">(c Conn, forceClose <span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">error</span></span> &#123;
    err := c.Err()
    p.mu.Lock()
    <span class="hljs-keyword">if</span> !p.closed &amp;&amp; err == <span class="hljs-literal">nil</span> &amp;&amp; !forceClose &#123;
      p.idle.PushFront(idleConn&#123;t: nowFunc(), c: c&#125;) <span class="hljs-comment">// 放回头部</span>
      <span class="hljs-keyword">if</span> p.idle.Len() &gt; p.MaxIdle &#123;
        c = p.idle.Remove(p.idle.Back()).(idleConn).c <span class="hljs-comment">// 如果连接池中数量超过了 maxidle，那么从后面删除一个</span>
      &#125; <span class="hljs-keyword">else</span> &#123;
        c = <span class="hljs-literal">nil</span>
      &#125;
    &#125;

    <span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;
      <span class="hljs-keyword">if</span> p.cond != <span class="hljs-literal">nil</span> &#123;
        p.cond.Signal() <span class="hljs-comment">// 通知</span>
      &#125;
      p.mu.Unlock()
      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    &#125;

    p.release()
    p.mu.Unlock()
    <span class="hljs-keyword">return</span> c.Close()
&#125;</code></pre></div><p>将没有出错的连接并且不是别强制关闭的连接放回到 idle list 中，注意，这里是放到 <strong>队头 </strong>！如果 list 长度大于最大闲置连接数(MaxIdle)，那么从队尾取连接 <code>remove</code> 掉。</p><p><code>Signal</code> 唤醒条件变量。</p><h3 id="4-2- 新版本 -pool">4.2 新版本 pool</h3><p>在版本的 pool 里，自己实现了一个 list，取代 golang 的官方库 list。</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> idleList <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 只记录头尾</span>
truecount       <span class="hljs-keyword">int</span> <span class="hljs-comment">// list 长度</span>
truefront, back *poolConn
&#125;

<span class="hljs-keyword">type</span> poolConn <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 双链表节点</span>
truec          Conn
truet          time.Time
truecreated    time.Time
truenext, prev *poolConn
&#125;</code></pre></div><p>同时实现了几个双链表的操作，<code>pushFront</code>、<code>popFront</code> 和 <code>popBack</code>。<br>新版本的 pool 里去掉了条件变量，换上了 channel。</p><div class="hljs"><pre><code class="hljs go">chInitialized <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// set to 1 when field ch is initialized</span>
ch           <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// limits open connections when p.Wait is true</span>
idle         idleList      <span class="hljs-comment">// idle connections</span>
waitCount    <span class="hljs-keyword">int64</span>         <span class="hljs-comment">// total number of connections waited for.</span>
waitDuration time.Duration <span class="hljs-comment">// total time waited for new connections.</span></code></pre></div><p>pool 里的连接个数使用了 buffer channel 进行控制，大小为 <code>MaxActive</code>。<br>在第一次从 pool 中获取连接时，进行 channel 来初始化，即</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span> <span class="hljs-title">lazyInit</span><span class="hljs-params">()</span></span> &#123;
    <span class="hljs-comment">// Fast path.</span>
    <span class="hljs-keyword">if</span> atomic.LoadUint32(&amp;p.chInitialized) == <span class="hljs-number">1</span> &#123;
      <span class="hljs-keyword">return</span>
    &#125;
    <span class="hljs-comment">// Slow path.</span>
    p.mu.Lock()
    <span class="hljs-keyword">if</span> p.chInitialized == <span class="hljs-number">0</span> &#123;
      p.ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, p.MaxActive)
      <span class="hljs-keyword">if</span> p.closed &#123;
        <span class="hljs-built_in">close</span>(p.ch)
      &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; p.MaxActive; i++ &#123;
          p.ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;
        &#125;
      &#125;
      atomic.StoreUint32(&amp;p.chInitialized, <span class="hljs-number">1</span>)
    &#125;
    p.mu.Unlock()
&#125;</code></pre></div><h4 id="4-2-1- 从 -pool- 获取连接">4.2.1 从 pool 获取连接</h4><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span> <span class="hljs-title">get</span><span class="hljs-params">(ctx context.Context)</span> <span class="hljs-params">(*poolConn, error)</span></span> &#123;

true<span class="hljs-comment">// Handle limit for p.Wait == true.</span>
    <span class="hljs-keyword">var</span> waited time.Duration
    <span class="hljs-keyword">if</span> p.Wait &amp;&amp; p.MaxActive &gt; <span class="hljs-number">0</span> &#123;
      p.lazyInit()

      <span class="hljs-comment">// wait indicates if we believe it will block so its not 100% accurate</span>
      <span class="hljs-comment">// however for stats it should be good enough.</span>
      wait := <span class="hljs-built_in">len</span>(p.ch) == <span class="hljs-number">0</span>
      <span class="hljs-keyword">var</span> start time.Time
      <span class="hljs-keyword">if</span> wait &#123;
        start = time.Now()
      &#125;
      <span class="hljs-keyword">if</span> ctx == <span class="hljs-literal">nil</span> &#123;
        &lt;-p.ch
      &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">select</span> &#123;
        <span class="hljs-keyword">case</span> &lt;-p.ch:
        <span class="hljs-keyword">case</span> &lt;-ctx.Done():
          <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ctx.Err()
        &#125;
      &#125;
      <span class="hljs-keyword">if</span> wait &#123;
        waited = time.Since(start)
      &#125;
    &#125;

    p.mu.Lock()

    <span class="hljs-keyword">if</span> waited &gt; <span class="hljs-number">0</span> &#123;
      p.waitCount++
      p.waitDuration += waited
    &#125;

    <span class="hljs-comment">// Prune stale connections at the back of the idle list.</span>
    <span class="hljs-keyword">if</span> p.IdleTimeout &gt; <span class="hljs-number">0</span> &#123;
      n := p.idle.count
      <span class="hljs-comment">// 清理过期的 conn</span>
      <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n &amp;&amp; p.idle.back != <span class="hljs-literal">nil</span> &amp;&amp; p.idle.back.t.Add(p.IdleTimeout).Before(nowFunc()); i++ &#123;
        pc := p.idle.back
        p.idle.popBack()
        p.mu.Unlock()
        pc.c.Close()
        p.mu.Lock()
        p.active--
      &#125;
    &#125;

    <span class="hljs-comment">// Get idle connection from the front of idle list.</span>
    <span class="hljs-keyword">for</span> p.idle.front != <span class="hljs-literal">nil</span> &#123;
      pc := p.idle.front
      p.idle.popFront() <span class="hljs-comment">// 从前面获取一个连接</span>
      p.mu.Unlock()
      <span class="hljs-keyword">if</span> (p.TestOnBorrow == <span class="hljs-literal">nil</span> || p.TestOnBorrow(pc.c, pc.t) == <span class="hljs-literal">nil</span>) &amp;&amp;
        (p.MaxConnLifetime == <span class="hljs-number">0</span> || nowFunc().Sub(pc.created) &lt; p.MaxConnLifetime) &#123;
        <span class="hljs-keyword">return</span> pc, <span class="hljs-literal">nil</span>
      &#125;
      pc.c.Close()
      p.mu.Lock()
      p.active--
    &#125;

    <span class="hljs-comment">// Check for pool closed before dialing a new connection.</span>
    <span class="hljs-keyword">if</span> p.closed &#123;
      p.mu.Unlock()
      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;redigo: get on closed pool&quot;</span>)
    &#125;

    <span class="hljs-comment">// Handle limit for p.Wait == false.</span>
    <span class="hljs-keyword">if</span> !p.Wait &amp;&amp; p.MaxActive &gt; <span class="hljs-number">0</span> &amp;&amp; p.active &gt;= p.MaxActive &#123;
      p.mu.Unlock()
      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrPoolExhausted
    &#125;

   <span class="hljs-comment">// 新建连接，更新 active</span>
    p.active++
    p.mu.Unlock()
    c, err := p.dial(ctx)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
      c = <span class="hljs-literal">nil</span>
      p.mu.Lock()
      p.active--
      <span class="hljs-keyword">if</span> p.ch != <span class="hljs-literal">nil</span> &amp;&amp; !p.closed &#123;
        p.ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125; <span class="hljs-comment">// 连接创建不成功，将这个名额还给 channel</span>
      &#125;
      p.mu.Unlock()
    &#125;
    <span class="hljs-keyword">return</span> &amp;poolConn&#123;c: c, created: nowFunc()&#125;, err
&#125;</code></pre></div><p>可以看到只有在连接池满了愿意等待时，才回初始化 buffer channel，即调用 <code>lazyInit</code> 函数，省去了不必要的内存占用，可以借鉴。<br>当连接池已满，则 channel 为空，此时取连接的流程会阻塞在 <code>&lt;-p.ch</code>，这跟上一版本的 <code>cond.Wait()</code> 有相同的作用。<br>有相同的清理过期连接的逻辑，以及连接创建逻辑。</p><h4 id="4-2-2- 从 -pool- 获取连接">4.2.2 从 pool 获取连接</h4><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span> <span class="hljs-title">put</span><span class="hljs-params">(pc *poolConn, forceClose <span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">error</span></span> &#123;
    p.mu.Lock()
    <span class="hljs-keyword">if</span> !p.closed &amp;&amp; !forceClose &#123;
      pc.t = nowFunc()
      p.idle.pushFront(pc)          <span class="hljs-comment">// 访问头部</span>
      <span class="hljs-keyword">if</span> p.idle.count &gt; p.MaxIdle &#123; <span class="hljs-comment">// 超出了 MaxIdle 的数量的话，从后面踢掉最后面的一个</span>
        pc = p.idle.back
        p.idle.popBack()
      &#125; <span class="hljs-keyword">else</span> &#123;
        pc = <span class="hljs-literal">nil</span>
      &#125;
    &#125;

    <span class="hljs-keyword">if</span> pc != <span class="hljs-literal">nil</span> &#123;
      p.mu.Unlock()
      pc.c.Close()
      p.mu.Lock()
      p.active--
    &#125;

    <span class="hljs-keyword">if</span> p.ch != <span class="hljs-literal">nil</span> &amp;&amp; !p.closed &#123;
      p.ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125; <span class="hljs-comment">// 放回池子</span>
    &#125;
    p.mu.Unlock()
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
&#125;</code></pre></div><p><code>ch</code> 控制着 pool 中连接的数量，当取走一个时，需要 <code>&lt;-ch</code>，当还回一个时，需要 <code>ch &lt;- struct&#123;&#125;&#123;&#125;</code>。<br>另外，还要考虑到某些失败的情况，是否需要将配额还回 <code>ch</code>。</p><h3 id="4-3- 分析">4.3 分析</h3><p>从上面的代码可以看出，不管哪个版本的 pool，获得连接是从 <strong>队首 </strong>获取，还连接也是从 <strong>队首 </strong>还，淘汰过期连接或者多出的连接是从 <strong>队尾 </strong>淘汰。<br>另外，新版本的 pool 实现比老版本更加符合 golang 的语言风格。<br>从某种角度讲，这种 pool 的管理方式会造成 <strong>某些连接过热 </strong>的情况，即负载均衡不均，尤其是过期时间设置不合理的情况下，需慎重使用。</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/redis/">redis</a> <a class="hover-with-bg" href="/tags/sdk/">sdk</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext row"><article class="post-prev col-6"><a href="/a4bc6018.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Redis 源码之主从复制 (1)</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/54df012b.html"><span class="hidden-mobile">Redis 源码之故障转移</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script type="text/javascript">function loadLivere(){addScript("https://cdn-city.livere.com/js/embed.dist.js")}waitElementVisible("lv-container",loadLivere)</script><noscript>为正常使用来必力评论功能请允许 JavaScript 运行</noscript></div></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:3,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","Redigo 源码分析&nbsp;"],cursorChar:"|",typeSpeed:72,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "§"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>