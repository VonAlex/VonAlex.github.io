<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Redis源码分析之数据迁移(1)"><meta name="keywords" content="redis"><meta name="author" content="Happen"><meta name="copyright" content="Happen"><title>Redis源码分析之数据迁移(1) | Happen's Memo</title><link rel="shortcut icon" href="/images/dolphin.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?882b48640075e00a238ae94a7eec0d40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,c,g,o){e.GoogleAnalyticsObject=c,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,g=a.createElement(t),o=a.getElementsByTagName(t)[0],g.async=1,g.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(g,o)}(window,document,"script",0,"ga"),ga("create","RRBput3V2WYVZd2lq058Z4IwJEhViOwuMElqkWh6bcA","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#标记-importing"><span class="toc-number">1.</span> <span class="toc-text">标记 importing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#标记-migrating"><span class="toc-number">2.</span> <span class="toc-text">标记 migrating</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源节点从-slot-中取-key"><span class="toc-number">3.</span> <span class="toc-text">源节点从 slot 中取 key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#migrate-keys-过程"><span class="toc-number">4.</span> <span class="toc-text">migrate keys 过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#源节点处理"><span class="toc-number">4.1.</span> <span class="toc-text">源节点处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一些初始化"><span class="toc-number">4.1.1.</span> <span class="toc-text">一些初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#建立连接"><span class="toc-number">4.1.2.</span> <span class="toc-text">建立连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#填充-cmd-信息"><span class="toc-number">4.1.3.</span> <span class="toc-text">填充 cmd 信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#发送到目的节点"><span class="toc-number">4.1.4.</span> <span class="toc-text">发送到目的节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对目的节点回复的处理"><span class="toc-number">4.1.5.</span> <span class="toc-text">对目的节点回复的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#回复-client-与错误处理"><span class="toc-number">4.1.6.</span> <span class="toc-text">回复 client 与错误处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目的节点的处理"><span class="toc-number">4.2.</span> <span class="toc-text">目的节点的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设置-slot-最终归属"><span class="toc-number">5.</span> <span class="toc-text">设置 slot 最终归属</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附录"><span class="toc-number">6.</span> <span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#migrateGetSocket-函数分析"><span class="toc-number">6.1.</span> <span class="toc-text">migrateGetSocket 函数分析</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.png"></div><div class="author-info__name text-center">Happen</div><div class="author-info__description text-center">浮生若梦，为欢几何</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">39</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://renrenlove.me/" target="_blank" rel="noopener">Galway</a><a class="author-info-links__name text-center" href="http://kvguru.com/" target="_blank" rel="noopener">Wangbin</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div id="page-header"> <span class="pull-left"><a id="site-name" href="/">Happen's Memo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Redis源码分析之数据迁移(1)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a><div class="post-meta-wordcount"><span>字数总计:</span> <span class="word-count">5k</span><span class="post-meta__separator">|</span><span>阅读时长: 20 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>redis 中的数据迁移是以 key 为单位的，整个迁移过程由一系列命令组成，在官方提供的 ruby 实现的 trib 工具中对整个过程进行了包装串联，在更新的版本的 redis 中，已经将这些逻辑移植到了 redis-cli 中，使用 C 进行了重写。下面进行分步详细讲解。</p><a id="more"></a><h2 id="标记-importing"><a href="#标记-importing" class="headerlink" title="标记 importing"></a>标记 importing</h2><p>在<strong>目的节点</strong> B 执行命令 <code>SETSLOT 10 IMPORTING &lt;A 的 nodeID&gt;</code>，标记有一个 slot (10) 将要从源节点 A 迁入到本节点 B。<br>此时，在 B 上使用 <code>cluster nodes</code> 命令查看集群路由现状，可以发现，在 B 负责的 slot 信息里有这样的标记<code>[10-&lt;-A nodeid]</code>。（其他节点不知道这件事）</p><p>具体代码执行逻辑如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"setslot"</span>) &amp;&amp; c-&gt;argc &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">        .....</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">3</span>]-&gt;ptr,<span class="string">"importing"</span>) &amp;&amp; c-&gt;argc == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (server.cluster-&gt;slots[slot] == myself) &#123;</span><br><span class="line">                addReplyErrorFormat(c, <span class="string">"I'm already the owner of hash slot %u"</span>,slot);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((n = clusterLookupNode(c-&gt;argv[<span class="number">4</span>]-&gt;ptr)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                addReplyErrorFormat(c,<span class="string">"I don't know about node %s"</span>, (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">3</span>]-&gt;ptr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            server.cluster-&gt;importing_slots_from[slot] = n;</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当接收到 <code>setslot</code> 命令时，匹配到关于设置 slot importing 状态的逻辑。</p><p>首先是一些参数的校验。</p><ul><li>检查 slot x 是不是已经属于我了，如果是，那么报错 <strong>I’m already the owner of hash slot x</strong>。（slot x 已经是我的了，不需要再迁给我）</li><li>检查源节点我是否认识，如果不认识的话，报错 <strong>I don’t know about node</strong>。（不认识源节点，我从哪儿迁入呢？）</li></ul><p>然后，修改 <code>server.cluster</code> 结构体的相应变量，表示已经记下了。</p><p>在每个 cluster 节点中，都有一个 <code>clusterState</code> 结构体，用来保存集群信息，其中 <code>importing_slots_from</code> 变量表示要迁入本节点的 slot 信息，而 <code>migrating_slots_to</code> 变量表示要迁出本节点的 slot 信息，它们都是 16384 长度的数组。</p><h2 id="标记-migrating"><a href="#标记-migrating" class="headerlink" title="标记 migrating"></a>标记 migrating</h2><p>在源节点 A 执行命令 <code>SETSLOT 10 MIGRATING &lt;B 的 nodeID&gt;</code>，标记有一个 slot (10) 将要从本节点 A 迁出到目标节点 B。<br>此时，在 A 上使用 <code>cluster nodes</code> 命令查看集群路由现状，可以发现，在 A 负责的 slot 信息里有这样的标记<code>[10-&gt;-B nodeid]</code>。（其他节点不知道这件事）</p><p>具体代码执行逻辑如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"setslot"</span>) &amp;&amp; c-&gt;argc &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">        ....</span><br><span class="line">          <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">3</span>]-&gt;ptr,<span class="string">"migrating"</span>) &amp;&amp; c-&gt;argc == <span class="number">5</span>) &#123;</span><br><span class="line">                addReplyErrorFormat(c,<span class="string">"I'm not the owner of hash slot %u"</span>,slot);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((n = clusterLookupNode(c-&gt;argv[<span class="number">4</span>]-&gt;ptr)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                addReplyErrorFormat(c,<span class="string">"I don't know about node %s"</span>, (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">4</span>]-&gt;ptr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            server.cluster-&gt;migrating_slots_to[slot] = n; <span class="comment">// 标记 slot 的目的地</span></span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当接收到 <code>setslot</code> 命令时，匹配到关于设置 slot migrating 状态的逻辑。<br>首先是一些参数的校验。</p><ul><li>检查 slot x 是不是我负责的，如果不是，报错 <strong>I’m not the owner of hash slot x</strong>。（不是我负责的 slot，我无权迁出）</li><li>检查目的节点我是否认识，如果不认识的话，报错 <strong>I don’t know about node</strong>。（不认识目的节点，我怎么迁出？）</li></ul><p>然后，修改 <code>server.cluster</code> 结构体相应变量，表示已经记下了。</p><p><strong>注意</strong>：<br>应该先在迁入节点标记 slot 的 importing 状态，后在迁出节点标记 slot 的 migrating 状态。若颠倒顺序的话，会有一些问题。<br>假设这样的场景，在迁出节点设置了 slot 的 migrating 状态。之后访问迁出节点 slot 的<strong>写命令</strong>，会被重定向到迁入节点（没有 key 就会重定向），但是此时迁入节点 slot 还没有做标记，所以又会产出一个 <strong>MOVED</strong> 错误，如此循环往复。说到底还是因为这些命令的执行是分开的，而非原子的。</p><h2 id="源节点从-slot-中取-key"><a href="#源节点从-slot-中取-key" class="headerlink" title="源节点从 slot 中取 key"></a>源节点从 slot 中取 key</h2><p>经过前面两步，将要迁移的 slot 在源节点和目的节点都进行的标记。 现有的 redis cluster 中数据迁移的基本单位是 key，因此要先取出要迁移的一部分 key，有 <code>GETKEYSINSLOT</code> 命令可以使用，全格式为 <code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code>。</p><p>具体代码逻辑如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"getkeysinslot"</span>) &amp;&amp; c-&gt;argc == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">/* CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt; */</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> maxkeys, slot;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> numkeys, j;</span><br><span class="line">        robj **keys;</span><br><span class="line">        <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;slot,<span class="literal">NULL</span>) != C_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;maxkeys,<span class="literal">NULL</span>)</span><br><span class="line">            != C_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (slot &lt; <span class="number">0</span> || slot &gt;= CLUSTER_SLOTS || maxkeys &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyError(c,<span class="string">"Invalid slot or number of keys"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        keys = zmalloc(<span class="keyword">sizeof</span>(robj*)*maxkeys);</span><br><span class="line">        numkeys = getKeysInSlot(slot, keys, maxkeys);</span><br><span class="line">        addReplyMultiBulkLen(c,numkeys);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numkeys; j++) addReplyBulk(c,keys[j]);</span><br><span class="line">        zfree(keys);</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，解析参数，</p><ul><li><p>从哪个 slot 取数据？存到变量 slot 中。</p></li><li><p>这一次取多少个 key？存到变量 maxkeys 中。</p></li></ul><p>然后，分配内存，使用 <code>getKeysInSlot</code> 函数从跳表 <code>server.cluster-&gt;slots_to_keys</code> 中取出 slot x 里最多 maxkeys 个 key，存入数组 keys 中，<code>getKeysInSlot</code> 函数返回实际取得的key的数量。<br>最后，响应客户端 OK，并释放内存。</p><h2 id="migrate-keys-过程"><a href="#migrate-keys-过程" class="headerlink" title="migrate keys 过程"></a>migrate keys 过程</h2><h3 id="源节点处理"><a href="#源节点处理" class="headerlink" title="源节点处理"></a>源节点处理</h3><p>使用上一步取出来的 key，使用 <code>MIGRATE</code> 命令进行 key 的搬迁。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MIGRATE host port <span class="string">""</span> dbid timeout [COPY | REPLACE] KEYS key1 key2 ... keyN</span><br></pre></td></tr></table></figure><p>正常流程中，将 key 搬迁到目标节点以后，会其从源节点删除掉，但是命令中的 <strong>COPY</strong> 和 <strong>REPLACE</strong> 选项会使得此过程有不同的表现。</p><ul><li><p>COPY ：目的节点如果已经存在要搬迁的 key，会报错。且 key 搬迁完成后，源节点也不会删掉这个 key。</p></li><li><p>REPLACE：不管目的节点是否存在要迁移的 key，都覆盖它。</p></li><li><p>两个选项都不要。目的节点如果已经存在要搬迁的 key，会报错。</p></li></ul><h4 id="一些初始化"><a href="#一些初始化" class="headerlink" title="一些初始化"></a>一些初始化</h4><p><code>MIGRATE</code> 命令使用函数 <code>migrateCommand</code> 进行处理。</p><p>首先，进行一些参数校验以及变量的初始化。<br>如果 timeout 选项解析出来 &lt;=0，那么设置为默认值 1s。timeout 值用来做建链接接超时，以及后面的读写超时。<br>将要迁移的 key 保存到数组 kv 中，相应的 value 保存到数组 ov 中 ，代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ov = zrealloc(ov,<span class="keyword">sizeof</span>(robj*)*num_keys);</span><br><span class="line">kv = zrealloc(kv,<span class="keyword">sizeof</span>(robj*)*num_keys);</span><br><span class="line"><span class="keyword">int</span> oi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; num_keys; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((ov[oi] = lookupKeyRead(c-&gt;db,c-&gt;argv[first_key+j])) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        kv[oi] = c-&gt;argv[first_key+j];</span><br><span class="line">        oi++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">num_keys = oi;</span><br><span class="line"><span class="keyword">if</span> (num_keys == <span class="number">0</span>) &#123;</span><br><span class="line">    zfree(ov); zfree(kv);</span><br><span class="line">    addReplySds(c,sdsnew(<span class="string">"+NOKEY\r\n"</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>由于 key 的过期或者主从删除等原因，这里的 <strong>oi 的值很可能跟 num_keys 是不一致的</strong>，如果 key 都没有了，也就是不用再迁移了，那么返回信息 <strong>+NOKEY</strong>。</p><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>然后，跟要迁入 key 的目的节点建立连接。代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Connect */</span></span><br><span class="line">cs = migrateGetSocket(c,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],timeout);</span><br><span class="line"><span class="keyword">if</span> (cs == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    zfree(ov); zfree(kv);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* error sent to the client by migrateGetSocket() */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，代码中根据命令参数 host 和 port 使用 <code>migrateGetSocket</code> 函数可拿到一个可用的连接，该函数逻辑可以参考附录。</p><h4 id="填充-cmd-信息"><a href="#填充-cmd-信息" class="headerlink" title="填充 cmd 信息"></a>填充 cmd 信息</h4><p>拿到可用的连接后，接着就需要将要搬迁的 key 以 <strong>redis 协议的格式</strong>发送到目的节点，具体格式如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*<span class="number">4</span>\r\n (或 *<span class="number">5</span>\r\n)</span><br><span class="line">$<span class="number">14</span>\r\nRESTORE-ASKING\r\n (或 $<span class="number">7</span>\r\nRESTORE\r\n)</span><br><span class="line">$&lt;count&gt;\r\n&lt;payload&gt;\r\n (key 信息)</span><br><span class="line">$&lt;count&gt;\r\n&lt;payload&gt;\r\n (ttl 信息)</span><br><span class="line">$&lt;count&gt;\r\n&lt;payload&gt;\r\n (value dump 信息)</span><br><span class="line">$<span class="number">7</span>\r\nREPLACE\r\n (根据情况决定是否有这个参数)</span><br></pre></td></tr></table></figure><p>可以看到使用的是 <code>RESTORE-ASKING</code> 或者 <code>RESTORE</code> 的命令。</p><p>下面看填充 cmd 的具体代码分析。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rio cmd, payload;</span><br><span class="line">rioInitWithBuffer(&amp;cmd,sdsempty());</span><br></pre></td></tr></table></figure><p>首先，使用 <code>rio</code> 类型的变量 cmd 存放要发给目的节点的 redis 协议格式的命令，下面就开始使用要迁移的 key/value 组装数据。<br>看下是否需要切换数据库，有必要的话，强制发 <code>SELECT &lt;dbid&gt;</code> 。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> select = cs-&gt;last_dbid != dbid; <span class="comment">/* Should we emit SELECT? */</span></span><br><span class="line"><span class="keyword">if</span> (select) &#123;</span><br><span class="line">    serverAssertWithInfo(c,<span class="literal">NULL</span>,rioWriteBulkCount(&amp;cmd,<span class="string">'*'</span>,<span class="number">2</span>));</span><br><span class="line">    serverAssertWithInfo(c,<span class="literal">NULL</span>,rioWriteBulkString(&amp;cmd,<span class="string">"SELECT"</span>,<span class="number">6</span>));</span><br><span class="line">    serverAssertWithInfo(c,<span class="literal">NULL</span>,rioWriteBulkLongLong(&amp;cmd,dbid));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是针对每一个 key 进行的处理，具体代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ttl = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> expireat = getExpire(c-&gt;db,kv[j]);</span><br><span class="line"><span class="keyword">if</span> (expireat != <span class="number">-1</span>) &#123;</span><br><span class="line">    ttl = expireat-mstime();</span><br><span class="line">    <span class="keyword">if</span> (ttl &lt; <span class="number">1</span>) ttl = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将 key 的过期时间从绝对时间转成相对时间，记录在 ttl 中。<br>根据前面命令传入的选项是 replace 还是 copy，决定发送命令的参数个数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">serverAssertWithInfo(c,<span class="literal">NULL</span>,rioWriteBulkCount(&amp;cmd,<span class="string">'*'</span>,replace ? <span class="number">5</span> : <span class="number">4</span>));</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.cluster_enabled)</span><br><span class="line">    serverAssertWithInfo(c,<span class="literal">NULL</span>,</span><br><span class="line">                rioWriteBulkString(&amp;cmd,<span class="string">"RESTORE-ASKING"</span>,<span class="number">14</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    serverAssertWithInfo(c,<span class="literal">NULL</span>,rioWriteBulkString(&amp;cmd,<span class="string">"RESTORE"</span>,<span class="number">7</span>));</span><br></pre></td></tr></table></figure><p>如果当前处于集群模式下，则向 cmd 中填充 <code>RESTORE-ASKING</code> 命令，否则填充 <code>RESTORE</code> 命令。<br>然后，对每个 key 的信息进行填充，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 填充 key 的信息</span></span><br><span class="line">serverAssertWithInfo(c,<span class="literal">NULL</span>,sdsEncodedObject(kv[j]));</span><br><span class="line">serverAssertWithInfo(c,<span class="literal">NULL</span>,rioWriteBulkString(&amp;cmd,kv[j]-&gt;ptr,</span><br><span class="line">                sdslen(kv[j]-&gt;ptr)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充 ttl 信息</span></span><br><span class="line">serverAssertWithInfo(c,<span class="literal">NULL</span>,rioWriteBulkLongLong(&amp;cmd,ttl));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充 value 的信息</span></span><br><span class="line">createDumpPayload(&amp;payload,ov[j]);</span><br><span class="line">serverAssertWithInfo(c,<span class="literal">NULL</span>,</span><br><span class="line">rioWriteBulkString(&amp;cmd,payload.io.<span class="built_in">buffer</span>.ptr,</span><br><span class="line">    sdslen(payload.io.<span class="built_in">buffer</span>.ptr)));</span><br><span class="line">sdsfree(payload.io.<span class="built_in">buffer</span>.ptr);</span><br></pre></td></tr></table></figure><p>value 的值，要使用 <code>createDumpPayload</code> 函数进行 rdb 序列化，具体格式如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Write the footer, this is how it looks like:</span></span><br><span class="line"><span class="comment"> * ----------------+---------------------+---------------+</span></span><br><span class="line"><span class="comment"> * ... RDB payload | 2 bytes RDB version | 8 bytes CRC64 |</span></span><br><span class="line"><span class="comment"> * ----------------+---------------------+---------------+</span></span><br><span class="line"><span class="comment"> * RDB version and CRC are both in little endian.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>序列化过程在函数 <code>createDumpPayload</code> 中，在此就不做分析了。<br>最后根据 replace 变量，决定是否要填充 <strong>REPLACE</strong>，即，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (replace)</span><br><span class="line">    serverAssertWithInfo(c,<span class="literal">NULL</span>,rioWriteBulkString(&amp;cmd,<span class="string">"REPLACE"</span>,<span class="number">7</span>));</span><br></pre></td></tr></table></figure><p>这样，所有要迁移的 key 也就序列化到 cmd 这个 <code>rio</code> 变量里了。下面就要发给目的节点了。</p><h4 id="发送到目的节点"><a href="#发送到目的节点" class="headerlink" title="发送到目的节点"></a>发送到目的节点</h4><p>组装完cmd，就要把它们发送到对端，代码逻辑如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds buf = cmd.io.<span class="built_in">buffer</span>.ptr;</span><br><span class="line"><span class="keyword">size_t</span> pos = <span class="number">0</span>, towrite;</span><br><span class="line"><span class="keyword">int</span> nwritten = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((towrite = sdslen(buf)-pos) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    towrite = (towrite &gt; (<span class="number">64</span>*<span class="number">1024</span>) ? (<span class="number">64</span>*<span class="number">1024</span>) : towrite);</span><br><span class="line">    nwritten = syncWrite(cs-&gt;fd,buf+pos,towrite,timeout);</span><br><span class="line">    <span class="keyword">if</span> (nwritten != (<span class="keyword">signed</span>)towrite) &#123;</span><br><span class="line">        write_error = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> socket_err;</span><br><span class="line">     &#125;</span><br><span class="line">     pos += nwritten;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环调用 <code>syncWrite</code> 函数，向远端 Redis <strong>同步</strong>发送 cmd 中的内容，每次最多发送 <strong>64k</strong> 个字节。</p><h4 id="对目的节点回复的处理"><a href="#对目的节点回复的处理" class="headerlink" title="对目的节点回复的处理"></a>对目的节点回复的处理</h4><p>定义两个变量，接收对端的回复。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buf1[<span class="number">1024</span>]; <span class="comment">/* Select reply. */</span></span><br><span class="line"><span class="keyword">char</span> buf2[<span class="number">1024</span>]; <span class="comment">/* Restore reply. */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果前面发送了 select 命令，那么需要先读取此命令的回复</span></span><br><span class="line"><span class="keyword">if</span> (select &amp;&amp; syncReadLine(cs-&gt;fd, buf1, <span class="keyword">sizeof</span>(buf1), timeout) &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> socket_err;</span><br></pre></td></tr></table></figure><p>下面同步读取每一个 restore key 的返回值，具体逻辑如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (syncReadLine(cs-&gt;fd, buf2, <span class="keyword">sizeof</span>(buf2), timeout) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">     socket_error = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((select &amp;&amp; buf1[<span class="number">0</span>] == <span class="string">'-'</span>) || buf2[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">    <span class="comment">/* On error assume that last_dbid is no longer valid. */</span></span><br><span class="line">   <span class="keyword">if</span> (!error_from_target) &#123;</span><br><span class="line">       cs-&gt;last_dbid = <span class="number">-1</span>;</span><br><span class="line">       addReplyErrorFormat(c,<span class="string">"Target instance replied with error: %s"</span>,</span><br><span class="line">           (select &amp;&amp; buf1[<span class="number">0</span>] == <span class="string">'-'</span>) ? buf1+<span class="number">1</span> : buf2+<span class="number">1</span>);</span><br><span class="line">       error_from_target = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!copy) &#123;</span><br><span class="line">        <span class="comment">/* No COPY option: remove the local key, signal the change. */</span></span><br><span class="line">        dbDelete(c-&gt;db,kv[j]);</span><br><span class="line">        signalModifiedKey(c-&gt;db,kv[j]);</span><br><span class="line">        server.dirty++;</span><br><span class="line">        <span class="comment">/* Populate the argument vector to replace the old one. */</span></span><br><span class="line">         newargv[del_idx++] = kv[j];</span><br><span class="line">         incrRefCount(kv[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将对端回复读取变量 <strong>buf2</strong> 里。<br>如果 <strong>buf1</strong> 或者 <strong>buf2</strong> 首字母是字符 <code>-</code>，说明遇到了错误，那么将连接中的 <code>last_dbid</code> 置为 -1，这样下次再使用时，会强制发送 <code>SELECT</code> 命令。<br>如果 <code>MIGRATE</code> 命令中没有使用 <strong>COPY</strong> 选项，那么需要将搬迁到目标节点的 key 从本地删除掉。同时记录在数组 <code>newargv</code> 中，<strong>以方便后面修改命令，传播到副本中</strong>。</p><p>具体逻辑如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!copy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (del_idx &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        newargv[<span class="number">0</span>] = createStringObject(<span class="string">"DEL"</span>,<span class="number">3</span>);</span><br><span class="line">        replaceClientCommandVector(c,del_idx,newargv);</span><br><span class="line">        argv_rewritten = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zfree(newargv);</span><br><span class="line">    &#125;</span><br><span class="line">   newargv = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>MIGRATE</code> 命令改成 <code>DEL</code> 命令。</p><h4 id="回复-client-与错误处理"><a href="#回复-client-与错误处理" class="headerlink" title="回复 client 与错误处理"></a>回复 client 与错误处理</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (socket_error) migrateCloseSocket(c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">if</span> (!copy) &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>socket_error</code> 在同步读取对端回复时，有可能遇到。当发生这个错误时，直接关掉这个 socket。</p><p><strong>注意</strong>：<br>这里并没有返回，这是因为，对于已经迁移成功的 key，后面还是要做命令转换的，因此不能直接返回。</p><p>如果没有发生错误，就可以给 client 正确的回复了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!error_from_target) &#123;</span><br><span class="line">    cs-&gt;last_dbid = dbid;</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功了，更改连接中的 <code>last_dbid</code> 为本次使用的 dbid，留着下一次用，避免下次再发送 <code>SELECT</code> 命令。<br>如果写命令或者读回复发生错误，而且若<strong>不是超时错误</strong>的话，那么可以重试一次。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (errno != ETIMEDOUT &amp;&amp; may_retry) &#123;</span><br><span class="line">    may_retry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> try_again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>try_again</strong> 会跳到前面重新填 cmd，再来一遍，否则会回复 client 错误。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">addReplySds(c, sdscatprintf(sdsempty(),</span><br><span class="line">    <span class="string">"-IOERR error or timeout %s to target instance\r\n"</span>,</span><br><span class="line">    write_error ? <span class="string">"writing"</span> : <span class="string">"reading"</span>));</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>从上面的分析，<br>为了避免同一个 key 出现在两个节点中，在源节点上，涉及到向目标节点建链、发送命令和等待回复的过程，<strong>都是同步的</strong>。<strong>如果遇到大 key，那么搬迁时间会比较长，此时会堵塞住进来请求的 client，甚至有可能触发 failover。</strong><br>所以，<strong>不建议一次性搬移过多的 key，而且要提前解决掉 大 key 的问题</strong>。<br>目前业界已经有以主从复制的思路，以 slot 为单位进行数据搬迁了，能很好解决大 key 问题。</p><h3 id="目的节点的处理"><a href="#目的节点的处理" class="headerlink" title="目的节点的处理"></a>目的节点的处理</h3><p>对端接收到 <code>RESTORE-ASKING</code> 或 <code>RESTORE</code> 命令后，使用函数 <code>restoreCommand</code> 进行逻辑处理。<br>首先检查第 4 个参数是否为 replace。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">4</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">"replace"</span>)) &#123;</span><br><span class="line">        replace = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         addReply(c,shared.syntaxerr);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果有</strong>第 4 个参数，那么一定是 replace ，否则就报语法错误 <strong>-ERR syntax error</strong>。当然也有可能没有，这时 replace = 0。<br>如果 replace = 0，且当前数据库中已经有个这个 key，报错 <strong>-BUSYKEY Target key name already exists</strong><br>取出 ttl 信息，且它一定是个 &gt; 0 的数值。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (getLongLongFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;ttl,<span class="literal">NULL</span>) != C_OK) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ttl &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    addReplyError(c,<span class="string">"Invalid TTL value, must be &gt;= 0"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着解析第 3 个参数，应该是 value 的 dump 信息了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Verify RDB version and data checksum. */</span></span><br><span class="line"><span class="keyword">if</span> (verifyDumpPayload(c-&gt;argv[<span class="number">3</span>]-&gt;ptr,sdslen(c-&gt;argv[<span class="number">3</span>]-&gt;ptr)) == C_ERR) &#123;</span><br><span class="line">    addReplyError(c,<span class="string">"DUMP payload version or checksum are wrong"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rioInitWithBuffer(&amp;payload,c-&gt;argv[<span class="number">3</span>]-&gt;ptr);</span><br><span class="line"><span class="keyword">if</span> (((type = rdbLoadObjectType(&amp;payload)) == <span class="number">-1</span>) ||</span><br><span class="line">    ((obj = rdbLoadObject(type,&amp;payload)) == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    addReplyError(c,<span class="string">"Bad data format"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先校验一下这个 dump 信息是否符合规范，然后分别使用 <code>rdbLoadObjectType</code> 函数和 <code>rdbLoadObject</code> 函数，将 type 和 obj 还原。<br>接着对本地数据库进行处理，代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (replace) dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create the key and set the TTL if any */</span></span><br><span class="line">dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ttl) setExpire(c-&gt;db,c-&gt;argv[<span class="number">1</span>],mstime()+ttl);</span><br><span class="line">signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">addReply(c,shared.ok);</span><br><span class="line">server.dirty++;</span><br></pre></td></tr></table></figure><p>如果有 replace，就要从本地删除原来的 key，使用从源节点传过来的值进行覆盖。<br>有 ttl 的话，再设置一下过期时间。<br>最后，回复客户端”OK”信息；</p><p><strong>以上，就完成了一个 key 的迁移过程。</strong></p><h2 id="设置-slot-最终归属"><a href="#设置-slot-最终归属" class="headerlink" title="设置 slot 最终归属"></a>设置 slot 最终归属</h2><p>当 slot 中的 key 全部搬迁完之后，<br>使用 <code>CLUSTER SETSLOT &lt;SLOT&gt; NODE &lt;NODE ID&gt;</code> 命令设置 slot。</p><p>先在目标节点设置，消除 importing 标记。<br>再在源节点设置， 消除 migrating 标记。</p><p>为了让整个集群都感知到新的 slot 归属，可以给集群其他节点都发一遍，当然了，也可以等着 gossip 消息，但是在大集群中扩散过程就比较慢了。</p><p><strong>注意</strong>：<br>注意上面的顺序，如果<strong>先取消到 migrating 标记，且还没有取消 importing 标记</strong>，那么迁出节点会认为这个 slot 属于迁入节点了，所以读写访问时，会 MOVED 到迁入节点，但是在迁入节点来看这个节点不属于自己，且没有 ASK 重定向，所以会重新 MOVED 到迁出节点。所以产生一个 pingpong 的过程。<br>而按照上面的顺序的话，如果有访问到正在迁出的 slot，那么会 ASK 重定向到迁入节点，在迁入节点看来，这个 slot 是属于自己的，正常处理，不会发生错误。</p><p><strong>这个顺序跟开始迁移时是一致的，先处理迁入节点，再处理迁出节点</strong>。</p><p>下面看这个命令的实际处理过程，部分代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">3</span>]-&gt;ptr,<span class="string">"node"</span>) &amp;&amp; c-&gt;argc == <span class="number">5</span>) &#123;</span><br><span class="line">    clusterNode *n = clusterLookupNode(c-&gt;argv[<span class="number">4</span>]-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">        addReplyErrorFormat(c,<span class="string">"Unknown node %s"</span>, (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">4</span>]-&gt;ptr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.cluster-&gt;slots[slot] == myself &amp;&amp; n != myself) &#123;</span><br><span class="line">    <span class="keyword">if</span> (countKeysInSlot(slot) != <span class="number">0</span>) &#123;</span><br><span class="line">        addReplyErrorFormat(c,</span><br><span class="line">            <span class="string">"Can't assign hashslot %d to a different node "</span></span><br><span class="line">             <span class="string">"while I still hold keys for this hash slot."</span>, slot);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先还是一些参数校验。</p><ul><li><p>参数传入的 node 我是否认识，不认识的话，报错退出。</p></li><li><p>参数传入的 slot 是我负责的，且 node 是别人。这时就要看下，这个 slot 里的 key 是否已经全部搬迁完了，如果不是，那么报错。（key 都没有迁完，怎么能把 slot 给别人呢？会丢数据的）。如果 slot 不是我的，那么我就抱着看热闹的心态，跳过这个检查就好了。</p></li></ul><p>下面就是 slot 状态的消除了，主要代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (countKeysInSlot(slot) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">    server.cluster-&gt;migrating_slots_to[slot])</span><br><span class="line">    server.cluster-&gt;migrating_slots_to[slot] = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>如果 slot 中没有 key，并且处于 <strong>migrating</strong> 状态（也就说这是针对源节点的操作），那么把迁出状态取消。<br>接下来，对于 <strong>importing</strong> 状态的目标节点，发布最新的路由，代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n == myself &amp;&amp; server.cluster-&gt;importing_slots_from[slot])&#123;</span><br><span class="line">    <span class="keyword">if</span> (clusterBumpConfigEpochWithoutConsensus() == C_OK) &#123;</span><br><span class="line">        serverLog(LL_WARNING, <span class="string">"configEpoch updated after importing slot %d"</span>, slot);</span><br><span class="line">    &#125;</span><br><span class="line">    server.cluster-&gt;importing_slots_from[slot] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>clusterBumpConfigEpochWithoutConsensus</code> 函数，<strong>自行增加自己的 config epoch 值</strong>。</p><p>本函数违反了 config epochs 应经过集群达成共识后产生，且在整个 cluster 内是唯一的。<br>然而 Redis Cluster 在以下两种情况下使用自动生成的新 config epochs：</p><ul><li><p>当 slots 在 importing 后关闭。否则，resharding 的代价太昂贵。</p></li><li><p>当 CLUSTER FAILOVER 强制一个 slave failover 的选项调用时，即使没有大多数 master 同意也要产生一个新的 epoch。</p></li></ul><p>如果本节点的 config epoch 值不是集群中最大的，那么会取到最大的，然后 +1，作为现在的 config epoch 和 current epoch。<br>最后变更路由，代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clusterDelSlot(slot);</span><br><span class="line">clusterAddSlot(n,slot);</span><br></pre></td></tr></table></figure><p><strong>至此，就把完成了一个完整的迁移流程</strong>。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="migrateGetSocket-函数分析"><a href="#migrateGetSocket-函数分析" class="headerlink" title="migrateGetSocket 函数分析"></a>migrateGetSocket 函数分析</h3><p>主要代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">migrateCachedSocket* <span class="title">migrateGetSocket</span><span class="params">(client *c, robj *host, robj *port, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    cs = dictFetchValue(server.migrate_cached_sockets,name);</span><br><span class="line">    <span class="keyword">if</span> (cs) &#123;</span><br><span class="line">        sdsfree(name);</span><br><span class="line">        cs-&gt;last_use_time = server.unixtime;</span><br><span class="line">        <span class="keyword">return</span> cs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* No cached socket, create one. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(server.migrate_cached_sockets) == MIGRATE_SOCKET_CACHE_ITEMS) &#123;</span><br><span class="line">        <span class="comment">/* Too many items, drop one at random. */</span></span><br><span class="line">        dictEntry *de = dictGetRandomKey(server.migrate_cached_sockets);</span><br><span class="line">        cs = dictGetVal(de);</span><br><span class="line">        <span class="built_in">close</span>(cs-&gt;fd);</span><br><span class="line">        zfree(cs);</span><br><span class="line">        dictDelete(server.migrate_cached_sockets,dictGetKey(de));</span><br><span class="line">    &#125;</span><br><span class="line">    fd = anetTcpNonBlockConnect(server.neterr, c-&gt;argv[<span class="number">1</span>]-&gt;ptr, atoi(c-&gt;argv[<span class="number">2</span>]-&gt;ptr));</span><br><span class="line">    ...</span><br><span class="line">    anetEnableTcpNoDelay(server.neterr,fd);</span><br><span class="line">   <span class="comment">/* Check if it connects within the specified timeout. */</span></span><br><span class="line">    <span class="keyword">if</span> ((aeWait(fd,AE_WRITABLE,timeout) &amp; AE_WRITABLE) == <span class="number">0</span>) &#123;</span><br><span class="line">        sdsfree(name);</span><br><span class="line">        addReplySds(c,</span><br><span class="line">            sdsnew(<span class="string">"-IOERR error or timeout connecting to the client\r\n"</span>));</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add to the cache and return it to the caller. */</span></span><br><span class="line">    cs = zmalloc(<span class="keyword">sizeof</span>(*cs));</span><br><span class="line">    cs-&gt;fd = fd;</span><br><span class="line">    cs-&gt;last_dbid = <span class="number">-1</span>;</span><br><span class="line">    cs-&gt;last_use_time = server.unixtime;</span><br><span class="line">    dictAdd(server.migrate_cached_sockets,name,cs);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过以上代码可以看到，对于连接过程中的 socket fd 封装到结构体 <code>migrateCachedSocket</code>，存入 <code>server.migrate_cached_sockets</code> 这个 dict 中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">migrateCachedSocket</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> fd;</span><br><span class="line">   <span class="keyword">long</span> last_dbid;</span><br><span class="line">   <span class="keyword">time_t</span> last_use_time;</span><br><span class="line">&#125; migrateCachedSocket;</span><br></pre></td></tr></table></figure><p><code>migrateCachedSocket</code> 结构体包含 socket fd，上一次迁移数据用到的 db，以及连接上一次使用的时间 <code>last_use_time</code>。<br>将 socket 缓存下来的目的是，当要迁移的 key 很多时，一次 migrate 命令是迁不完的，缓存下来 socket 可以减少创建成本。<br><code>last_use_time</code> 变量存在的意义是，为了节省资源，缓存的连接需要做定期清理，该逻辑在函数 <code>migrateCloseTimedoutSockets</code> 中，如果一个连接 <strong>10 s</strong> 未使用，就把它 close 掉。<br><code>last_dbid</code> 的作用是，强制发送 <code>SELECT</code> 命令，以切换数据库。<br>当缓存的连接数量足够多时，会随机剔除一个，以容纳新的连接。<br>然后，设置 fd 为非阻塞式的，在给定时间内，看一下是否连接成功了。成功后返回一个 <code>migrateCachedSocket</code> 类型的变量，并放到 <code>migrate_cached_sockets</code> 中缓存起来。</p></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="social-share" data-disabled="google,facebook,qzone,twitter,diandian,linkedin,qzone,tencent"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/badab03c.html"><i class="fa fa-chevron-left"></i><span>Redis源码分析之数据迁移(2)</span></a></div><div class="next-post pull-right"><a href="/9025979a.html"><span>Redis源码之主从复制(4)</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script>!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script></div></div></div><footer class="footer-bg" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;&nbsp;2016 - 2020 By Happen</div><div class="framework-info"><span>Powered by</span> <a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>