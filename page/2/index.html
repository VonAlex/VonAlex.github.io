<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/dolphin.png"><link rel="icon" type="image/png" href="/images/dolphin.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#433d3c"><meta name="description" content=""><meta name="author" content="Happen"><meta name="keywords" content=""><title>HappenのMemo</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body><header style="height:100vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>HappenのMemo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(https://gitee.com/happencc/pics/raw/master/images/index-banner.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"><span class="h2" id="subtitle"></span></div><div class="scroll-down-bar"><i class="iconfont icon-arrowdown"></i></div></div></div></div></header><main><div class="container nopadding-md"><div class="py-5" id="board" style="margin-top:0"><div class="container"><div class="row"><div class="col-12 col-md-10 m-auto"><div class="row mx-auto index-card"><div class="col-12 col-md-4 m-auto index-img"><a href="/54df012b.html" target="_self"><img src="https://gitee.com/happencc/pics/raw/master/images/redis.png" srcset="/img/loading.gif" alt="Redis 源码之故障转移"></a></div><article class="col-12 col-md-8 mx-auto index-info"><h1 class="index-header"><a href="/54df012b.html">Redis 源码之故障转移</a></h1><p class="index-excerpt"><a href="/54df012b.html">在 Redis cluster 中故障转移是个很重要的功能，下面就从故障发现到故障转移整个流程做一下详细分析。 1. 故障检测 1.1 PFAIL 标记 集群中每个节点都会定期向其他节点发送 PING 消息，以此来检测对方是否在线，如果接收 PING 消息的节点 B 没有在规定时间（cluster_node_timeout）内回应节点 A PONG 消息，那么节点 A 就会将节点 B 标记为疑似</a></p><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2019-01-31 16:13" pubdate>2019-01-31</time></div><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/redis/">redis</a></div></div></article></div><div class="row mx-auto index-card"><div class="col-12 col-md-4 m-auto index-img"><a href="/d15eb256.html" target="_self"><img src="https://gitee.com/happencc/pics/raw/master/images/redis.png" srcset="/img/loading.gif" alt="Redis 持久化之 AOF 重写"></a></div><article class="col-12 col-md-8 mx-auto index-info"><h1 class="index-header"><a href="/d15eb256.html">Redis 持久化之 AOF 重写</a></h1><p class="index-excerpt"><a href="/d15eb256.html">因为 AOF 持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF 文件中的内容会原来越多，文件的体积也会越来越大，若不加以控制，体积过大的 AOF 文件很可能对 Redis 服务器、甚至整个宿主计算机造成影响，并且其体积越大，使用 AOF 文件来进行数据还原所需要的时间就越长。 为防止 aofrewrite 过程阻塞服务器，Redis 服务器会 fork</a></p><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2019-01-20 01:55" pubdate>2019-01-20</time></div><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/redis/">redis</a></div></div></article></div><div class="row mx-auto index-card"><div class="col-12 col-md-4 m-auto index-img"><a href="/fd3e9e30.html" target="_self"><img src="https://gitee.com/happencc/pics/raw/master/images/redis.png" srcset="/img/loading.gif" alt="Redis 持久化之 AOF"></a></div><article class="col-12 col-md-8 mx-auto index-info"><h1 class="index-header"><a href="/fd3e9e30.html">Redis 持久化之 AOF</a></h1><p class="index-excerpt"><a href="/fd3e9e30.html">除了 RDB 持久化功能之外，Redis 还提供了 AOF（Append Only File）持久化功能。与 RDB 持久化通过保存数据库中的键值对来记录数据库状态不同，AOF 持久化是通过保存 Redis 服务器所执行的写命令来记录数据库状态的。 简介 AOF 文件中记录了 Redis 服务器所执行的写命令，以此来保存数据库的状态。AOF 文件本质上是一个 redo log，通过它可以恢复数据</a></p><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2019-01-14 16:09" pubdate>2019-01-14</time></div><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/redis/">redis</a></div></div></article></div><div class="row mx-auto index-card"><div class="col-12 col-md-4 m-auto index-img"><a href="/3581d0f0.html" target="_self"><img src="https://gitee.com/happencc/pics/raw/master/images/gopher.png" srcset="/img/loading.gif" alt="golang 中下划线的使用"></a></div><article class="col-12 col-md-8 mx-auto index-info"><h1 class="index-header"><a href="/3581d0f0.html">golang 中下划线的使用</a></h1><p class="index-excerpt"><a href="/3581d0f0.html">在 Golang 里， _ （下划线）是个特殊的标识符。前几天看 gin 源码，看到一个有意思的用法。虽然网上的总结博客已有很多，但是总是有点欠缺，于是就有了这一篇，方便以后查阅。 用在 import 在导包的时候，常见这个用法，尤其是项目中使用到 mysql 或者使用 pprof 做性能分析时，比如 import _ &quot;net/http/pprof&quot; import _ &</a></p><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2019-01-06 16:07" pubdate>2019-01-06</time></div><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a href="/categories/quick-start/">quick-start</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/go/">go</a></div></div></article></div><div class="row mx-auto index-card"><div class="col-12 col-md-4 m-auto index-img"><a href="/c62267d.html" target="_self"><img src="https://gitee.com/happencc/pics/raw/master/images/redis.png" srcset="/img/loading.gif" alt="Redis 源码之 cluster meet"></a></div><article class="col-12 col-md-8 mx-auto index-info"><h1 class="index-header"><a href="/c62267d.html">Redis 源码之 cluster meet</a></h1><p class="index-excerpt"><a href="/c62267d.html">本文主要用来厘清cluster meet 命令执行后，一个节点如何加入集群，重点关注各节点路由打平。 一个新启动的节点 B 想要加入一个已有的 cluster，选 cluster 中一个节点 A，在 A 上 meet B。整个流程如下图所示， 图上大致可以分为 3 个阶段： A 通过 meet msg 的 pong 回包，更改 A 对 B 的认识 B 更过 ping msg 的 pong 回</a></p><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2018-12-10 00:02" pubdate>2018-12-10</time></div><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/redis/">redis</a></div></div></article></div><div class="row mx-auto index-card"><div class="col-12 col-md-4 m-auto index-img"><a href="/3800d1bd.html" target="_self"><img src="https://gitee.com/happencc/pics/raw/master/images/redis.png" srcset="/img/loading.gif" alt="Redis 源码之 cluster 初始化"></a></div><article class="col-12 col-md-8 mx-auto index-info"><h1 class="index-header"><a href="/3800d1bd.html">Redis 源码之 cluster 初始化</a></h1><p class="index-excerpt"><a href="/3800d1bd.html">Redis Cluster 是官方提出的 redis 分布式集群解决方案，在此之前，也有一些第三方的可选方案，如 codis、Twemproxy 等。 cluster 内部使用了 gossip 协议进行通信，以达到数据的最终一致性。详细介绍可参考官网 Redis cluster tutorial。 当 redis server 以 cluster mode 启动时，即配置文件中的 clust</a></p><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2018-12-09 00:02" pubdate>2018-12-09</time></div><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/redis/">redis</a></div></div></article></div><div class="row mx-auto index-card"><div class="col-12 col-md-4 m-auto index-img"><a href="/35a9decf.html" target="_self"><img src="https://gitee.com/happencc/pics/raw/master/images/redis.png" srcset="/img/loading.gif" alt="Redis 源码之启动流程"></a></div><article class="col-12 col-md-8 mx-auto index-info"><h1 class="index-header"><a href="/35a9decf.html">Redis 源码之启动流程</a></h1><p class="index-excerpt"><a href="/35a9decf.html">说说 redis 的启动流程。 首先要找到 启动函数，我们知道 C 程序从 main 函数开始，所以，就找到了“梦想”开始的地方 server.c -&gt; main。 这里主要讲启动过程中的主要部分，所以并不会一一涉及到。 大概启动流程 initServerConfig 函数 整个代码中最重要的结构体莫过于 struct redisServer server，它以一个全局变量的形式出现。本</a></p><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2018-12-08 01:07" pubdate>2018-12-08</time></div><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/redis/">redis</a></div></div></article></div><div class="row mx-auto index-card"><div class="col-12 col-md-4 m-auto index-img"><a href="/9ceee0f6.html" target="_self"><img src="https://gitee.com/happencc/pics/raw/master/images/redis.png" srcset="/img/loading.gif" alt="Redis 源码之 Bio"></a></div><article class="col-12 col-md-8 mx-auto index-info"><h1 class="index-header"><a href="/9ceee0f6.html">Redis 源码之 Bio</a></h1><p class="index-excerpt"><a href="/9ceee0f6.html">很多人提到 Redis 时都会讲这是一个 单线程 的内存数据库，其实不然。虽然 Redis 把处理网络收发和执行命令这些操作都放在了主工作线程，但是除此之外还有许多 bio 后台线程也在兢兢业业的工作着，比如用来处理关闭文件和刷盘这些比较重的 IO 操作。bio，即 Background I/O。 Redis 源码中关于 bio 的部分，主要在 bio.h 和 bio.c 这两个文件中。 任</a></p><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2018-10-29 12:35" pubdate>2018-10-29</time></div><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/redis/">redis</a></div></div></article></div><div class="row mx-auto index-card"><div class="col-12 col-md-4 m-auto index-img"><a href="/d68bbf73.html" target="_self"><img src="https://gitee.com/happencc/pics/raw/master/images/redis.png" srcset="/img/loading.gif" alt="Redis 基本数据结构之 dict"></a></div><article class="col-12 col-md-8 mx-auto index-info"><h1 class="index-header"><a href="/d68bbf73.html">Redis 基本数据结构之 dict</a></h1><p class="index-excerpt"><a href="/d68bbf73.html">字典，又称为符号表 (symbol table)、关联数组(associative array) 或者映射(map)，是一种用于保存键值对(key-value pair) 的抽象数据结构。 dict 是一种非常常用的数据结构，因为 c 语言里没有内置这种数据结构，所以 redis 内部实现了自己的 dict 数据结构。 dict 在 redis 中被广泛使用，如 redis 的数据库就是使</a></p><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2018-09-08 14:04" pubdate>2018-09-08</time></div><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/redis/">redis</a></div></div></article></div><div class="row mx-auto index-card"><div class="col-12 col-md-4 m-auto index-img"><a href="/85f7b0b4.html" target="_self"><img src="https://gitee.com/happencc/pics/raw/master/images/redis.png" srcset="/img/loading.gif" alt="Redis 中的事件"></a></div><article class="col-12 col-md-8 mx-auto index-info"><h1 class="index-header"><a href="/85f7b0b4.html">Redis 中的事件</a></h1><p class="index-excerpt"><a href="/85f7b0b4.html">每个 CS 模式程序，尤其是高并发的网络服务端程序都有自己的网络异步事件处理库，Redis 不例外。Redis 基于 Reactor 模型 封装了自己的事件驱动模型库。你可能会跟我有一样的疑问，为什么作者不使用已有的成熟的相关库，比如 Libevent 或 Libev？作者是 这样 跟别人讨论的，感兴趣的可以了解下。 下面从源码入手介绍下 Redis 中封装的 ae 库。 Redis 中的</a></p><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2018-08-17 01:50" pubdate>2018-08-17</time></div><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/redis/">redis</a></div></div></article></div><div class="row mx-auto index-card"><div class="col-12 col-md-4 m-auto index-img"><a href="/ba6bb8e7.html" target="_self"><img src="https://gitee.com/happencc/pics/raw/master/images/redis.png" srcset="/img/loading.gif" alt="Redis 基本数据结构之双向链表"></a></div><article class="col-12 col-md-8 mx-auto index-info"><h1 class="index-header"><a href="/ba6bb8e7.html">Redis 基本数据结构之双向链表</a></h1><p class="index-excerpt"><a href="/ba6bb8e7.html">链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。 链表是一种非常常见的数据结构。由于 redis 使用的 C 语言并没有这种数据结构，因此，作者在 redis 对这一数据结构进行了实现。redis 的链表实现为双向链表，主要用在实现列表键、发布订阅、保存多客户端状态、服务器模块，订阅模块和保存输入命令等方面，使用较广。 redis 源码</a></p><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2018-08-13 20:19" pubdate>2018-08-13</time></div><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/redis/">redis</a></div></div></article></div><div class="row mx-auto index-card"><div class="col-12 col-md-4 m-auto index-img"><a href="/fe52c850.html" target="_self"><img src="https://gitee.com/happencc/pics/raw/master/images/linux.jpg" srcset="/img/loading.gif" alt="dstat 工具使用"></a></div><article class="col-12 col-md-8 mx-auto index-info"><h1 class="index-header"><a href="/fe52c850.html">dstat 工具使用</a></h1><p class="index-excerpt"><a href="/fe52c850.html">Dstat 是一个多样化的资源统计工具。官网 上是这么说的，感受一下： Dstat is a versatile replacement for vmstat, iostat, netstat and ifstat. Dstat overcomes some of their limitations and adds some extra features, more counters and</a></p><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2018-07-04 00:35" pubdate>2018-07-04</time></div><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a href="/categories/linux/">linux</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/shell/">shell</a></div></div></article></div><nav aria-label="navigation"><span class="pagination" id="pagination"><a class="extend prev" rel="prev" href="/"><i class="iconfont icon-arrowleft"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="iconfont icon-arrowright"></i></a></span></nav><script>for (ele of document.getElementById("pagination").getElementsByTagName("a")) {
      ele.href += '#board';
    }</script></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","Stay foolish, Stay hungry&nbsp;"],cursorChar:"|",typeSpeed:72,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script></body></html>