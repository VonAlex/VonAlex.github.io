<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Redis源码分析之数据迁移(2)"><meta name="keywords" content="redis"><meta name="author" content="Happen"><meta name="copyright" content="Happen"><title>Redis源码分析之数据迁移(2) | Happen's Memo</title><link rel="shortcut icon" href="/images/dolphin.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?882b48640075e00a238ae94a7eec0d40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,c,g,o){e.GoogleAnalyticsObject=c,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,g=a.createElement(t),o=a.getElementsByTagName(t)[0],g.async=1,g.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(g,o)}(window,document,"script",0,"ga"),ga("create","RRBput3V2WYVZd2lq058Z4IwJEhViOwuMElqkWh6bcA","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#processCommand-函数处理"><span class="toc-number">1.</span> <span class="toc-text">processCommand 函数处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getNodeByQuery-函数处理"><span class="toc-number">2.</span> <span class="toc-text">getNodeByQuery 函数处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MOVED-与-ASK-重定向"><span class="toc-number">3.</span> <span class="toc-text">MOVED 与 ASK 重定向</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.png"></div><div class="author-info__name text-center">Happen</div><div class="author-info__description text-center">浮生若梦，为欢几何</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">39</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://renrenlove.me/" target="_blank" rel="noopener">Galway</a><a class="author-info-links__name text-center" href="http://kvguru.com/" target="_blank" rel="noopener">Wangbin</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div id="page-header"> <span class="pull-left"><a id="site-name" href="/">Happen's Memo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Redis源码分析之数据迁移(2)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a><div class="post-meta-wordcount"><span>字数总计:</span> <span class="word-count">2.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 8 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>上一篇文章中，详细讲解了 redis cluster 中说数据迁移的流程，那在迁移过程中，节点对正常用户访问是如何处理的呢？<br>本篇文章将探讨一下。</p><a id="more"></a><h3 id="processCommand-函数处理"><a href="#processCommand-函数处理" class="headerlink" title="processCommand 函数处理"></a>processCommand 函数处理</h3><p>众所周知，<code>processCommand</code> 函数负责处理具体的命令处理过程，</p><p>在 cluster 模式下，此函数中会进行 cluster 重定向，但 2 种情况除外：</p><ul><li>发送命令的是我的 master</li><li>发送的命令没有 key 参数</li></ul><p>具体代码，如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.cluster_enabled &amp;&amp;</span><br><span class="line">    !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">    !(c-&gt;flags &amp; CLIENT_LUA &amp;&amp;</span><br><span class="line">    server.lua_caller-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">    !(c-&gt;cmd-&gt;getkeys_proc == <span class="literal">NULL</span> &amp;&amp; c-&gt;cmd-&gt;firstkey == <span class="number">0</span> &amp;&amp;</span><br><span class="line">    c-&gt;cmd-&gt;proc != execCommand))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> hashslot;</span><br><span class="line">    <span class="keyword">int</span> error_code;</span><br><span class="line">    clusterNode *n = getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,</span><br><span class="line">                                        &amp;hashslot,&amp;error_code);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="literal">NULL</span> || n != server.cluster-&gt;myself) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;cmd-&gt;proc == execCommand) &#123;</span><br><span class="line">            discardTransaction(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flagTransaction(c);</span><br><span class="line">        &#125;</span><br><span class="line">        clusterRedirectClient(c,n,hashslot,error_code);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上可以看出，代码中使用 <code>getNodeByQuery</code> 函数负责处理 hashslot 的节点 n。<br>如果 n 是空的，或者不是我自己，那么就需要做一个 cluster 的 redirection，使用 <code>clusterRedirectClient</code> 函数，该函数主要是针对 <code>getNodeByQuery</code> 函数返回的不同错误码，给 client 不同的返回信息，具体代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterRedirectClient</span><span class="params">(client *c, clusterNode *n, <span class="keyword">int</span> hashslot, <span class="keyword">int</span> error_code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error_code == CLUSTER_REDIR_CROSS_SLOT) &#123;</span><br><span class="line">        addReplySds(c,sdsnew(<span class="string">"-CROSSSLOT Keys in request don't hash to the same slot\r\n"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error_code == CLUSTER_REDIR_UNSTABLE) &#123;</span><br><span class="line">        addReplySds(c,sdsnew(<span class="string">"-TRYAGAIN Multiple keys request during rehashing of slot\r\n"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error_code == CLUSTER_REDIR_DOWN_STATE) &#123;</span><br><span class="line">        addReplySds(c,sdsnew(<span class="string">"-CLUSTERDOWN The cluster is down\r\n"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error_code == CLUSTER_REDIR_DOWN_UNBOUND) &#123;</span><br><span class="line">        addReplySds(c,sdsnew(<span class="string">"-CLUSTERDOWN Hash slot not served\r\n"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error_code == CLUSTER_REDIR_MOVED || error_code == CLUSTER_REDIR_ASK)</span><br><span class="line">    &#123;</span><br><span class="line">        addReplySds(c,sdscatprintf(sdsempty(),</span><br><span class="line">            <span class="string">"-%s %d %s:%d\r\n"</span>,</span><br><span class="line">            (error_code == CLUSTER_REDIR_ASK) ? <span class="string">"ASK"</span> : <span class="string">"MOVED"</span>,</span><br><span class="line">            hashslot,n-&gt;ip,n-&gt;port));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"getNodeByQuery() unknown error."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后返回 <code>C_OK</code>，结束命令处理流程，因为涉及到的 slot 不是本节点负责！</p><h3 id="getNodeByQuery-函数处理"><a href="#getNodeByQuery-函数处理" class="headerlink" title="getNodeByQuery 函数处理"></a>getNodeByQuery 函数处理</h3><p>下面来看下比较重要的 <code>getNodeByQuery</code> 函数的处理逻辑，它用来返回负责访问 slot 的真实节点。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">multiState *ms, _ms;</span><br><span class="line">multiCmd mc;</span><br><span class="line"><span class="keyword">int</span> i, slot = <span class="number">0</span>, migrating_slot = <span class="number">0</span>, importing_slot = <span class="number">0</span>, missing_keys = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* Set error code optimistically for the base case. */</span></span><br><span class="line"><span class="keyword">if</span> (error_code) *error_code = CLUSTER_REDIR_NONE;</span><br><span class="line"><span class="keyword">if</span> (cmd-&gt;proc == execCommand) &#123;</span><br><span class="line">    <span class="comment">/* If CLIENT_MULTI flag is not set EXEC is just going to return an</span></span><br><span class="line"><span class="comment">     * error. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) <span class="keyword">return</span> myself;</span><br><span class="line">        ms = &amp;c-&gt;mstate;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* In order to have a single codepath create a fake Multi State</span></span><br><span class="line"><span class="comment">         * structure if the client is not in MULTI/EXEC state, this way</span></span><br><span class="line"><span class="comment">         * we have a single codepath below. */</span></span><br><span class="line">        ms = &amp;_ms;</span><br><span class="line">        _ms.commands = &amp;mc;</span><br><span class="line">        _ms.count = <span class="number">1</span>;</span><br><span class="line">        mc.argv = argv;</span><br><span class="line">        mc.argc = argc;</span><br><span class="line">        mc.cmd = cmd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当没有错误时，该函数返回的错误码是 <strong>CLUSTER_REDIR_NONE</strong>。</p><p><strong>注意</strong>：<br>如果当前处于事务模式下，则事务中的所有命令中的所有 key，需要一起进行判断。<br>对于非事务模式下的命令，也按照事务的方式进行处理，只不过本事务只包含当前一条命令。</p><p>如果当前执行的命令是 <code>EXEC</code>，并且 client 没有 <strong>CLIENT_MULTI</strong> 标记，那么直接返回 myself，表示自己能处理这个命令，但是实际上这种情况下，在命令处理函数 <code>execCommand</code> 中，会直接反馈给客户端 <strong>EXEC without MULTI</strong> 错误。<br>否则，构造伪事务数据结构变量 <code>ms</code>，其中只包含当前命令这一条。</p><p>接下来，针对每一条命令，即所有逻辑包裹在如下循环里，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ms-&gt;count; i++) &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每一个命令的相关参数</span></span><br><span class="line">mcmd = ms-&gt;commands[i].cmd;</span><br><span class="line">margc = ms-&gt;commands[i].argc;</span><br><span class="line">margv = ms-&gt;commands[i].argv;</span><br><span class="line">keyindex = getKeysFromCommand(mcmd,margv,margc,&amp;numkeys);</span><br></pre></td></tr></table></figure><p><code>getKeysFromCommand</code> 函数的返回值 <code>keyindex</code> 为本条命令中所有 key 的 index 数组，<code>numkeys</code> 则为 key 的个数。<br>接下来就循环处理本条命令中的所有 key。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环处理每个 key</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numkeys; j++) &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拿到 key</span></span><br><span class="line">robj *thiskey = margv[keyindex[j]];</span><br><span class="line"><span class="comment">// 拿到对应的 slot</span></span><br><span class="line"><span class="keyword">int</span> thisslot = keyHashSlot((<span class="keyword">char</span>*)thiskey-&gt;ptr, sdslen(thiskey-&gt;ptr));</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (firstkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是该命令中的一个 key，记录到 firstkey 里</span></span><br><span class="line">    firstkey = thiskey;</span><br><span class="line">    slot = thisslot;</span><br><span class="line">    n = server.cluster-&gt;slots[slot];</span><br><span class="line">    <span class="comment">// 找不到负责该 slot 的节点，报错 "-CLUSTERDOWN, unbound slot."</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        getKeysFreeResult(keyindex);</span><br><span class="line">        <span class="keyword">if</span> (error_code)</span><br><span class="line">            *error_code = CLUSTER_REDIR_DOWN_UNBOUND;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 是我负责的 slot，并且该 slot 正在迁出 key</span></span><br><span class="line">     <span class="keyword">if</span> (n == myself</span><br><span class="line">         &amp;&amp; server.cluster-&gt;migrating_slots_to[slot] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">         migrating_slot = <span class="number">1</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.cluster-&gt;importing_slots_from[slot] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">         importing_slot = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个重要的逻辑。<br>当要操作的 key 对应的 slot 是我负责的，并且该 slot 正在迁出 key，那么标记 <code>migrating_slot = 1</code>。<br>如果这个 slot 不是我负责的，那么标记 <code>importing_slot = 1</code>。</p><p>如果不是第一个 key，就要看下<strong>是不是所有的 key 都在一个 slot 上</strong>，否则，会报错 <strong>CROSSSLOT Keys in request don’t hash to the same slot</strong>。代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!equalStringObjects(firstkey,thiskey)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (slot != thisslot) &#123;</span><br><span class="line">       <span class="comment">/* Error: multiple keys from different slots. */</span></span><br><span class="line">        getKeysFreeResult(keyindex);</span><br><span class="line">        <span class="keyword">if</span> (error_code)</span><br><span class="line">            *error_code = CLUSTER_REDIR_CROSS_SLOT;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Flag this request as one with multiple different keys. */</span></span><br><span class="line">         multiple_keys = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，对于多 key 操作，涉及到的 key 需要在一个 slot 上，否则会报错。</p><p>同时，遇到正在迁入迁出 key 的 slot 还要统计 missing_keys（本地找不到的 key，可能已经迁移到目的地了）。如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((migrating_slot || importing_slot) &amp;&amp;</span><br><span class="line">    lookupKeyRead(&amp;server.db[<span class="number">0</span>],thiskey) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     missing_keys++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结束了每个命令的处理，接着往下走，对于有迁入迁出 slot 的情况是如何处理的呢？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令里没有 key，本节点就可以处理，返回 myself</span></span><br><span class="line"><span class="keyword">if</span> (n == <span class="literal">NULL</span>) <span class="keyword">return</span> myself;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集群状态不正常，返回错误 -CLUSTERDOWN</span></span><br><span class="line"><span class="keyword">if</span> (server.cluster-&gt;state != CLUSTER_OK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error_code) *error_code = CLUSTER_REDIR_DOWN_STATE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有正在迁入或者迁出的 slot，且正执行的命令是 MIGRATE，返回 myself</span></span><br><span class="line"><span class="comment">// MIGRATE 命令总是在本地上下文环境中运行的</span></span><br><span class="line"><span class="keyword">if</span> ((migrating_slot || importing_slot) &amp;&amp; cmd-&gt;proc == migrateCommand)</span><br><span class="line">    <span class="keyword">return</span> myself;</span><br></pre></td></tr></table></figure><p>对于访问到迁入迁出 slot 中的 key 的处理，如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (migrating_slot &amp;&amp; missing_keys) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error_code) *error_code = CLUSTER_REDIR_ASK;</span><br><span class="line">    <span class="keyword">return</span> server.cluster-&gt;migrating_slots_to[slot];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (importing_slot &amp;&amp;</span><br><span class="line"> (c-&gt;flags &amp; CLIENT_ASKING || cmd-&gt;flags &amp; CMD_ASKING)) &#123;</span><br><span class="line">     <span class="keyword">if</span> (multiple_keys &amp;&amp; missing_keys) &#123;</span><br><span class="line">         <span class="keyword">if</span> (error_code) *error_code = CLUSTER_REDIR_UNSTABLE;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 否则返回 myself</span></span><br><span class="line">         <span class="keyword">return</span> myself;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若访问的 slot 正在做迁出，且存在正常访问的 key 在本地查不到，那么报错 <strong>-ASK</strong>，并返回该 key 迁移到的目的节点（可能是迁到目的节点了）。<br>若访问的 slot 正在做迁入，且 client 带有 <strong>CLIENT_ASKING</strong> 标记，或者 cmd 带有 <strong>CMD_ASKING</strong> 的标记。此时，如果涉及到多 key 操作，且有的key不在当前节点中，报错 <strong>-TRYAGAIN</strong>（后面重试），返回 NULL。否则，返回 myself（因为所有的 key 我都有嘛）。</p><hr><p>经过上面两条分析，<strong>下面总结一下</strong>：<br>当要访问的 slot 恰好在做迁移，那么 redis 有如下逻辑。<br><code>multiple_keys</code> 变量表示这是否是个多 key 操作。<br><code>missing_keys</code> 变量表示，要访问的 key，是否都在本节点。</p><p>对于单 key 操作，</p><ul><li><p>写 key 时，因为本地没有这个 key，所以通过 ASK 错误重定向到目标节点进行写入操作。</p></li><li><p>读 key 时，如果本地节点有，那么在本地节点访问，否则通过 ASK 错误，重定向到目标节点进行读取。</p></li></ul><p>对于多 key 操作，</p><ul><li><p>写 key 时，因为本地没有这些 key，所以通过 ASK 错误重定向到目标节点，而在目标节点中也没有这些 key，而且又是个多 key 操作，那么报错 <strong>-TRYAGAIN</strong>，只能等到后面这个 slot 迁移完成后才能做多 key 写入。</p></li><li><p>多 key 时，如果本地有所有的 key，那么正常返回。如果本地只有部分 key，那么通过 ASK 错误重定向到目标节点。到了目标节点，如果有全部的 key，那么正常返回，否则报错 <strong>-TRYAGAIN</strong>。（待会再来访问吧，等到所有的 key 都迁过来）</p></li></ul><hr><h3 id="MOVED-与-ASK-重定向"><a href="#MOVED-与-ASK-重定向" class="headerlink" title="MOVED 与 ASK 重定向"></a>MOVED 与 ASK 重定向</h3><p>如果访问到的 slot 不是我负责的，那么报错 <strong>-MOVED</strong>，且返回正确的负责节点。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n != myself &amp;&amp; error_code) *error_code = CLUSTER_REDIR_MOVED;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br></pre></td></tr></table></figure><p>当然，这样也可以很清楚的看到 <strong>MOVED</strong> 和 <strong>ASK</strong> 错误的区别。</p><ul><li><p><strong>ASK</strong> 表示，要访问的 key 所在的 slot 当前正在做迁移，去 ASK 迁入节点处理请求。</p></li><li><p><strong>MOVED</strong> 表示，要访问的 key 所在的 slot 不由本节点负责，MOVED 到正确的节点去访问吧。</p></li></ul><p>接收到 ASK 错误后，client 应该先发送 <code>ASKING</code> 命令到迁入节点，使得 client 带上 <code>CLIENT_ASKING</code> 标记，然后再发送正常命令。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">askingCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled == <span class="number">0</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"This instance has cluster support disabled"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c-&gt;flags |= CLIENT_ASKING;</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="social-share" data-disabled="google,facebook,qzone,twitter,diandian,linkedin,qzone,tencent"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="next-post pull-right"><a href="/91f7e3ff.html"><span>Redis源码分析之数据迁移(1)</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script>!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script></div></div></div><footer class="footer-bg" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;&nbsp;2016 - 2020 By Happen</div><div class="framework-info"><span>Powered by</span> <a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>