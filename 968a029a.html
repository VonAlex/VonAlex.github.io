<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/dolphin.png"><link rel="icon" type="image/png" href="/images/dolphin.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#433d3c"><meta name="description" content=""><meta name="author" content="Happen"><meta name="keywords" content=""><title>Redis 源码之主从复制 (3) - HappenのMemo</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/monokai.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body><header style="height:60vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>HappenのMemo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(/images/about-banner.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"><span class="h2" id="subtitle"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Happen </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2019-09-05 00:20" pubdate>2019-09-05 00:20</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 7.6k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 109 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">Redis 源码之主从复制 (3)</h1><p class="note note-info">本文最后更新于：2019-09-05 00:20</p><div class="markdown-body" id="post-body"><p>redis 代码中主从复制流程的核心部分在于 <strong>状态机的流转</strong>。</p><!--more----><p>单机模式下以 <strong>SLAVEOF</strong> 命令触发；<br>cluster 模式下以 <strong>REPLICATE</strong> 命令触发，且 cluster 模式下不支持 <strong>SLAVEOF</strong> 命令。</p><p>在该过程中，master 与 slave 各有不同的流转逻辑，交互频繁，本文以下内容试图介绍 slave 的处理逻辑, 以下流程图可以辅助理解。<br><img src="https://s2.ax1x.com/2019/09/09/nGjlXd.png" srcset="/img/loading.gif" alt="nGjlXd.png"></p><p>代码中在 <code>redisServer</code> 结构体里定义的很多 <strong>repl</strong> 前缀的变量都用于此过程，如<code>repl_transfer_fd</code>。<br>各变量的作用在源码注释里已经写得非常详细了，不做赘述。</p><h2 id="单机模式下的主从复制">单机模式下的主从复制</h2><p>redis 实例以单机模式启动，即在 <span id="inline-blue">redis.conf </span>中配置 <strong>cluster-enabled no</strong>。</p><h3 id="触发方式">触发方式</h3><p>有以下三种方式可触发主从复制流程。<br>① <span id="inline-blue">redis.conf </span>中配置 <code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>；<br>② redis-server 命令启动服务时指定参数 <code>--slaveof [masterip] [masterport]</code>；<br>③ 对一个实例执行 <code>slaveof [masterip] [masterport]</code> 命令。</p><p>①② 逻辑相似，直接标记 <code>server.repl_state</code> 为 <strong>REPL_STATE_CONNECT</strong> 状态，以 ① 为例简要说明，加载配置文件时有如下逻辑，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadServerConfigFromString</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *config)</span> </span>&#123;
    ....
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!strcasecmp(argv[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;slaveof&quot;</span>) &amp;&amp; argc == <span class="hljs-number">3</span>) &#123;
        slaveof_linenum = linenum;
        server.masterhost = sdsnew(argv[<span class="hljs-number">1</span>]);
        server.masterport = atoi(argv[<span class="hljs-number">2</span>]);
        server.repl_state = REPL_STATE_CONNECT;
    &#125;
....
&#125;</code></pre></div><p>而 ③ 在标记 <code>REPL_STATE_CONNECT</code> 状态前需要做一些检查。<br>首先，检查实例是否开启了 cluster 模式，如果开启了，那么直接返回，不支持这个命令。<br>接着，通过检查 <code>slaveof</code> 命令后面的参数来判断使用的是哪个命令，代码如下，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slaveofCommand</span><span class="hljs-params">(client *c)</span> </span>&#123;
    <span class="hljs-comment">/* cluster 模式开启后，禁用 slaveof 命令 */</span>
    <span class="hljs-keyword">if</span> (server.cluster_enabled) &#123;
        addReplyError(c,<span class="hljs-string">&quot;SLAVEOF not allowed in cluster mode.&quot;</span>);
        <span class="hljs-keyword">return</span>;
    &#125;

   <span class="hljs-comment">// SLAVEOF NO ONE</span>
    <span class="hljs-keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="hljs-number">1</span>]-&gt;ptr,<span class="hljs-string">&quot;no&quot;</span>) &amp;&amp;
        !strcasecmp(c-&gt;argv[<span class="hljs-number">2</span>]-&gt;ptr,<span class="hljs-string">&quot;one&quot;</span>)) &#123;
        <span class="hljs-keyword">if</span> (server.masterhost) &#123; <span class="hljs-comment">// 如果之前有 master</span>
            replicationUnsetMaster();
            sds client = catClientInfoString(sdsempty(),c);
            serverLog(LL_NOTICE,<span class="hljs-string">&quot;MASTER MODE enabled (user request from &#x27;%s&#x27;)&quot;</span>, client);
            sdsfree(client);
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">long</span> port;
        <span class="hljs-comment">// 从参数中获得 port</span>
        <span class="hljs-keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="hljs-number">2</span>], &amp;port, <span class="hljs-literal">NULL</span>) != C_OK))
            <span class="hljs-keyword">return</span>;
        <span class="hljs-comment">// 如果现在的 master 已经是要设置的，那么就不必再做操作了，直接返回吧</span>
        <span class="hljs-keyword">if</span> (server.masterhost &amp;&amp; !strcasecmp(server.masterhost,c-&gt;argv[<span class="hljs-number">1</span>]-&gt;ptr)
            &amp;&amp; server.masterport == port) &#123;
            serverLog(LL_NOTICE,<span class="hljs-string">&quot;SLAVE OF would result into synchronization with the master we are already connected with. No operation performed.&quot;</span>);
            addReplySds(c,sdsnew(<span class="hljs-string">&quot;+OK Already connected to specified master\r\n&quot;</span>));
            <span class="hljs-keyword">return</span>;
        &#125;
        replicationSetMaster(c-&gt;argv[<span class="hljs-number">1</span>]-&gt;ptr, port);
        sds client = catClientInfoString(sdsempty(),c);
        serverLog(LL_NOTICE,<span class="hljs-string">&quot;SLAVE OF %s:%d enabled (user request from &#x27;%s&#x27;)&quot;</span>,
            server.masterhost, server.masterport, client);
        sdsfree(client);
    &#125;
    addReply(c,shared.ok);
&#125;</code></pre></div><h4 id="SLAVEOF-NO-ONE- 命令">SLAVEOF NO ONE 命令</h4><p>该命令会取消现有的主从关系，使 slave 变为 master，主要函数如下，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replicationUnsetMaster</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-comment">// 已经是 master 了，无需继续操作</span>
    <span class="hljs-keyword">if</span> (server.masterhost == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;

    sdsfree(server.masterhost);
    server.masterhost = <span class="hljs-literal">NULL</span>;

    <span class="hljs-keyword">if</span> (server.master) &#123;
        <span class="hljs-keyword">if</span> (listLength(server.slaves) == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// 继承 master 的 repl offset</span>
            server.master_repl_offset = server.master-&gt;reploff;
            freeReplicationBacklog();
        &#125;
        freeClient(server.master);
    &#125;
    replicationDiscardCachedMaster();
    cancelReplicationHandshake();
    server.repl_state = REPL_STATE_NONE;
&#125;</code></pre></div><p>这里主要涉及到一些与 master 相关的变量的内存释放。<br>如果该实例有 master，且不是其他实例的 master，即 <code>listLength(server.slaves) == 0</code>，也就是说未形成链式结构，那么记录下原 master 的 replication offset。在某些特定条件下，副本的数据新鲜度可以通过 replication offset 来比较，有时由于网络等原因暂时断开了，隔了一段时间又重新连上原 master，有了这个偏移量可以减少做完全重同步的可能性(我是这么理解的)。<br><strong>freeClient</strong> 函数会释放掉原来的 master，做一些内存释放，一些标志位重置等。</p><p>接下来的 <code>replicationDiscardCachedMaster</code> 函数中会释放掉 <code>server.cached_master</code>，因为这里缓存以前的 mater 已经没用了，不知道下次要连的是哪个 master，或者自己以后成为一个 master，避免不必要的内存浪费。</p><p><code>cancelReplicationHandshake</code> 函数则会取消一个正在进行尝试 handshake 的主从复制过程。<br>最后重置状态机为 <strong>REPL_STATE_NONE</strong>。</p><h4 id="SLAVEOF-host-port- 命令">SLAVEOF host port 命令</h4><p>通过执行该命令，可以将当前实例变成某个实例的 slave。<br>如果指定的主从关系已经存在，那本次命令没必要继续执行了，直接返回；否则，通过 <code>replicationSetMaster</code> 函数设置新的主从关系，代码如下，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replicationSetMaster</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *ip, <span class="hljs-keyword">int</span> port)</span> </span>&#123;
    sdsfree(server.masterhost);
    server.masterhost = sdsnew(ip);
    server.masterport = port;
    <span class="hljs-comment">// 如果原来有 master 了，需要释放掉</span>
    <span class="hljs-keyword">if</span> (server.master) freeClient(server.master);
    disconnectAllBlockedClients();

    <span class="hljs-comment">// 释放掉所有的 slave，让它们重新连</span>
    disconnectSlaves();
    replicationDiscardCachedMaster();
    freeReplicationBacklog();

    cancelReplicationHandshake();
    server.repl_state = REPL_STATE_CONNECT;
    server.master_repl_offset = <span class="hljs-number">0</span>;
    server.repl_down_since = <span class="hljs-number">0</span>;
&#125;</code></pre></div><p>在以上函数中，<br>先保存下要连接的 ip 和 port，方便后面进行建立网络连接。<br>如果，该节点之前有 master 了，那么需要释放掉原来的 master，跟上面一节的逻辑类似，前面详细说过了。<br><strong>disconnectAllBlockedClients</strong> 函数会 unlock 已经 lock 在这个实例上的 client，并返回 <strong>-UNBLOCKED</strong> 开头的错误。这是因为该实例已经改变了角色，block 已经没什么意义。比如当一个实例从 master 变为 slave，那么由于 list 选项而阻塞在该实例上的 client 就不安全了，<strong>因为数据随着从新的 slave 同步数据，该实例的数据集可能会发生变化</strong>。<br><strong>disconnectSlaves</strong> 函数释放掉所有的 slave，重新同步新的数据。<br>释放掉 <code>server.cached_master</code>，同样因为数据集变化了，cache 的数据并不能用了。<br>释放掉 <code>server.repl_backlog</code>，理由同上。<br><code>cancelReplicationHandshake</code> 函数在上面讲过了。<br>将 <code>server.repl_state</code> 置为 <strong>REPL_STATE_CONNECT</strong> 状态，复制偏离量归零等。<br>最后返回 OK，也就是这个命令的返回值<code>+OK\r\n</code>。</p><h3 id="主从建立连接">主从建立连接</h3><p>redis 中有很多 cron 任务，其中就有一个负责 replication 的，即每秒执行一次的 <strong>replicationCron</strong> 函数。</p><div class="hljs"><pre><code class="hljs c">run_with_period(<span class="hljs-number">1000</span>) replicationCron();</code></pre></div><p>在上一步中，状态机已经流转到 <strong>REPL_STATE_CONNECT</strong> 状态，这里直接就进入到主从建连的逻辑。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replicationCron</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
true......
    <span class="hljs-comment">// 开始一段新的主从关系</span>
    <span class="hljs-keyword">if</span> (server.repl_state == REPL_STATE_CONNECT) &#123;
        serverLog(LL_NOTICE,<span class="hljs-string">&quot;Connecting to MASTER %s:%d&quot;</span>,
            server.masterhost, server.masterport);
        <span class="hljs-keyword">if</span> (connectWithMaster() == C_OK) &#123;
            serverLog(LL_NOTICE,<span class="hljs-string">&quot;MASTER &lt;-&gt; SLAVE sync started&quot;</span>);
        &#125;
    &#125;
  ......
&#125;</code></pre></div><p>使用 <code>server.masterhost</code> 和 <code>server.masterport</code> 向 master 发起 connect 请求， fd 设置为<strong> 非阻塞</strong>。成功后，为 fd 的读写事件注册 <code>syncWithMaster</code> 回调函数，用于处理 master 与 slave 之间的 handshake 过程。这部分逻辑在 <strong>connectWithMaster</strong> 函数中实现，代码如下，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connectWithMaster</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-keyword">int</span> fd;

    <span class="hljs-comment">// 连接 master，获得 fd</span>
    fd = anetTcpNonBlockBestEffortBindConnect(<span class="hljs-literal">NULL</span>, server.masterhost,server.masterport,NET_FIRST_BIND_ADDR);
    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;
        serverLog(LL_WARNING,<span class="hljs-string">&quot;Unable to connect to MASTER: %s&quot;</span>,
            strerror(errno));
        <span class="hljs-keyword">return</span> C_ERR;
    &#125;
    <span class="hljs-comment">// 为 fd 设置读写事件回调 syncWithMaster</span>
    <span class="hljs-keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE,syncWithMaster,<span class="hljs-literal">NULL</span>) == AE_ERR)
    &#123;
        close(fd);
        serverLog(LL_WARNING,<span class="hljs-string">&quot;Can&#x27;t create readable event for SYNC&quot;</span>);
        <span class="hljs-keyword">return</span> C_ERR;
    &#125;

    server.repl_transfer_lastio = server.unixtime;
    server.repl_transfer_s = fd;

    <span class="hljs-comment">// 状态机更新</span>
    server.repl_state = REPL_STATE_CONNECTING;
    <span class="hljs-keyword">return</span> C_OK;
&#125;</code></pre></div><p><code>server.repl_transfer_lastio</code> 用于记录上一次 fd 读事件的时刻，<code>server.repl_transfer_s</code> 记录主从复制使用到的 socket fd。</p><p>更新状态机为 <strong>REPL_STATE_CONNECTING</strong>。</p><h3 id="主从 -handshake- 过程">主从 handshake 过程</h3><h4 id="发送 -ping">发送 ping</h4><p>主从建连成功后，通过 fd 的读写事件触发 <code>syncWithMaster</code> 回调函数。</p><p>如果该事件在用户把本实例用 <strong>SLAVEOF NO ONE</strong> 变成 master 后出触发，那么没有执行下去的必要，判断逻辑如下，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (server.repl_state == REPL_STATE_NONE) &#123;
    close(fd);
    <span class="hljs-keyword">return</span>;
&#125;</code></pre></div><p>下面是同步发送 PING 的代码逻辑，更新状态机为 <strong>REPL_STATE_RECEIVE_PONG</strong>。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (server.repl_state == REPL_STATE_CONNECTING) &#123;
    serverLog(LL_NOTICE,<span class="hljs-string">&quot;Non blocking connect for SYNC fired the event.&quot;</span>);

    <span class="hljs-comment">/* 为了等待 pong 的返回，删除 fd 上的可写事件，但保留可读事件 */</span>
    aeDeleteFileEvent(server.el,fd,AE_WRITABLE);
    server.repl_state = REPL_STATE_RECEIVE_PONG;

    <span class="hljs-comment">/* 同步发送 ping，这里不检查是否 err，因为已经有超时限制做保证 */</span>
    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,<span class="hljs-string">&quot;PING&quot;</span>,<span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">goto</span> write_error;
    <span class="hljs-keyword">return</span>;
&#125;</code></pre></div><p><code>sendSynchronousCommand</code> 函数通过 flag 标识读写命令，此处写命令标识为 <strong>SYNC_CMD_WRITE</strong>。</p><h4 id="验证 -AUTH">验证 AUTH</h4><p>使用 <strong>sendSynchronousCommand</strong> 函数同步读取 master 对 PING 的回复。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_PONG) &#123;
    <span class="hljs-comment">/* 读取上面发送的 ping 命令的 response */</span>
    err = sendSynchronousCommand(SYNC_CMD_READ,fd,<span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> (err[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;+&#x27;</span> &amp;&amp; <span class="hljs-built_in">strncmp</span>(err,<span class="hljs-string">&quot;-NOAUTH&quot;</span>,<span class="hljs-number">7</span>) != <span class="hljs-number">0</span> &amp;&amp;
        <span class="hljs-built_in">strncmp</span>(err,<span class="hljs-string">&quot;-ERR operation not permitted&quot;</span>,<span class="hljs-number">28</span>) != <span class="hljs-number">0</span>)
    &#123;
        serverLog(LL_WARNING,<span class="hljs-string">&quot;Error reply to PING from master: &#x27;%s&#x27;&quot;</span>,err);
        sdsfree(err);
        <span class="hljs-keyword">goto</span> error;
    &#125; <span class="hljs-keyword">else</span> &#123;
        serverLog(LL_NOTICE,
          <span class="hljs-string">&quot;Master replied to PING, replication can continue...&quot;</span>);
    &#125;
    sdsfree(err);
    server.repl_state = REPL_STATE_SEND_AUTH;
&#125;</code></pre></div><p>回复只可能有 3 种情况：<strong>+PONG</strong>，<strong>-NOAUTH</strong> 和 <strong>-ERR operation not permitted</strong>（老版本的 redis 主节点）。如果不是，直接进入错误处理代码流程。</p><p><strong>注意</strong>：这里的读操作会更新变量 <code>server.repl_transfer_lastio</code>。</p><p>调整状态机为 <strong>REDIS_REPL_SEND_AUTH</strong>。这里没有 <code>return</code>，直接往下执行，进入鉴权的逻辑，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (server.repl_state == REPL_STATE_SEND_AUTH) &#123;
    <span class="hljs-keyword">if</span> (server.masterauth) &#123;
        err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,<span class="hljs-string">&quot;AUTH&quot;</span>,server.masterauth,<span class="hljs-literal">NULL</span>);
        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">goto</span> write_error;
        server.repl_state = REPL_STATE_RECEIVE_AUTH;
        <span class="hljs-keyword">return</span>;
    &#125; <span class="hljs-keyword">else</span> &#123;
     	 server.repl_state = REPL_STATE_SEND_PORT;
    &#125;
&#125;</code></pre></div><p>如果配置文件中没有设置 <strong>masterauth</strong> 选项，那么状态机置为 <strong>REPL_STATE_SEND_PORT</strong>。<br>否则，需要发送 <code>AUTH</code> 命令鉴权。状态机置为 <strong>REPL_STATE_RECEIVE_AUTH</strong>。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* Receive AUTH reply. */</span>
<span class="hljs-keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_AUTH) &#123;
    err = sendSynchronousCommand(SYNC_CMD_READ,fd,<span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> (err[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;
        serverLog(LL_WARNING,<span class="hljs-string">&quot;Unable to AUTH to MASTER: %s&quot;</span>,err);
        sdsfree(err);
        <span class="hljs-keyword">goto</span> error;
    &#125;
    sdsfree(err);
    server.repl_state = REPL_STATE_SEND_PORT;
&#125;</code></pre></div><p>验证 auth 通过后，状态机置为 <strong>REPL_STATE_SEND_PORT</strong>，否则，直接跳到的 err 处理流程。</p><h4 id="发送 -REPLCONF- 命令">发送 REPLCONF 命令</h4><p>slave 将发送一连串的 <code>REPLCONF</code> 命令，以告知 master 自己的一些信息。<br><code>slave-announce-ip</code> 和 <code>slave-announce-port</code> 主要是针对转发或者 NAT 场景下，master 无法通过 socket 连接获得对端信息时使用。</p><p>首先发送自己的 port 信息，<code>REPLCONF listening-port &lt;port&gt;</code>，状态机置为 <strong>REPL_STATE_RECEIVE_PORT</strong>，返回，等下一次事件触发。<br>接着，同步读取 master 的回复，即使返回错误也没有关系，状态机置为 <strong>REPL_STATE_SEND_IP</strong>。<br>代码如下，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* Set the slave port, so that Master&#x27;s INFO command can list the</span>
<span class="hljs-comment"> * slave listening port correctly. */</span>
<span class="hljs-keyword">if</span> (server.repl_state == REPL_STATE_SEND_PORT) &#123;
    sds port = sdsfromlonglong(server.slave_announce_port ?
                               server.slave_announce_port : server.port);
    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,<span class="hljs-string">&quot;REPLCONF&quot;</span>,
                                 <span class="hljs-string">&quot;listening-port&quot;</span>,port, <span class="hljs-literal">NULL</span>);
    sdsfree(port);
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">goto</span> write_error;
    sdsfree(err);
    server.repl_state = REPL_STATE_RECEIVE_PORT;
    <span class="hljs-keyword">return</span>;
&#125;

<span class="hljs-keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_PORT) &#123;
    err = sendSynchronousCommand(SYNC_CMD_READ,fd,<span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> (err[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;
      	serverLog(LL_NOTICE,<span class="hljs-string">&quot;(Non critical) Master does not understand &quot;</span>
                <span class="hljs-string">&quot;REPLCONF listening-port: %s&quot;</span>, err);
    &#125;
    sdsfree(err);
    server.repl_state = REPL_STATE_SEND_IP;</code></pre></div><p>如果没有配置 <code>slave-announce-ip</code> 时，直接将状态机调跳转到 <strong>REPL_STATE_SEND_CAPA</strong>，跳过发送 REPLCONF ip-address 的步骤。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (server.repl_state == REPL_STATE_SEND_IP &amp;&amp;
    server.slave_announce_ip == <span class="hljs-literal">NULL</span>)
&#123;
  server.repl_state = REPL_STATE_SEND_CAPA;
&#125;</code></pre></div><p>发送 REPLCONF ip-address，接收回复，将状态机置为 <strong>REPL_STATE_SEND_CAPA</strong>。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* REPLCONF ip-address &lt;ip&gt;  */</span>
<span class="hljs-keyword">if</span> (server.repl_state == REPL_STATE_SEND_IP) &#123;
    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,<span class="hljs-string">&quot;REPLCONF&quot;</span>,
                                 <span class="hljs-string">&quot;ip-address&quot;</span>,server.slave_announce_ip, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">goto</span> write_error;
    sdsfree(err);
    server.repl_state = REPL_STATE_RECEIVE_IP;
    <span class="hljs-keyword">return</span>;
&#125;

<span class="hljs-comment">/* Receive REPLCONF ip-address reply. */</span>
<span class="hljs-keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_IP) &#123;
    err = sendSynchronousCommand(SYNC_CMD_READ,fd,<span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> (err[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;
      serverLog(LL_NOTICE,<span class="hljs-string">&quot;(Non critical) Master does not understand &quot;</span>
                <span class="hljs-string">&quot;REPLCONF ip-address: %s&quot;</span>, err);
    &#125;
    sdsfree(err);
    server.repl_state = REPL_STATE_SEND_CAPA;
&#125;</code></pre></div><p>状态机置为 <strong>REPL_STATE_SEND_CAPA</strong>，告知 master 自己的能力，现在只有 eof，表示支持无磁盘化主从复制，以后可能会有更多，格式为 <code>REPLCONF capa X capa Y capa Z ...</code>。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (server.repl_state == REPL_STATE_SEND_CAPA) &#123;
    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,<span class="hljs-string">&quot;REPLCONF&quot;</span>,
                                 <span class="hljs-string">&quot;capa&quot;</span>,<span class="hljs-string">&quot;eof&quot;</span>,<span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">goto</span> write_error;
    sdsfree(err);
    server.repl_state = REPL_STATE_RECEIVE_CAPA;
    <span class="hljs-keyword">return</span>;
&#125;
<span class="hljs-keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_CAPA) &#123;
    err = sendSynchronousCommand(SYNC_CMD_READ,fd,<span class="hljs-literal">NULL</span>);
    <span class="hljs-comment">/* Ignore the error if any, not all the Redis versions support</span>
<span class="hljs-comment">           * REPLCONF capa. */</span>
    <span class="hljs-keyword">if</span> (err[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;
      	serverLog(LL_NOTICE,<span class="hljs-string">&quot;(Non critical) Master does not understand &quot;</span>
                <span class="hljs-string">&quot;REPLCONF capa: %s&quot;</span>, err);
    &#125;
    sdsfree(err);
    server.repl_state = REPL_STATE_SEND_PSYNC;
&#125;
</code></pre></div><p>状态机置为 <strong>REPL_STATE_SEND_PSYNC</strong>。</p><h4 id="尝试做部分重同步">尝试做部分重同步</h4><p>为解决旧版本 redis 在处理断线情况下完全复制的低效问题， 从 2.8 版本开始，使用 PSYNC 命令代替 SYNC 命令来执行复制时的同步操作，这个点在前面的博客讲过了。</p><p>为高效起见，首先尝试做部分重同步，试探逻辑在函数 <strong>slaveTryPartialResynchronization</strong> 中。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (server.repl_state == REPL_STATE_SEND_PSYNC) &#123;
    <span class="hljs-keyword">if</span> (slaveTryPartialResynchronization(fd,<span class="hljs-number">0</span>) == PSYNC_WRITE_ERROR) &#123;
        err = sdsnew(<span class="hljs-string">&quot;Write error sending the PSYNC command.&quot;</span>);
        <span class="hljs-keyword">goto</span> write_error;
    &#125;
    server.repl_state = REPL_STATE_RECEIVE_PSYNC;
    <span class="hljs-keyword">return</span>;
&#125;</code></pre></div><p><strong>slaveTryPartialResynchronization</strong> 里包含了读写两部分，其中写的部分在上半部，当第二个参数为 0 时，发送 PSYNC 命令，命令格式为 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code>。<br>发送 PSYNC 时，分两种情况，首次连接或非首次连接。首次连接时，runid 未知，用 <code>?</code> 代替，offset 置为初始值 -1。<br>代码逻辑如下，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!read_reply) &#123;
trueserver.repl_master_initial_offset = <span class="hljs-number">-1</span>;

    <span class="hljs-keyword">if</span> (server.cached_master) &#123; <span class="hljs-comment">// 重连</span>
        psync_runid = server.cached_master-&gt;replrunid;
        <span class="hljs-built_in">snprintf</span>(psync_offset,<span class="hljs-keyword">sizeof</span>(psync_offset),<span class="hljs-string">&quot;%lld&quot;</span>, server.cached_master-&gt;reploff+<span class="hljs-number">1</span>);
        serverLog(LL_NOTICE,<span class="hljs-string">&quot;Trying a partial resynchronization (request %s:%s).&quot;</span>, psync_runid, psync_offset);
    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 首次连接 master</span>
        serverLog(LL_NOTICE,<span class="hljs-string">&quot;Partial resynchronization not possible (no cached master)&quot;</span>);
        psync_runid = <span class="hljs-string">&quot;?&quot;</span>;
        <span class="hljs-built_in">memcpy</span>(psync_offset,<span class="hljs-string">&quot;-1&quot;</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">/* psync ? -1 */</span>
    &#125;

    reply = sendSynchronousCommand(SYNC_CMD_WRITE,fd,<span class="hljs-string">&quot;PSYNC&quot;</span>,psync_runid,psync_offset,<span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> (reply != <span class="hljs-literal">NULL</span>) &#123;
        serverLog(LL_WARNING,<span class="hljs-string">&quot;Unable to send PSYNC to master: %s&quot;</span>,reply);
        sdsfree(reply);
        <span class="hljs-comment">/* 发送出错了，需要删掉 fd 上的可读事件 */</span>
        aeDeleteFileEvent(server.el,fd,AE_READABLE);
        <span class="hljs-keyword">return</span> PSYNC_WRITE_ERROR;
    &#125;
    <span class="hljs-keyword">return</span> PSYNC_WAIT_REPLY;
&#125;</code></pre></div><p>发送出错后，需要删掉 fd 上的可读事件。<br>回到 <strong>syncWithMaster</strong> 函数中，状态机置为 <strong>REPL_STATE_RECEIVE_PSYNC</strong>。</p><p>代码逻辑走到这一步，如果状态机的状态不是 <strong>REPL_STATE_RECEIVE_PSYNC</strong>，一定是哪里出错了，进入错误处理流程，即，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* If reached this point, we should be in REPL_STATE_RECEIVE_PSYNC. */</span>
<span class="hljs-keyword">if</span> (server.repl_state != REPL_STATE_RECEIVE_PSYNC) &#123;
    serverLog(LL_WARNING,<span class="hljs-string">&quot;syncWithMaster(): state machine error, &quot;</span>
        <span class="hljs-string">&quot;state should be RECEIVE_PSYNC but is %d&quot;</span>, server.repl_state);
    <span class="hljs-keyword">goto</span> error;
&#125;</code></pre></div><p>接着去读取 master 的给的回复信息，</p><div class="hljs"><pre><code class="hljs c">psync_result = slaveTryPartialResynchronization(fd,<span class="hljs-number">1</span>);</code></pre></div><p>可能会读到三种，<code>+FULLRESYNC</code>、<code>+CONTINUE</code>以及<code>-ERR</code>。</p><div class="hljs"><pre><code class="hljs c">reply = sendSynchronousCommand(SYNC_CMD_READ,fd,<span class="hljs-literal">NULL</span>);
<span class="hljs-keyword">if</span> (sdslen(reply) == <span class="hljs-number">0</span>) &#123;
  <span class="hljs-comment">// 为了保活，master 可能在收到 PSYNC 后且回复前发送空行</span>
  sdsfree(reply);
  <span class="hljs-keyword">return</span> PSYNC_WAIT_REPLY;
&#125;
<span class="hljs-comment">/* 删除 fd 可读事件，方便后面为 f&#x27;d 重新注册新的回调 */</span>
aeDeleteFileEvent(server.el,fd,AE_READABLE);</code></pre></div><p>【1】<code>+FULLRESYNC</code> 回复表示不能进行部分重同步，slave 告诉给 master 的 offset 不在 master 的复制积压缓冲区范围内，只能进行完全重同步，返回给上层函数 <strong>PSYNC_FULLRESYNC</strong>，代码如下，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* 完全重同步得到 response 为 +FULLRESYNC &lt;master_runid&gt; &lt;offset&gt; */</span>
<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strncmp</span>(reply,<span class="hljs-string">&quot;+FULLRESYNC&quot;</span>,<span class="hljs-number">11</span>)) &#123;
    <span class="hljs-keyword">char</span> *runid = <span class="hljs-literal">NULL</span>, *offset = <span class="hljs-literal">NULL</span>;
    runid = <span class="hljs-built_in">strchr</span>(reply,<span class="hljs-string">&#x27; &#x27;</span>);
    <span class="hljs-keyword">if</span> (runid) &#123;
        runid++;
        offset = <span class="hljs-built_in">strchr</span>(runid,<span class="hljs-string">&#x27; &#x27;</span>);
        <span class="hljs-keyword">if</span> (offset) offset++;
    &#125;
    <span class="hljs-comment">/* 有可能是 master 发送格式有问题，先把 repl_master_runid 置空 */</span>
    <span class="hljs-keyword">if</span> (!runid || !offset || (offset-runid<span class="hljs-number">-1</span>) != CONFIG_RUN_ID_SIZE) &#123;
        serverLog(LL_WARNING,
                  <span class="hljs-string">&quot;Master replied with wrong +FULLRESYNC syntax.&quot;</span>);
        <span class="hljs-built_in">memset</span>(server.repl_master_runid,<span class="hljs-number">0</span>,CONFIG_RUN_ID_SIZE+<span class="hljs-number">1</span>);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-built_in">memcpy</span>(server.repl_master_runid, runid, offset-runid<span class="hljs-number">-1</span>);
        server.repl_master_runid[CONFIG_RUN_ID_SIZE] = <span class="hljs-string">&#x27;\0&#x27;</span>;
        server.repl_master_initial_offset = strtoll(offset,<span class="hljs-literal">NULL</span>,<span class="hljs-number">10</span>);
        serverLog(LL_NOTICE,<span class="hljs-string">&quot;Full resync from master: %s:%lld&quot;</span>,
                  server.repl_master_runid,
                  server.repl_master_initial_offset);
    &#125;
    <span class="hljs-comment">/* We are going to full resync, discard the cached master structure. */</span>
    replicationDiscardCachedMaster();
    sdsfree(reply);
    <span class="hljs-keyword">return</span> PSYNC_FULLRESYNC;
&#125;</code></pre></div><p>以上代码解析出 master 的 runid，以及 offset，分别赋值给 <code>repl_master_runid</code> 和 <code>repl_master_initial_offset</code>。因为要进行全同步，<code>cached_master</code> 保存的信息就失效了，需要重置，即函数 <code>replicationDiscardCachedMaster</code> 的调用。</p><p>【2】<code>+CONTINUE</code> 表示可以进行部分重同步，返回给上层函数 <strong>PSYNC_CONTINUE</strong>。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strncmp</span>(reply,<span class="hljs-string">&quot;+CONTINUE&quot;</span>,<span class="hljs-number">9</span>)) &#123;
    serverLog(LL_NOTICE,
              <span class="hljs-string">&quot;Successful partial resynchronization with master.&quot;</span>);
    sdsfree(reply);
    replicationResurrectCachedMaster(fd);
    <span class="hljs-keyword">return</span> PSYNC_CONTINUE;
&#125;</code></pre></div><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replicationResurrectCachedMaster</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newfd)</span> </span>&#123;
    server.master = server.cached_master;
    server.cached_master = <span class="hljs-literal">NULL</span>;
    server.master-&gt;fd = newfd;
    server.master-&gt;flags &amp;= ~(CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP);
    server.master-&gt;authenticated = <span class="hljs-number">1</span>;
    server.master-&gt;lastinteraction = server.unixtime;
    server.repl_state = REPL_STATE_CONNECTED;

    <span class="hljs-comment">/* Re-add to the list of clients. */</span>
    listAddNodeTail(server.clients,server.master);
    <span class="hljs-keyword">if</span> (aeCreateFileEvent(server.el, newfd, AE_READABLE,
                          readQueryFromClient, server.master)) &#123;
        serverLog(LL_WARNING,<span class="hljs-string">&quot;Error resurrecting the cached master, impossible to add the readable handler: %s&quot;</span>, strerror(errno));
        freeClientAsync(server.master); <span class="hljs-comment">/* Close ASAP. */</span>
    &#125;

    <span class="hljs-keyword">if</span> (clientHasPendingReplies(server.master)) &#123;
        <span class="hljs-keyword">if</span> (aeCreateFileEvent(server.el, newfd, AE_WRITABLE,
                          sendReplyToClient, server.master)) &#123;
            serverLog(LL_WARNING,<span class="hljs-string">&quot;Error resurrecting the cached master, impossible to add the writable handler: %s&quot;</span>, strerror(errno));
            freeClientAsync(server.master); <span class="hljs-comment">/* Close ASAP. */</span>
        &#125;
    &#125;
&#125;</code></pre></div><p>可以看出，从 <code>cached_master</code> 恢复 master，将状态机置为 <strong>REPL_STATE_CONNECTED</strong>。<br>为 fd 的读事件注册新的回调函数 readQueryFromClient。<br>如果在<code>server.master</code> 上仍然有 reply，或者是在写 buffer 里有数据，那么需要为写事件注册回调函数 <code>sendReplyToClient</code>。</p><p>【3】<code>-ERR</code> 的情况。需要清理现有的 <code>cached_master</code>，返回给上层函数 <strong>PSYNC_NOT_SUPPORTED</strong> 。</p><p>回到 <strong>syncWithMaster</strong> 函数里，处理 PSYNC 命令的返回值。<br>当返回的是 <strong>PSYNC_CONTINUE</strong> 时，表示进行的是部分重同步，该函数结束。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (psync_result == PSYNC_CONTINUE) &#123; <span class="hljs-comment">/* 部分重同步 ，不会走到下面接收 rdb 的流程 */</span>
  serverLog(LL_NOTICE, <span class="hljs-string">&quot;MASTER &lt;-&gt; SLAVE sync: Master accepted a Partial Resynchronization.&quot;</span>);
  <span class="hljs-keyword">return</span>;
&#125;</code></pre></div><p>否则，有两种可能，进行完全重同步，或者 master 不支持 PSYNC 命令(老版本的 master)，但是无论如何都需要断开现有的所有 slave，因为新 master 可能会传过来一份不同的数据。<br>同时清空复制积压缓冲区，即 repl_backlog，不允许我的 slave 做 psync 了（<strong>毕竟数据不同了嘛</strong>）。</p><p>如果新 master 不支持 PSYNC 命令，那么同步发送 SYNC 命令。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (psync_result == PSYNC_NOT_SUPPORTED) &#123;
    serverLog(LL_NOTICE,<span class="hljs-string">&quot;Retrying with SYNC...&quot;</span>);
    <span class="hljs-keyword">if</span> (syncWrite(fd,<span class="hljs-string">&quot;SYNC\r\n&quot;</span>,<span class="hljs-number">6</span>,server.repl_syncio_timeout*<span class="hljs-number">1000</span>) == <span class="hljs-number">-1</span>) &#123;
        serverLog(LL_WARNING,<span class="hljs-string">&quot;I/O error writing to MASTER: %s&quot;</span>,
                  strerror(errno));
        <span class="hljs-keyword">goto</span> error;
    &#125;
&#125;</code></pre></div><p>如果没有出错，接下来准备完全重同步阶段 master 发过来的 rdb 数据。创建一个名字以 tmp 为前缀的临时 rdb 接收文件，打开，并记录 fd，最多 5 次，要是还不能成功创建一个临时文件，那么就走错误处理的流程了。代码如下，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(maxtries--) &#123;
    <span class="hljs-built_in">snprintf</span>(tmpfile,<span class="hljs-number">256</span>,
             <span class="hljs-string">&quot;temp-%d.%ld.rdb&quot;</span>,(<span class="hljs-keyword">int</span>)server.unixtime,(<span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span>)getpid());
    dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL,<span class="hljs-number">0644</span>);
    <span class="hljs-keyword">if</span> (dfd != <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;
    sleep(<span class="hljs-number">1</span>);
&#125;
<span class="hljs-keyword">if</span> (dfd == <span class="hljs-number">-1</span>) &#123;
    serverLog(LL_WARNING,<span class="hljs-string">&quot;Opening the temp file needed for MASTER &lt;-&gt; SLAVE synchronization: %s&quot;</span>,strerror(errno));
    <span class="hljs-keyword">goto</span> error;
&#125;</code></pre></div><p>接着为 fd 的读事件注册回调函数 <code>readSyncBulkPayload</code>，用来处理从 master 读到的数据 rdb 文件。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* 为 fd 的可读事件注册新的函数 readSyncBulkPayload */</span>
<span class="hljs-keyword">if</span> (aeCreateFileEvent(server.el,fd, AE_READABLE,readSyncBulkPayload,<span class="hljs-literal">NULL</span>) == AE_ERR)
&#123;
    serverLog(LL_WARNING,
              <span class="hljs-string">&quot;Can&#x27;t create readable event for SYNC: %s (fd=%d)&quot;</span>,
              strerror(errno),fd);
    <span class="hljs-keyword">goto</span> error;
&#125;</code></pre></div><p>最后是一些 server 变量的赋值。</p><div class="hljs"><pre><code class="hljs c">server.repl_state = REPL_STATE_TRANSFER;
<span class="hljs-comment">/* 初始化 RDB 文件大小 */</span>
server.repl_transfer_size = <span class="hljs-number">-1</span>;
<span class="hljs-comment">/* 已读数据大小 */</span>
server.repl_transfer_read = <span class="hljs-number">0</span>;
<span class="hljs-comment">/* 最近一次执行的 fsync 偏移量 */</span>
server.repl_transfer_last_fsync_off = <span class="hljs-number">0</span>;
<span class="hljs-comment">/* 本地临时 rdb 文件的 fd */</span>
server.repl_transfer_fd = dfd;
<span class="hljs-comment">/* 最近一次读数据的时间 */</span>
server.repl_transfer_lastio = server.unixtime;
<span class="hljs-comment">/* 本地临时 rdb 文件的名字 */</span>
server.repl_transfer_tmpfile = zstrdup(tmpfile);</code></pre></div><p>状态机置为 <strong>REPL_STATE_TRANSFER</strong>，<code>repl_transfer_fd</code> 记录 rdb 临时文件的 fd。</p><h4 id="几个超时保证">几个超时保证</h4><p>在 <strong>replicationCron</strong> 函数中的开始部分，有一些超时保证。</p><p>与 master 建立连接后，一直没能发 PING，说明连接可能有问题。<br>在鉴权和确认 capa 的流程中，花了过多的时间。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (server.masterhost &amp;&amp;
    (server.repl_state == REPL_STATE_CONNECTING ||  slaveIsInHandshakeState()) &amp;&amp;
        (time(<span class="hljs-literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout) <span class="hljs-comment">// 默认 60s 超时</span>
&#123;
    serverLog(LL_WARNING,<span class="hljs-string">&quot;Timeout connecting to the MASTER...&quot;</span>);
    cancelReplicationHandshake();
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">slaveIsInHandshakeState</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-keyword">return</span> server.repl_state &gt;= REPL_STATE_RECEIVE_PONG &amp;&amp;
        server.repl_state &lt;= REPL_STATE_RECEIVE_PSYNC;
&#125;</code></pre></div><p>接收 rdb 文件的时长做限制。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* Bulk transfer I/O timeout? */</span>
<span class="hljs-keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_TRANSFER &amp;&amp;
    (time(<span class="hljs-literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout) <span class="hljs-comment">// 默认 60s 超时</span>
&#123;
    serverLog(LL_WARNING,<span class="hljs-string">&quot;Timeout receiving bulk data from MASTER... If the problem persists try to set the &#x27;repl-timeout&#x27; parameter in redis.conf to a larger value.&quot;</span>);
    cancelReplicationHandshake();
&#125;</code></pre></div><p>成为 slave 以后，没有数据发过来。</p><div class="hljs"><pre><code class="hljs c"> <span class="hljs-comment">/* Timed out master when we are an already connected slave? */</span>
<span class="hljs-keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_CONNECTED &amp;&amp;
    (time(<span class="hljs-literal">NULL</span>)-server.master-&gt;lastinteraction) &gt; server.repl_timeout)
&#123;
    serverLog(LL_WARNING,<span class="hljs-string">&quot;MASTER timeout: no data nor PING received...&quot;</span>);
    freeClient(server.master);
&#125;</code></pre></div><h3 id="接收 -RDB- 文件">接收 RDB 文件</h3><p>接收 rdb 数据有两种方式，一种是磁盘化的，一种是无磁盘化的。</p><blockquote><p>从 V2.8.18 开始，redis 引入了“无硬盘复制”选项，开启该选项时，redis 在与 slave 进行复制初始化时将不会将快照内容存储到硬盘上，而是直接通过网络发送给 slave，避免了硬盘的性能瓶颈，可以在配置文件中使用 <strong>repl-diskless-sync</strong> 选项来配置开启该功能。</p></blockquote><p>两种方式发送的数据格式是不一样的。<br>磁盘化复制时，master 先生成 rdb 文件，然后将文件内容加上 <code>$&lt;len&gt;/r/n</code> 的头部后，发送给 slave。<br>而无磁盘化复制时，master 直接把 rdb 数据发送给你 slave 时，以 <code>$EOF:&lt;XXX&gt;\r\n</code> 开头，并以 <code>&lt;XXX&gt;</code> 结尾，开头和结尾的 <code>&lt;XXX&gt;</code> 内容相同，都是 40 个字节，是由 <strong>0123456789abcdef</strong> 中的字符组成的随机字符串，为了校验数据的是否发送完成。</p><p>该流程主要是回调函数 <code>readSyncBulkPayload</code> 中的逻辑。<br>首先读取 master 传过来的辅助信息。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (server.repl_transfer_size == <span class="hljs-number">-1</span>) &#123;
    <span class="hljs-comment">/* 第一行内容 $&lt;len&gt;/r/n */</span>
    <span class="hljs-keyword">if</span> (syncReadLine(fd,buf,<span class="hljs-number">1024</span>,server.repl_syncio_timeout*<span class="hljs-number">1000</span>) == <span class="hljs-number">-1</span>) &#123;
        serverLog(LL_WARNING,
                  <span class="hljs-string">&quot;I/O error reading bulk count from MASTER: %s&quot;</span>,
                  strerror(errno));
        <span class="hljs-keyword">goto</span> error;
    &#125;

    <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;
        serverLog(LL_WARNING,
                  <span class="hljs-string">&quot;MASTER aborted replication with an error: %s&quot;</span>,
                  buf+<span class="hljs-number">1</span>);
        <span class="hljs-keyword">goto</span> error;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;
        server.repl_transfer_lastio = server.unixtime;
        <span class="hljs-keyword">return</span>;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;$&#x27;</span>) &#123;
        serverLog(LL_WARNING,<span class="hljs-string">&quot;Bad protocol from MASTER, the first byte is not &#x27;$&#x27; (we received &#x27;%s&#x27;), are you sure the host and port are right?&quot;</span>, buf);
        <span class="hljs-keyword">goto</span> error;
    &#125;

  <span class="hljs-comment">/* 有两种可能的 bulk payload 格式，正常的是 $&lt;count&gt;</span>
<span class="hljs-comment">   * 还有一种可能就是无磁盘化主从同步时，因为这个时候不知道后面要传输数据的长度，因此会发送一个分隔符，</span>
<span class="hljs-comment">   * 格式为 $EOF:&lt;40 bytes delimiter&gt;</span>
<span class="hljs-comment">   * 在发送完 rdb 数据后，分隔符会再次被发送，以便让接收端知道数据发送完成了。</span>
<span class="hljs-comment">   * 分隔符足够的长和随机，因此真实文件内容碰撞的可能性可以被忽略。*/</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(buf+<span class="hljs-number">1</span>,<span class="hljs-string">&quot;EOF:&quot;</span>,<span class="hljs-number">4</span>) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">strlen</span>(buf+<span class="hljs-number">5</span>) &gt;= CONFIG_RUN_ID_SIZE) &#123;
      usemark = <span class="hljs-number">1</span>;
      <span class="hljs-built_in">memcpy</span>(eofmark,buf+<span class="hljs-number">5</span>,CONFIG_RUN_ID_SIZE);
      <span class="hljs-built_in">memset</span>(lastbytes,<span class="hljs-number">0</span>,CONFIG_RUN_ID_SIZE);
      server.repl_transfer_size = <span class="hljs-number">0</span>;
      serverLog(LL_NOTICE,
                <span class="hljs-string">&quot;MASTER &lt;-&gt; SLAVE sync: receiving streamed RDB from master&quot;</span>);
    &#125; <span class="hljs-keyword">else</span> &#123;
      usemark = <span class="hljs-number">0</span>;
      server.repl_transfer_size = strtol(buf+<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">10</span>);
      serverLog(LL_NOTICE,
                <span class="hljs-string">&quot;MASTER &lt;-&gt; SLAVE sync: receiving %lld bytes from master&quot;</span>,
                (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) server.repl_transfer_size);
    &#125;
    <span class="hljs-keyword">return</span>;
&#125;</code></pre></div><p>同步读取第一行内容，当开启了无磁盘化同步时，有一点需要注意，保存完 eofmark 后，要把 <code>repl_transfer_size</code> 变量置为一个非 -1 的值，防止下次事件触发后又进到这个逻辑里来了。而正常同步时，可以读到 <code>repl_transfer_size</code> 的大小。<br>通过 <code>usemark</code> 来标记同步类型，值为 1 表示无磁盘化的同步，值为 0 表示磁盘化同步。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* Read bulk data */</span>
<span class="hljs-keyword">if</span> (usemark) &#123;
    readlen = <span class="hljs-keyword">sizeof</span>(buf);
&#125; <span class="hljs-keyword">else</span> &#123;
    left = server.repl_transfer_size - server.repl_transfer_read;
    readlen = (left &lt; (<span class="hljs-keyword">signed</span>)<span class="hljs-keyword">sizeof</span>(buf)) ? left : (<span class="hljs-keyword">signed</span>)<span class="hljs-keyword">sizeof</span>(buf);
&#125;</code></pre></div><p>以上逻辑来调整每次从 socket 中读取数据的长度，因为 usemark 时，不知道要读取的数据总长度。</p><div class="hljs"><pre><code class="hljs c">nread = read(fd,buf,readlen);
<span class="hljs-keyword">if</span> (nread &lt;= <span class="hljs-number">0</span>) &#123;
    serverLog(LL_WARNING,<span class="hljs-string">&quot;I/O error trying to sync with MASTER: %s&quot;</span>,
              (nread == <span class="hljs-number">-1</span>) ? strerror(errno) : <span class="hljs-string">&quot;connection lost&quot;</span>);
    cancelReplicationHandshake();
    <span class="hljs-keyword">return</span>;
&#125;</code></pre></div><p>计算出 readlen 后，读取数据，如果读错了，要断开连接，清理 fd ，重置同步状态等，<code>cancelReplicationHandshake</code> 的逻辑在上面已经说过。<br>如果是 usemark，那么需要校验 eofmark，以便知道数据是否已经读完。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> eof_reached = <span class="hljs-number">0</span>;

<span class="hljs-keyword">if</span> (usemark) &#123;
    <span class="hljs-comment">/* Update the last bytes array, and check if it matches our delimiter.*/</span>
    <span class="hljs-keyword">if</span> (nread &gt;= CONFIG_RUN_ID_SIZE) &#123;
        <span class="hljs-built_in">memcpy</span>(lastbytes,buf+nread-CONFIG_RUN_ID_SIZE,CONFIG_RUN_ID_SIZE);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">int</span> rem = CONFIG_RUN_ID_SIZE-nread;
        memmove(lastbytes,lastbytes+nread,rem);
        <span class="hljs-built_in">memcpy</span>(lastbytes+rem,buf,nread);
    &#125;
    <span class="hljs-comment">/* 读到 EOF 了 */</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(lastbytes,eofmark,CONFIG_RUN_ID_SIZE) == <span class="hljs-number">0</span>) eof_reached = <span class="hljs-number">1</span>;
&#125;</code></pre></div><p>如果读到的数据长度 &gt;= 40，那么截取 buf 最后 40 个字符。否则使用 <code>memmove</code> 和 <code>memcpy</code> 将最后的 40 个字节填满，这部分操作有点绕，画了个图帮助理解，</p><p><img src="http://ww1.sinaimg.cn/large/71ca8e3cly1g5w95590gbj20h60873z7.jpg" srcset="/img/loading.gif" alt="lastbytes"></p><p>然后根据前面记录 eofmark 去判断是不是数据接收结束了，如果是，<code>eof_reached</code> 置为 1。<br>读完一次数据需要将其写入本地的临时 rdb 文件里，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (write(server.repl_transfer_fd,buf,nread) != nread) &#123;
    serverLog(LL_WARNING,<span class="hljs-string">&quot;Write error or short write writing to the DB dump file needed for MASTER &lt;-&gt; SLAVE synchronization: %s&quot;</span>, strerror(errno));
    <span class="hljs-keyword">goto</span> error;
&#125;
server.repl_transfer_read += nread; <span class="hljs-comment">// 更新读了多少数据量</span></code></pre></div><p>如果是已经读到末尾了，那么需要从文件中删掉 eofmark，因为它不是 rdb 数据嘛，只是个辅助标识。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (usemark &amp;&amp; eof_reached) &#123;
    <span class="hljs-keyword">if</span> (ftruncate(server.repl_transfer_fd,
                  server.repl_transfer_read - CONFIG_RUN_ID_SIZE) == <span class="hljs-number">-1</span>)
    &#123;
        serverLog(LL_WARNING,<span class="hljs-string">&quot;Error truncating the RDB file received from the master for SYNC: %s&quot;</span>, strerror(errno));
        <span class="hljs-keyword">goto</span> error;
    &#125;
&#125;</code></pre></div><p>光是 <code>write</code> 了还不够，这只是写到了系统的 cache，还需要做 <code>fsync</code> 将数据落盘。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (server.repl_transfer_read &gt;=
    server.repl_transfer_last_fsync_off + REPL_MAX_WRITTEN_BEFORE_FSYNC)
&#123;
    <span class="hljs-keyword">off_t</span> sync_size = server.repl_transfer_read -
      server.repl_transfer_last_fsync_off;
    rdb_fsync_range(server.repl_transfer_fd,
                    server.repl_transfer_last_fsync_off, sync_size);
    server.repl_transfer_last_fsync_off += sync_size;
&#125;</code></pre></div><p>刷盘策略是每 8M 一次。<br>如果不是无磁盘化的主从同步，就要依赖于接收到的数据 size 与第一次传过来的值作比较。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!usemark) &#123;
    <span class="hljs-keyword">if</span> (server.repl_transfer_read == server.repl_transfer_size)
        eof_reached = <span class="hljs-number">1</span>;
&#125;</code></pre></div><p>如果完全接收完数据了了，那么需要做一些善后工作，如下代码，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (eof_reached) &#123;....&#125;</code></pre></div><p>首先，把本地 rdb 文件的名字改成配置文件里配置的名字<code>server.rdb_filename</code>。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (rename(server.repl_transfer_tmpfile,server.rdb_filename) == <span class="hljs-number">-1</span>) &#123;
    serverLog(LL_WARNING,<span class="hljs-string">&quot;Failed trying to rename the temp DB into dump.rdb in MASTER &lt;-&gt; SLAVE 				synchronization: %s&quot;</span>, strerror(errno));
    cancelReplicationHandshake();
    <span class="hljs-keyword">return</span>;
&#125;</code></pre></div><p>然后需要为加载新的 rdb 文件做一些准备。</p><div class="hljs"><pre><code class="hljs c">signalFlushedDb(<span class="hljs-number">-1</span>); <span class="hljs-comment">// 使得本实例的所有客户端感知到接下来要清空数据库</span>
emptyDb(replicationEmptyDbCallback); <span class="hljs-comment">// 清空所有数据，给 master 发一个 \n</span></code></pre></div><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">emptyDb</span><span class="hljs-params">(<span class="hljs-keyword">void</span>(callback)(<span class="hljs-keyword">void</span>*))</span> </span>&#123;
    <span class="hljs-keyword">int</span> j;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> removed = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; server.dbnum; j++) &#123;
        removed += dictSize(server.db[j].dict);
        dictEmpty(server.db[j].dict,callback);
        dictEmpty(server.db[j].expires,callback);
    &#125;
    <span class="hljs-keyword">if</span> (server.cluster_enabled) slotToKeyFlush();
    <span class="hljs-keyword">return</span> removed;
&#125;

<span class="hljs-comment">/* Callback used by emptyDb() while flushing away old data to load</span>
<span class="hljs-comment"> * the new dataset received by the master. */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replicationEmptyDbCallback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *privdata)</span> </span>&#123;
    UNUSED(privdata);
    replicationSendNewlineToMaster();
&#125;

<span class="hljs-comment">/* 给 master 发 \n 表明自己还活着，在加载数据 */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replicationSendNewlineToMaster</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">time_t</span> newline_sent;
    <span class="hljs-keyword">if</span> (time(<span class="hljs-literal">NULL</span>) != newline_sent) &#123;
        newline_sent = time(<span class="hljs-literal">NULL</span>);
        <span class="hljs-keyword">if</span> (write(server.repl_transfer_s,<span class="hljs-string">&quot;\n&quot;</span>,<span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>) &#123;
            <span class="hljs-comment">/* Pinging back in this stage is best-effort. */</span>
        &#125;
    &#125;
&#125;</code></pre></div><p>清空老数据完老数据，下面开始加载新数据。</p><div class="hljs"><pre><code class="hljs c">aeDeleteFileEvent(server.el,server.repl_transfer_s,AE_READABLE);
serverLog(LL_NOTICE, <span class="hljs-string">&quot;MASTER &lt;-&gt; SLAVE sync: Loading DB in memory&quot;</span>);
<span class="hljs-keyword">if</span> (rdbLoad(server.rdb_filename) != C_OK) &#123;
    serverLog(LL_WARNING,<span class="hljs-string">&quot;Failed trying to load the MASTER synchronization DB from disk&quot;</span>);
    cancelReplicationHandshake();
    <span class="hljs-keyword">return</span>;
&#125;</code></pre></div><p>在加载新数据之前，需要先删除 socket fd 的可读事件，这是因为在调用 <code>rdbLoad</code> 加载 rdb 数据时，每次调用<code>rioRead</code> 都会因为要计算 checksum 而调用 <code>processEventsWhileBlocked</code> 处理当前已触发的事件，如果不删除该可读事件的话，就会递归进入的本函数中（因此，slave 在加载 rdb 数据时，是不能处理主节点发来的其他数据的）。<br>然后做一些清理工作。</p><div class="hljs"><pre><code class="hljs c">zfree(server.repl_transfer_tmpfile);
close(server.repl_transfer_fd);</code></pre></div><p>根据 socket fd 创建一个 master 的 client。</p><div class="hljs"><pre><code class="hljs c"> <span class="hljs-comment">/* 创建 master 相关的变量 */</span>
replicationCreateMasterClient(server.repl_transfer_s);</code></pre></div><p>然后可以看下这个 <code>replicationCreateMasterClient</code> 这个函数都干了些什么事情。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replicationCreateMasterClient</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span> </span>&#123;
    server.master = createClient(fd);
    server.master-&gt;flags |= CLIENT_MASTER;
    server.master-&gt;authenticated = <span class="hljs-number">1</span>;
    server.repl_state = REPL_STATE_CONNECTED;
    server.master-&gt;reploff = server.repl_master_initial_offset;
    <span class="hljs-built_in">memcpy</span>(server.master-&gt;replrunid, server.repl_master_runid,
        <span class="hljs-keyword">sizeof</span>(server.repl_master_runid));
    <span class="hljs-keyword">if</span> (server.master-&gt;reploff == <span class="hljs-number">-1</span>)
        server.master-&gt;flags |= CLIENT_PRE_PSYNC;
&#125;</code></pre></div><p>需要注意一点，如果 master 不支持 PSYNC 的话，那么 salve 不会得到 <code>+FULLRESYNC</code> 的回复，也就不会更新 <code>server.repl_master_initial_offset</code> 变量，它就一直是 -1，在这里创建 master client 时，会给它一个标记 <strong>CLIENT_PRE_PSYNC</strong>。</p><p>这里会把状态机更新为 <strong>REPL_STATE_CONNECTED</strong>。<br>最后，如果 aof 功能没有关闭的话，需要重新生成 aof 文件，因为数据已经改变了。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (server.aof_state != AOF_OFF) &#123;
    <span class="hljs-keyword">int</span> retry = <span class="hljs-number">10</span>;

    stopAppendOnly();
    <span class="hljs-keyword">while</span> (retry-- &amp;&amp; startAppendOnly() == C_ERR) &#123;
        serverLog(LL_WARNING,<span class="hljs-string">&quot;Failed enabling the AOF after successful master synchronization! 							Trying it again in one second.&quot;</span>);
        sleep(<span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-keyword">if</span> (!retry) &#123;
        serverLog(LL_WARNING,<span class="hljs-string">&quot;FATAL: this slave instance finished the synchronization with its 							master, but the AOF can&#x27;t be turned on. Exiting now.&quot;</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    &#125;
&#125;</code></pre></div><p>到这里，<code>readSyncBulkPayload</code> 函数读取并加载新 rdb 文件的流程就走完了。</p><p>当复制状态变为 <strong>REPL_STATE_CONNECTED</strong> 后，表示进入了命令传播阶段。后续 slave 将 master 当成一个客户端，并接收其发来的命令请求，像处理普通客户端一样处理即可。命令传播在前面的博客已经详细讲过。</p><h3 id="探活机制">探活机制</h3><p>在 master-slave 连接建立以后，他们就通过心跳进行相互探活，这些机制都在 <code>replicationCron</code> 函数里。</p><h4 id="master- 探活">master 探活</h4><p>master 会定期给它所有的 slave 发送 PING。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((replication_cron_loops % server.repl_ping_slave_period) == <span class="hljs-number">0</span>) &#123;
    ping_argv[<span class="hljs-number">0</span>] = createStringObject(<span class="hljs-string">&quot;PING&quot;</span>,<span class="hljs-number">4</span>);
    replicationFeedSlaves(server.slaves, server.slaveseldb,
                          ping_argv, <span class="hljs-number">1</span>);
    decrRefCount(ping_argv[<span class="hljs-number">0</span>]);
&#125;</code></pre></div><p>给 slave 发送命令是通过 <code>replicationFeedSlaves</code> 函数实现的。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replicationFeedSlaves</span><span class="hljs-params">(<span class="hljs-built_in">list</span> *slaves, <span class="hljs-keyword">int</span> dictid, robj **argv, <span class="hljs-keyword">int</span> argc)</span> </span>&#123;....&#125;</code></pre></div><p>下面看一下该函数的详细实现。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (server.repl_backlog == <span class="hljs-literal">NULL</span> &amp;&amp; listLength(slaves) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;</code></pre></div><p>如果 <code>repl_backlog</code> 为空，或者是没有 slave，那么这个过程是不必要的，直接返回。必要的时候生成 SELECT 命令，告知 slave 切换数据库。<code>slaveseldb</code> 中保存的是上一次 replication 输出时选择的数据库。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (server.repl_backlog) &#123;
    <span class="hljs-keyword">char</span> aux[LONG_STR_SIZE+<span class="hljs-number">3</span>];

    <span class="hljs-comment">/* Add the multi bulk reply length. */</span>
    aux[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;*&#x27;</span>;
    len = ll2string(aux+<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(aux)<span class="hljs-number">-1</span>,argc);
    aux[len+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\r&#x27;</span>;
    aux[len+<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\n&#x27;</span>;
    feedReplicationBacklog(aux,len+<span class="hljs-number">3</span>);

    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; argc; j++) &#123;
        <span class="hljs-keyword">long</span> objlen = stringObjectLen(argv[j]);
        aux[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;$&#x27;</span>;
        len = ll2string(aux+<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(aux)<span class="hljs-number">-1</span>,objlen);
        aux[len+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\r&#x27;</span>;
        aux[len+<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\n&#x27;</span>;
        feedReplicationBacklog(aux,len+<span class="hljs-number">3</span>);
        feedReplicationBacklogWithObject(argv[j]);
        feedReplicationBacklog(aux+len+<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
    &#125;
&#125;</code></pre></div><p>如果 <code>repl_backlog</code> 不为空，那么组装 redis 协议的命令，这里是 <code>*1\r\n$4\r\nPING</code>，放到 <code>repl_backlog</code> 变量里。</p><h4 id="slave- 探活">slave 探活</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replicationCron</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    ...
    <span class="hljs-keyword">if</span> (server.masterhost &amp;&amp; server.master &amp;&amp;
          !(server.master-&gt;flags &amp; CLIENT_PRE_PSYNC)) &#123;
      	replicationSendAck();
    &#125;
    ...
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replicationSendAck</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    client *c = server.master;

    <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">NULL</span>) &#123;
        c-&gt;flags |= CLIENT_MASTER_FORCE_REPLY;
        addReplyMultiBulkLen(c,<span class="hljs-number">3</span>);
        addReplyBulkCString(c,<span class="hljs-string">&quot;REPLCONF&quot;</span>);
        addReplyBulkCString(c,<span class="hljs-string">&quot;ACK&quot;</span>);
        addReplyBulkLongLong(c,c-&gt;reploff);
        c-&gt;flags &amp;= ~CLIENT_MASTER_FORCE_REPLY;
    &#125;
&#125;</code></pre></div><p>对于非老版本的 master，slave 向它定期发送 <code>REPLCONF ACK &lt;offset&gt;</code> 命令，以便告诉它复制偏移量。</p><h2 id="cluster- 模式">cluster 模式</h2><p>cluster 模式下，使用 <code>CLUSTER REPLICATE &lt;NODE ID&gt;</code> 命令来进行新的主从关系的构建。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clusterCommand</span><span class="hljs-params">(client *c)</span> </span>&#123;
    ...
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="hljs-number">1</span>]-&gt;ptr,<span class="hljs-string">&quot;replicate&quot;</span>) &amp;&amp; c-&gt;argc == <span class="hljs-number">3</span>) &#123;
        <span class="hljs-comment">/* CLUSTER REPLICATE &lt;NODE ID&gt; */</span>
        clusterNode *n = clusterLookupNode(c-&gt;argv[<span class="hljs-number">2</span>]-&gt;ptr);

        <span class="hljs-comment">/* Lookup the specified node in our table. */</span>
        <span class="hljs-keyword">if</span> (!n) &#123;
            addReplyErrorFormat(c,<span class="hljs-string">&quot;Unknown node %s&quot;</span>, (<span class="hljs-keyword">char</span>*)c-&gt;argv[<span class="hljs-number">2</span>]-&gt;ptr);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-comment">/* I can&#x27;t replicate myself. */</span>
        <span class="hljs-keyword">if</span> (n == myself) &#123;
            addReplyError(c,<span class="hljs-string">&quot;Can&#x27;t replicate myself&quot;</span>);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-comment">/* Can&#x27;t replicate a slave. */</span>
        <span class="hljs-keyword">if</span> (nodeIsSlave(n)) &#123;
            addReplyError(c,<span class="hljs-string">&quot;I can only replicate a master, not a slave.&quot;</span>);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-comment">// 我要做别人的 slave， 那么不是不能够有 slots 和数据库数据的</span>
        <span class="hljs-keyword">if</span> (nodeIsMaster(myself) &amp;&amp;
            (myself-&gt;numslots != <span class="hljs-number">0</span> || dictSize(server.db[<span class="hljs-number">0</span>].dict) != <span class="hljs-number">0</span>)) &#123;
            addReplyError(c,
                <span class="hljs-string">&quot;To set a master the node must be empty and &quot;</span>
                <span class="hljs-string">&quot;without assigned slots.&quot;</span>);
            <span class="hljs-keyword">return</span>;
        &#125;

        <span class="hljs-comment">/* Set the master. */</span>
        clusterSetMaster(n);
        clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
        addReply(c,shared.ok);
    &#125;
    .....
&#125;</code></pre></div><p><strong>很重要的一个检查 </strong>是，有 slot 或者有数据的 master 节点，不能做此操作，防止丢数据。<br>跳过一些合理性检查，重点函数就是 <code>clusterSetMaster</code> 了，那么它做了什么呢？</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clusterSetMaster</span><span class="hljs-params">(clusterNode *n)</span> </span>&#123;
    serverAssert(n != myself);
    serverAssert(myself-&gt;numslots == <span class="hljs-number">0</span>);

    <span class="hljs-keyword">if</span> (nodeIsMaster(myself)) &#123;
        myself-&gt;flags &amp;= ~(CLUSTER_NODE_MASTER|CLUSTER_NODE_MIGRATE_TO);
        myself-&gt;flags |= CLUSTER_NODE_SLAVE;
        clusterCloseAllSlots();
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">if</span> (myself-&gt;slaveof)
            clusterNodeRemoveSlave(myself-&gt;slaveof,myself); <span class="hljs-comment">// 解除原有的主从关系</span>
    &#125;
    myself-&gt;slaveof = n;
    clusterNodeAddSlave(n,myself);
    replicationSetMaster(n-&gt;ip, n-&gt;port);
    resetManualFailover();
&#125;</code></pre></div><p>首先，如果本身是个 master，那么取消掉 master 和 migrating 的 flag，因为该 master 没有数据，可以大胆地取消迁移的叫标记，然后加上 slave 的标记 <strong>CLUSTER_NODE_SLAVE</strong>。<br>如果原本就是个 slave 节点，那么调整自己的主从归属信息，置空以手动主从切换有关的变量值，关于 cluster mf 的逻辑以后会专门去讨论。<br>然后就是前面说过的 <code>replicationSetMaster</code> 函数，触发上也是在 cron 里，就不啰嗦了。</p><p>以上，主从复制中，slave 的逻辑就介绍完了。</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/redis/">redis</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext row"><article class="post-prev col-6"><a href="/9025979a.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Redis 源码之主从复制 (4)</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/8f9133db.html"><span class="hidden-mobile">Redis 源码之主从复制 (2)</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script type="text/javascript">function loadLivere(){addScript("https://cdn-city.livere.com/js/embed.dist.js")}waitElementVisible("lv-container",loadLivere)</script><noscript>为正常使用来必力评论功能请允许 JavaScript 运行</noscript></div></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:3,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","Redis 源码之主从复制 (3)&nbsp;"],cursorChar:"|",typeSpeed:72,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "§"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>