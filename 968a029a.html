<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/dolphin.png"><link rel="icon" type="image/png" href="/images/dolphin.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="Happen"><meta name="keywords" content=""><title>Redis 源码之主从复制 (3) - Happen&#39;s Memo</title><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css"><link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"><link rel="stylesheet" href="/css/main.css"><link defer="defer" rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="/css/custom.css"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"> <a class="navbar-brand" href="/">&nbsp;<strong>Happen's Memo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="fa fa-home" aria-hidden="true"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="fa fa-archive" aria-hidden="true"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="fa fa-map-signs" aria-hidden="true"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="fa fa-tags" aria-hidden="true"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="fa fa-child" aria-hidden="true"></i> 关于</a></li><li class="nav-item" id="search-btn"> <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" parallax="true" style="background:url(/images/about-banner.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask rgba-black-light flex-center"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><p class="mt-3 post-meta"><i class="fas fa-calendar-alt" aria-hidden="true"></i> 2019/09/05, 星期四, 00:20</p><p class="mt-1"><span class="post-meta"><i class="far fa-chart-bar"></i> 7.3k 字</span><span class="post-meta"><i class="far fa-clock"></i> 33 分钟</span><span id="busuanzi_container_page_pv" class="post-meta" style="display:none"><i class="far fa-eye" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span> 次</span></p></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5 z-depth-3" id="board"><div class="post-content mx-auto" id="post"><p class="note note-warning">本文最后更新于：2020/04/03, 星期五, 01:46</p><div class="markdown-body"><p>redis 代码中主从复制流程的核心部分在于 <strong>状态机的流转</strong>。</p><a id="more"></a><p>单机模式下以 <strong>SLAVEOF</strong> 命令触发；<br> cluster 模式下以 <strong>REPLICATE</strong> 命令触发，且 cluster 模式下不支持 <strong>SLAVEOF</strong> 命令。</p><p>在该过程中，master 与 slave 各有不同的流转逻辑，交互频繁，本文以下内容试图介绍 slave 的处理逻辑, 以下流程图可以辅助理解。<br> <img src="https://s2.ax1x.com/2019/09/09/nGjlXd.png" srcset="/img/loading.gif" alt="nGjlXd.png"></p><p>代码中在 <code>redisServer</code> 结构体里定义的很多 <strong>repl</strong> 前缀的变量都用于此过程，如<code>repl_transfer_fd</code>。<br> 各变量的作用在源码注释里已经写得非常详细了，不做赘述。</p><h2 id="单机模式下的主从复制">单机模式下的主从复制</h2><p>redis 实例以单机模式启动，即在 <span id="inline-blue">redis.conf</span> 中配置 <strong>cluster-enabled no</strong>。</p><h3 id="触发方式">触发方式</h3><p>有以下三种方式可触发主从复制流程。<br> ① <span id="inline-blue">redis.conf</span> 中配置 <code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>；<br> ② redis-server 命令启动服务时指定参数 <code>--slaveof [masterip] [masterport]</code>；<br> ③ 对一个实例执行 <code>slaveof [masterip] [masterport]</code> 命令。</p><p>①② 逻辑相似，直接标记 <code>server.repl_state</code> 为 <strong>REPL_STATE_CONNECT</strong> 状态，以 ① 为例简要说明，加载配置文件时有如下逻辑，</p><pre><code class="language-c">void loadServerConfigFromString(char *config) {
    ....
    else if (!strcasecmp(argv[0],&quot;slaveof&quot;) &amp;&amp; argc == 3) {
        slaveof_linenum = linenum;
        server.masterhost = sdsnew(argv[1]);
        server.masterport = atoi(argv[2]);
        server.repl_state = REPL_STATE_CONNECT;
    }
....
}
</code></pre><p>而 ③ 在标记 <code>REPL_STATE_CONNECT</code> 状态前需要做一些检查。<br> 首先，检查实例是否开启了 cluster 模式，如果开启了，那么直接返回，不支持这个命令。<br> 接着，通过检查 <code>slaveof</code> 命令后面的参数来判断使用的是哪个命令，代码如下，</p><pre><code class="language-c">void slaveofCommand(client *c) {
    /* cluster 模式开启后，禁用 slaveof 命令 */
    if (server.cluster_enabled) {addReplyError(c,&quot;SLAVEOF not allowed in cluster mode.&quot;);
        return;
    }

   // SLAVEOF NO ONE
    if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;no&quot;) &amp;&amp;
        !strcasecmp(c-&gt;argv[2]-&gt;ptr,&quot;one&quot;)) {if (server.masterhost) { // 如果之前有 master
            replicationUnsetMaster();
            sds client = catClientInfoString(sdsempty(),c);
            serverLog(LL_NOTICE,&quot;MASTER MODE enabled (user request from '%s')&quot;, client);
            sdsfree(client);
        }
    } else {
        long port;
        // 从参数中获得 port
        if ((getLongFromObjectOrReply(c, c-&gt;argv[2], &amp;port, NULL) != C_OK))
            return;
        // 如果现在的 master 已经是要设置的，那么就不必再做操作了，直接返回吧
        if (server.masterhost &amp;&amp; !strcasecmp(server.masterhost,c-&gt;argv[1]-&gt;ptr)
            &amp;&amp; server.masterport == port) {serverLog(LL_NOTICE,&quot;SLAVE OF would result into synchronization with the master we are already connected with. No operation performed.&quot;);
            addReplySds(c,sdsnew(&quot;+OK Already connected to specified master\r\n&quot;));
            return;
        }
        replicationSetMaster(c-&gt;argv[1]-&gt;ptr, port);
        sds client = catClientInfoString(sdsempty(),c);
        serverLog(LL_NOTICE,&quot;SLAVE OF %s:%d enabled (user request from '%s')&quot;,
            server.masterhost, server.masterport, client);
        sdsfree(client);
    }
    addReply(c,shared.ok);
}
</code></pre><h4 id="SLAVEOF-NO-ONE- 命令">SLAVEOF NO ONE 命令</h4><p>该命令会取消现有的主从关系，使 slave 变为 master，主要函数如下，</p><pre><code class="language-c">void replicationUnsetMaster(void) {
    // 已经是 master 了，无需继续操作
    if (server.masterhost == NULL) return;

    sdsfree(server.masterhost);
    server.masterhost = NULL;

    if (server.master) {if (listLength(server.slaves) == 0) {
            // 继承 master 的 repl offset
            server.master_repl_offset = server.master-&gt;reploff;
            freeReplicationBacklog();}
        freeClient(server.master);
    }
    replicationDiscardCachedMaster();
    cancelReplicationHandshake();
    server.repl_state = REPL_STATE_NONE;
}
</code></pre><p>这里主要涉及到一些与 master 相关的变量的内存释放。<br> 如果该实例有 master，且不是其他实例的 master，即 <code>listLength(server.slaves) == 0</code>，也就是说未形成链式结构，那么记录下原 master 的 replication offset。在某些特定条件下，副本的数据新鲜度可以通过 replication offset 来比较，有时由于网络等原因暂时断开了，隔了一段时间又重新连上原 master，有了这个偏移量可以减少做完全重同步的可能性(我是这么理解的)。<br> <strong>freeClient</strong> 函数会释放掉原来的 master，做一些内存释放，一些标志位重置等。</p><p>接下来的 <code>replicationDiscardCachedMaster</code> 函数中会释放掉 <code>server.cached_master</code>，因为这里缓存以前的 mater 已经没用了，不知道下次要连的是哪个 master，或者自己以后成为一个 master，避免不必要的内存浪费。</p><p><code>cancelReplicationHandshake</code> 函数则会取消一个正在进行尝试 handshake 的主从复制过程。<br> 最后重置状态机为 <strong>REPL_STATE_NONE</strong>。</p><h4 id="SLAVEOF-host-port- 命令">SLAVEOF host port 命令</h4><p>通过执行该命令，可以将当前实例变成某个实例的 slave。<br> 如果指定的主从关系已经存在，那本次命令没必要继续执行了，直接返回；否则，通过 <code>replicationSetMaster</code> 函数设置新的主从关系，代码如下，</p><pre><code class="language-c">void replicationSetMaster(char *ip, int port) {sdsfree(server.masterhost);
    server.masterhost = sdsnew(ip);
    server.masterport = port;
    // 如果原来有 master 了，需要释放掉
    if (server.master) freeClient(server.master);
    disconnectAllBlockedClients();

    // 释放掉所有的 slave，让它们重新连
    disconnectSlaves();
    replicationDiscardCachedMaster();
    freeReplicationBacklog();

    cancelReplicationHandshake();
    server.repl_state = REPL_STATE_CONNECT;
    server.master_repl_offset = 0;
    server.repl_down_since = 0;
}
</code></pre><p>在以上函数中，<br> 先保存下要连接的 ip 和 port，方便后面进行建立网络连接。<br> 如果，该节点之前有 master 了，那么需要释放掉原来的 master，跟上面一节的逻辑类似，前面详细说过了。<br> <strong>disconnectAllBlockedClients</strong> 函数会 unlock 已经 lock 在这个实例上的 client，并返回 <strong>-UNBLOCKED</strong> 开头的错误。这是因为该实例已经改变了角色，block 已经没什么意义。比如当一个实例从 master 变为 slave，那么由于 list 选项而阻塞在该实例上的 client 就不安全了，<strong>因为数据随着从新的 slave 同步数据，该实例的数据集可能会发生变化</strong>。<br> <strong>disconnectSlaves</strong> 函数释放掉所有的 slave，重新同步新的数据。<br> 释放掉 <code>server.cached_master</code>，同样因为数据集变化了，cache 的数据并不能用了。<br> 释放掉 <code>server.repl_backlog</code>，理由同上。<br> <code>cancelReplicationHandshake</code> 函数在上面讲过了。<br> 将 <code>server.repl_state</code> 置为 <strong>REPL_STATE_CONNECT</strong> 状态，复制偏离量归零等。<br> 最后返回 OK，也就是这个命令的返回值<code>+OK\r\n</code>。</p><h3 id="主从建立连接">主从建立连接</h3><p>redis 中有很多 cron 任务，其中就有一个负责 replication 的，即每秒执行一次的 <strong>replicationCron</strong> 函数。</p><pre><code class="language-c"> run_with_period(1000) replicationCron();
</code></pre><p>在上一步中，状态机已经流转到 <strong>REPL_STATE_CONNECT</strong> 状态，这里直接就进入到主从建连的逻辑。</p><pre><code class="language-c">void replicationCron(void) {
	......
    // 开始一段新的主从关系
    if (server.repl_state == REPL_STATE_CONNECT) {
        serverLog(LL_NOTICE,&quot;Connecting to MASTER %s:%d&quot;,
            server.masterhost, server.masterport);
        if (connectWithMaster() == C_OK) {serverLog(LL_NOTICE,&quot;MASTER &lt;-&gt; SLAVE sync started&quot;);
        }
    }
  ......
}
</code></pre><p>使用 <code>server.masterhost</code> 和 <code>server.masterport</code> 向 master 发起 connect 请求， fd 设置为 <strong>非阻塞</strong>。成功后，为 fd 的读写事件注册 <code>syncWithMaster</code> 回调函数，用于处理 master 与 slave 之间的 handshake 过程。这部分逻辑在 <strong>connectWithMaster</strong> 函数中实现，代码如下，</p><pre><code class="language-c">int connectWithMaster(void) {
    int fd;

    // 连接 master，获得 fd
    fd = anetTcpNonBlockBestEffortBindConnect(NULL, server.masterhost,server.masterport,NET_FIRST_BIND_ADDR);
    if (fd == -1) {
        serverLog(LL_WARNING,&quot;Unable to connect to MASTER: %s&quot;,
            strerror(errno));
        return C_ERR;
    }
    // 为 fd 设置读写事件回调 syncWithMaster
    if (aeCreateFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE,syncWithMaster,NULL) == AE_ERR)
    {close(fd);
        serverLog(LL_WARNING,&quot;Can't create readable event for SYNC&quot;);
        return C_ERR;
    }

    server.repl_transfer_lastio = server.unixtime;
    server.repl_transfer_s = fd;

    // 状态机更新
    server.repl_state = REPL_STATE_CONNECTING;
    return C_OK;
}
</code></pre><p><code>server.repl_transfer_lastio</code> 用于记录上一次 fd 读事件的时刻，<code>server.repl_transfer_s</code> 记录主从复制使用到的 socket fd。</p><p>更新状态机为 <strong>REPL_STATE_CONNECTING</strong>。</p><h3 id="主从 -handshake- 过程">主从 handshake 过程</h3><h4 id="发送 -ping">发送 ping</h4><p>主从建连成功后，通过 fd 的读写事件触发 <code>syncWithMaster</code> 回调函数。</p><p>如果该事件在用户把本实例用 <strong>SLAVEOF NO ONE</strong> 变成 master 后出触发，那么没有执行下去的必要，判断逻辑如下，</p><pre><code class="language-c">if (server.repl_state == REPL_STATE_NONE) {close(fd);
    return;
}
</code></pre><p>下面是同步发送 PING 的代码逻辑，更新状态机为 <strong>REPL_STATE_RECEIVE_PONG</strong>。</p><pre><code class="language-c">if (server.repl_state == REPL_STATE_CONNECTING) {serverLog(LL_NOTICE,&quot;Non blocking connect for SYNC fired the event.&quot;);

    /* 为了等待 pong 的返回，删除 fd 上的可写事件，但保留可读事件 */
    aeDeleteFileEvent(server.el,fd,AE_WRITABLE);
    server.repl_state = REPL_STATE_RECEIVE_PONG;

    /* 同步发送 ping，这里不检查是否 err，因为已经有超时限制做保证 */
    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;PING&quot;,NULL);
    if (err) goto write_error;
    return;
}
</code></pre><p><code>sendSynchronousCommand</code> 函数通过 flag 标识读写命令，此处写命令标识为 <strong>SYNC_CMD_WRITE</strong>。</p><h4 id="验证 -AUTH">验证 AUTH</h4><p>使用 <strong>sendSynchronousCommand</strong> 函数同步读取 master 对 PING 的回复。</p><pre><code class="language-c">if (server.repl_state == REPL_STATE_RECEIVE_PONG) {
    /* 读取上面发送的 ping 命令的 response */
    err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
    if (err[0] != '+' &amp;&amp; strncmp(err,&quot;-NOAUTH&quot;,7) != 0 &amp;&amp;
        strncmp(err,&quot;-ERR operation not permitted&quot;,28) != 0)
    {serverLog(LL_WARNING,&quot;Error reply to PING from master: '%s'&quot;,err);
        sdsfree(err);
        goto error;
    } else {
        serverLog(LL_NOTICE,
          &quot;Master replied to PING, replication can continue...&quot;);
    }
    sdsfree(err);
    server.repl_state = REPL_STATE_SEND_AUTH;
}
</code></pre><p>回复只可能有 3 种情况：<strong>+PONG</strong>，<strong>-NOAUTH</strong> 和 <strong>-ERR operation not permitted</strong>（老版本的 redis 主节点）。如果不是，直接进入错误处理代码流程。</p><p><strong>注意</strong>：这里的读操作会更新变量 <code>server.repl_transfer_lastio</code>。</p><p>调整状态机为 <strong>REDIS_REPL_SEND_AUTH</strong>。这里没有 <code>return</code>，直接往下执行，进入鉴权的逻辑，</p><pre><code class="language-c">if (server.repl_state == REPL_STATE_SEND_AUTH) {if (server.masterauth) {err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;AUTH&quot;,server.masterauth,NULL);
        if (err) goto write_error;
        server.repl_state = REPL_STATE_RECEIVE_AUTH;
        return;
    } else {server.repl_state = REPL_STATE_SEND_PORT;}
}
</code></pre><p>如果配置文件中没有设置 <strong>masterauth</strong> 选项，那么状态机置为 <strong>REPL_STATE_SEND_PORT</strong>。<br> 否则，需要发送 <code>AUTH</code> 命令鉴权。状态机置为 <strong>REPL_STATE_RECEIVE_AUTH</strong>。</p><pre><code class="language-c">/* Receive AUTH reply. */
if (server.repl_state == REPL_STATE_RECEIVE_AUTH) {err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
    if (err[0] == '-') {serverLog(LL_WARNING,&quot;Unable to AUTH to MASTER: %s&quot;,err);
        sdsfree(err);
        goto error;
    }
    sdsfree(err);
    server.repl_state = REPL_STATE_SEND_PORT;
}
</code></pre><p>验证 auth 通过后，状态机置为 <strong>REPL_STATE_SEND_PORT</strong>，否则，直接跳到的 err 处理流程。</p><h4 id="发送 -REPLCONF- 命令">发送 REPLCONF 命令</h4><p>slave 将发送一连串的 <code>REPLCONF</code> 命令，以告知 master 自己的一些信息。<br> <code>slave-announce-ip</code> 和 <code>slave-announce-port</code> 主要是针对转发或者 NAT 场景下，master 无法通过 socket 连接获得对端信息时使用。</p><p>首先发送自己的 port 信息，<code>REPLCONF listening-port &lt;port&gt;</code>，状态机置为 <strong>REPL_STATE_RECEIVE_PORT</strong>，返回，等下一次事件触发。<br> 接着，同步读取 master 的回复，即使返回错误也没有关系，状态机置为 <strong>REPL_STATE_SEND_IP</strong>。<br> 代码如下，</p><pre><code class="language-c">/* Set the slave port, so that Master's INFO command can list the
 * slave listening port correctly. */
if (server.repl_state == REPL_STATE_SEND_PORT) {
    sds port = sdsfromlonglong(server.slave_announce_port ?
                               server.slave_announce_port : server.port);
    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,
                                 &quot;listening-port&quot;,port, NULL);
    sdsfree(port);
    if (err) goto write_error;
    sdsfree(err);
    server.repl_state = REPL_STATE_RECEIVE_PORT;
    return;
}

if (server.repl_state == REPL_STATE_RECEIVE_PORT) {err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
    if (err[0] == '-') {serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand &quot;
                &quot;REPLCONF listening-port: %s&quot;, err);
    }
    sdsfree(err);
    server.repl_state = REPL_STATE_SEND_IP;
</code></pre><p>如果没有配置 <code>slave-announce-ip</code> 时，直接将状态机调跳转到 <strong>REPL_STATE_SEND_CAPA</strong>，跳过发送 REPLCONF ip-address 的步骤。</p><pre><code class="language-c">if (server.repl_state == REPL_STATE_SEND_IP &amp;&amp;
    server.slave_announce_ip == NULL)
{server.repl_state = REPL_STATE_SEND_CAPA;}
</code></pre><p>发送 REPLCONF ip-address，接收回复，将状态机置为 <strong>REPL_STATE_SEND_CAPA</strong>。</p><pre><code class="language-c">/* REPLCONF ip-address &lt;ip&gt;  */
if (server.repl_state == REPL_STATE_SEND_IP) {
    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,
                                 &quot;ip-address&quot;,server.slave_announce_ip, NULL);
    if (err) goto write_error;
    sdsfree(err);
    server.repl_state = REPL_STATE_RECEIVE_IP;
    return;
}

/* Receive REPLCONF ip-address reply. */
if (server.repl_state == REPL_STATE_RECEIVE_IP) {err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
    if (err[0] == '-') {serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand &quot;
                &quot;REPLCONF ip-address: %s&quot;, err);
    }
    sdsfree(err);
    server.repl_state = REPL_STATE_SEND_CAPA;
}
</code></pre><p>状态机置为 <strong>REPL_STATE_SEND_CAPA</strong>，告知 master 自己的能力，现在只有 eof，表示支持无磁盘化主从复制，以后可能会有更多，格式为 <code>REPLCONF capa X capa Y capa Z ...</code>。</p><pre><code class="language-c">if (server.repl_state == REPL_STATE_SEND_CAPA) {
    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,
                                 &quot;capa&quot;,&quot;eof&quot;,NULL);
    if (err) goto write_error;
    sdsfree(err);
    server.repl_state = REPL_STATE_RECEIVE_CAPA;
    return;
}
if (server.repl_state == REPL_STATE_RECEIVE_CAPA) {err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
    /* Ignore the error if any, not all the Redis versions support
           * REPLCONF capa. */
    if (err[0] == '-') {serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand &quot;
                &quot;REPLCONF capa: %s&quot;, err);
    }
    sdsfree(err);
    server.repl_state = REPL_STATE_SEND_PSYNC;
}

</code></pre><p>状态机置为 <strong>REPL_STATE_SEND_PSYNC</strong>。</p><h4 id="尝试做部分重同步">尝试做部分重同步</h4><p>为解决旧版本 redis 在处理断线情况下完全复制的低效问题， 从 2.8 版本开始，使用 PSYNC 命令代替 SYNC 命令来执行复制时的同步操作，这个点在前面的博客讲过了。</p><p>为高效起见，首先尝试做部分重同步，试探逻辑在函数 <strong>slaveTryPartialResynchronization</strong> 中。</p><pre><code class="language-c">if (server.repl_state == REPL_STATE_SEND_PSYNC) {if (slaveTryPartialResynchronization(fd,0) == PSYNC_WRITE_ERROR) {err = sdsnew(&quot;Write error sending the PSYNC command.&quot;);
        goto write_error;
    }
    server.repl_state = REPL_STATE_RECEIVE_PSYNC;
    return;
}
</code></pre><p><strong>slaveTryPartialResynchronization</strong> 里包含了读写两部分，其中写的部分在上半部，当第二个参数为 0 时，发送 PSYNC 命令，命令格式为 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code>。<br> 发送 PSYNC 时，分两种情况，首次连接或非首次连接。首次连接时，runid 未知，用 <code>?</code> 代替，offset 置为初始值 -1。<br> 代码逻辑如下，</p><pre><code class="language-c">if (!read_reply) {
	server.repl_master_initial_offset = -1;

    if (server.cached_master) { // 重连
        psync_runid = server.cached_master-&gt;replrunid;
        snprintf(psync_offset,sizeof(psync_offset),&quot;%lld&quot;, server.cached_master-&gt;reploff+1);
        serverLog(LL_NOTICE,&quot;Trying a partial resynchronization (request %s:%s).&quot;, psync_runid, psync_offset);
    } else { // 首次连接 master
        serverLog(LL_NOTICE,&quot;Partial resynchronization not possible (no cached master)&quot;);
        psync_runid = &quot;?&quot;;
        memcpy(psync_offset,&quot;-1&quot;,3); /* psync ? -1 */
    }

    reply = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;PSYNC&quot;,psync_runid,psync_offset,NULL);
    if (reply != NULL) {serverLog(LL_WARNING,&quot;Unable to send PSYNC to master: %s&quot;,reply);
        sdsfree(reply);
        /* 发送出错了，需要删掉 fd 上的可读事件 */
        aeDeleteFileEvent(server.el,fd,AE_READABLE);
        return PSYNC_WRITE_ERROR;
    }
    return PSYNC_WAIT_REPLY;
}
</code></pre><p>发送出错后，需要删掉 fd 上的可读事件。<br> 回到 <strong>syncWithMaster</strong> 函数中，状态机置为 <strong>REPL_STATE_RECEIVE_PSYNC</strong>。</p><p>代码逻辑走到这一步，如果状态机的状态不是 <strong>REPL_STATE_RECEIVE_PSYNC</strong>，一定是哪里出错了，进入错误处理流程，即，</p><pre><code class="language-c">/* If reached this point, we should be in REPL_STATE_RECEIVE_PSYNC. */
if (server.repl_state != REPL_STATE_RECEIVE_PSYNC) {serverLog(LL_WARNING,&quot;syncWithMaster(): state machine error, &quot;
        &quot;state should be RECEIVE_PSYNC but is %d&quot;, server.repl_state);
    goto error;
}
</code></pre><p>接着去读取 master 的给的回复信息，</p><pre><code class="language-c">psync_result = slaveTryPartialResynchronization(fd,1);
</code></pre><p>可能会读到三种，<code>+FULLRESYNC</code>、<code>+CONTINUE</code>以及<code>-ERR</code>。</p><pre><code class="language-c">reply = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
if (sdslen(reply) == 0) {
  // 为了保活，master 可能在收到 PSYNC 后且回复前发送空行
  sdsfree(reply);
  return PSYNC_WAIT_REPLY;
}
/* 删除 fd 可读事件，方便后面为 f'd 重新注册新的回调 */
aeDeleteFileEvent(server.el,fd,AE_READABLE);
</code></pre><p>【1】<code>+FULLRESYNC</code> 回复表示不能进行部分重同步，slave 告诉给 master 的 offset 不在 master 的复制积压缓冲区范围内，只能进行完全重同步，返回给上层函数 <strong>PSYNC_FULLRESYNC</strong>，代码如下，</p><pre><code class="language-c">/* 完全重同步得到 response 为 +FULLRESYNC &lt;master_runid&gt; &lt;offset&gt; */
if (!strncmp(reply,&quot;+FULLRESYNC&quot;,11)) {
    char *runid = NULL, *offset = NULL;
    runid = strchr(reply,' ');
    if (runid) {
        runid++;
        offset = strchr(runid,' ');
        if (offset) offset++;
    }
    /* 有可能是 master 发送格式有问题，先把 repl_master_runid 置空 */
    if (!runid || !offset || (offset-runid-1) != CONFIG_RUN_ID_SIZE) {
        serverLog(LL_WARNING,
                  &quot;Master replied with wrong +FULLRESYNC syntax.&quot;);
        memset(server.repl_master_runid,0,CONFIG_RUN_ID_SIZE+1);
    } else {memcpy(server.repl_master_runid, runid, offset-runid-1);
        server.repl_master_runid[CONFIG_RUN_ID_SIZE] = '\0';
        server.repl_master_initial_offset = strtoll(offset,NULL,10);
        serverLog(LL_NOTICE,&quot;Full resync from master: %s:%lld&quot;,
                  server.repl_master_runid,
                  server.repl_master_initial_offset);
    }
    /* We are going to full resync, discard the cached master structure. */
    replicationDiscardCachedMaster();
    sdsfree(reply);
    return PSYNC_FULLRESYNC;
}
</code></pre><p>以上代码解析出 master 的 runid，以及 offset，分别赋值给 <code>repl_master_runid</code> 和 <code>repl_master_initial_offset</code>。因为要进行全同步，<code>cached_master</code> 保存的信息就失效了，需要重置，即函数 <code>replicationDiscardCachedMaster</code> 的调用。</p><p>【2】<code>+CONTINUE</code> 表示可以进行部分重同步，返回给上层函数 <strong>PSYNC_CONTINUE</strong>。</p><pre><code class="language-c">if (!strncmp(reply,&quot;+CONTINUE&quot;,9)) {
    serverLog(LL_NOTICE,
              &quot;Successful partial resynchronization with master.&quot;);
    sdsfree(reply);
    replicationResurrectCachedMaster(fd);
    return PSYNC_CONTINUE;
}
</code></pre><pre><code class="language-c">void replicationResurrectCachedMaster(int newfd) {
    server.master = server.cached_master;
    server.cached_master = NULL;
    server.master-&gt;fd = newfd;
    server.master-&gt;flags &amp;= ~(CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP);
    server.master-&gt;authenticated = 1;
    server.master-&gt;lastinteraction = server.unixtime;
    server.repl_state = REPL_STATE_CONNECTED;

    /* Re-add to the list of clients. */
    listAddNodeTail(server.clients,server.master);
    if (aeCreateFileEvent(server.el, newfd, AE_READABLE,
                          readQueryFromClient, server.master)) {serverLog(LL_WARNING,&quot;Error resurrecting the cached master, impossible to add the readable handler: %s&quot;, strerror(errno));
        freeClientAsync(server.master); /* Close ASAP. */
    }

    if (clientHasPendingReplies(server.master)) {
        if (aeCreateFileEvent(server.el, newfd, AE_WRITABLE,
                          sendReplyToClient, server.master)) {serverLog(LL_WARNING,&quot;Error resurrecting the cached master, impossible to add the writable handler: %s&quot;, strerror(errno));
            freeClientAsync(server.master); /* Close ASAP. */
        }
    }
}
</code></pre><p>可以看出，从 <code>cached_master</code> 恢复 master，将状态机置为 <strong>REPL_STATE_CONNECTED</strong>。<br> 为 fd 的读事件注册新的回调函数 readQueryFromClient。<br> 如果在 <code>server.master</code> 上仍然有 reply，或者是在写 buffer 里有数据，那么需要为写事件注册回调函数 <code>sendReplyToClient</code>。</p><p>【3】<code>-ERR</code> 的情况。需要清理现有的 <code>cached_master</code>，返回给上层函数 <strong>PSYNC_NOT_SUPPORTED</strong> 。</p><p>回到 <strong>syncWithMaster</strong> 函数里，处理 PSYNC 命令的返回值。<br> 当返回的是 <strong>PSYNC_CONTINUE</strong> 时，表示进行的是部分重同步，该函数结束。</p><pre><code class="language-c">if (psync_result == PSYNC_CONTINUE) { /* 部分重同步 ，不会走到下面接收 rdb 的流程 */
  serverLog(LL_NOTICE, &quot;MASTER &lt;-&gt; SLAVE sync: Master accepted a Partial Resynchronization.&quot;);
  return;
}
</code></pre><p>否则，有两种可能，进行完全重同步，或者 master 不支持 PSYNC 命令(老版本的 master)，但是无论如何都需要断开现有的所有 slave，因为新 master 可能会传过来一份不同的数据。<br> 同时清空复制积压缓冲区，即 repl_backlog，不允许我的 slave 做 psync 了（<strong>毕竟数据不同了嘛</strong>）。</p><p>如果新 master 不支持 PSYNC 命令，那么同步发送 SYNC 命令。</p><pre><code class="language-c">if (psync_result == PSYNC_NOT_SUPPORTED) {serverLog(LL_NOTICE,&quot;Retrying with SYNC...&quot;);
    if (syncWrite(fd,&quot;SYNC\r\n&quot;,6,server.repl_syncio_timeout*1000) == -1) {
        serverLog(LL_WARNING,&quot;I/O error writing to MASTER: %s&quot;,
                  strerror(errno));
        goto error;
    }
}
</code></pre><p>如果没有出错，接下来准备完全重同步阶段 master 发过来的 rdb 数据。创建一个名字以 tmp 为前缀的临时 rdb 接收文件，打开，并记录 fd，最多 5 次，要是还不能成功创建一个临时文件，那么就走错误处理的流程了。代码如下，</p><pre><code class="language-c">while(maxtries--) {
    snprintf(tmpfile,256,
             &quot;temp-%d.%ld.rdb&quot;,(int)server.unixtime,(long int)getpid());
    dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL,0644);
    if (dfd != -1) break;
    sleep(1);
}
if (dfd == -1) {serverLog(LL_WARNING,&quot;Opening the temp file needed for MASTER &lt;-&gt; SLAVE synchronization: %s&quot;,strerror(errno));
    goto error;
}
</code></pre><p>接着为 fd 的读事件注册回调函数 <code>readSyncBulkPayload</code>，用来处理从 master 读到的数据 rdb 文件。</p><pre><code class="language-c">/* 为 fd 的可读事件注册新的函数 readSyncBulkPayload */
if (aeCreateFileEvent(server.el,fd, AE_READABLE,readSyncBulkPayload,NULL) == AE_ERR)
{
    serverLog(LL_WARNING,
              &quot;Can't create readable event for SYNC: %s (fd=%d)&quot;,
              strerror(errno),fd);
    goto error;
}
</code></pre><p>最后是一些 server 变量的赋值。</p><pre><code class="language-c">server.repl_state = REPL_STATE_TRANSFER;
/* 初始化 RDB 文件大小 */
server.repl_transfer_size = -1;
/* 已读数据大小 */
server.repl_transfer_read = 0;
/* 最近一次执行的 fsync 偏移量 */
server.repl_transfer_last_fsync_off = 0;
/* 本地临时 rdb 文件的 fd */
server.repl_transfer_fd = dfd;
/* 最近一次读数据的时间 */
server.repl_transfer_lastio = server.unixtime;
/* 本地临时 rdb 文件的名字 */
server.repl_transfer_tmpfile = zstrdup(tmpfile);
</code></pre><p>状态机置为 <strong>REPL_STATE_TRANSFER</strong>，<code>repl_transfer_fd</code> 记录 rdb 临时文件的 fd。</p><h4 id="几个超时保证">几个超时保证</h4><p>在 <strong>replicationCron</strong> 函数中的开始部分，有一些超时保证。</p><p>与 master 建立连接后，一直没能发 PING，说明连接可能有问题。<br> 在鉴权和确认 capa 的流程中，花了过多的时间。</p><pre><code class="language-c">if (server.masterhost &amp;&amp;
    (server.repl_state == REPL_STATE_CONNECTING ||  slaveIsInHandshakeState()) &amp;&amp;
        (time(NULL)-server.repl_transfer_lastio) &gt; server.repl_timeout) // 默认 60s 超时
{serverLog(LL_WARNING,&quot;Timeout connecting to the MASTER...&quot;);
    cancelReplicationHandshake();}

int slaveIsInHandshakeState(void) {
    return server.repl_state &gt;= REPL_STATE_RECEIVE_PONG &amp;&amp;
        server.repl_state &lt;= REPL_STATE_RECEIVE_PSYNC;
}
</code></pre><p>接收 rdb 文件的时长做限制。</p><pre><code class="language-c">/* Bulk transfer I/O timeout? */
if (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_TRANSFER &amp;&amp;
    (time(NULL)-server.repl_transfer_lastio) &gt; server.repl_timeout) // 默认 60s 超时
{serverLog(LL_WARNING,&quot;Timeout receiving bulk data from MASTER... If the problem persists try to set the 'repl-timeout' parameter in redis.conf to a larger value.&quot;);
    cancelReplicationHandshake();}
</code></pre><p>成为 slave 以后，没有数据发过来。</p><pre><code class="language-c"> /* Timed out master when we are an already connected slave? */
if (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_CONNECTED &amp;&amp;
    (time(NULL)-server.master-&gt;lastinteraction) &gt; server.repl_timeout)
{serverLog(LL_WARNING,&quot;MASTER timeout: no data nor PING received...&quot;);
    freeClient(server.master);
}
</code></pre><h3 id="接收 -RDB- 文件">接收 RDB 文件</h3><p>接收 rdb 数据有两种方式，一种是磁盘化的，一种是无磁盘化的。</p><blockquote><p>从 V2.8.18 开始，redis 引入了“无硬盘复制”选项，开启该选项时，redis 在与 slave 进行复制初始化时将不会将快照内容存储到硬盘上，而是直接通过网络发送给 slave，避免了硬盘的性能瓶颈，可以在配置文件中使用 <strong>repl-diskless-sync</strong> 选项来配置开启该功能。</p></blockquote><p>两种方式发送的数据格式是不一样的。<br> 磁盘化复制时，master 先生成 rdb 文件，然后将文件内容加上 <code>$&lt;len&gt;/r/n</code> 的头部后，发送给 slave。<br> 而无磁盘化复制时，master 直接把 rdb 数据发送给你 slave 时，以 <code>$EOF:&lt;XXX&gt;\r\n</code> 开头，并以 <code>&lt;XXX&gt;</code> 结尾，开头和结尾的 <code>&lt;XXX&gt;</code> 内容相同，都是 40 个字节，是由 <strong>0123456789abcdef</strong> 中的字符组成的随机字符串，为了校验数据的是否发送完成。</p><p>该流程主要是回调函数 <code>readSyncBulkPayload</code> 中的逻辑。<br> 首先读取 master 传过来的辅助信息。</p><pre><code class="language-c">if (server.repl_transfer_size == -1) {
    /* 第一行内容 $&lt;len&gt;/r/n */
    if (syncReadLine(fd,buf,1024,server.repl_syncio_timeout*1000) == -1) {
        serverLog(LL_WARNING,
                  &quot;I/O error reading bulk count from MASTER: %s&quot;,
                  strerror(errno));
        goto error;
    }

    if (buf[0] == '-') {
        serverLog(LL_WARNING,
                  &quot;MASTER aborted replication with an error: %s&quot;,
                  buf+1);
        goto error;
    } else if (buf[0] == '\0') {
        server.repl_transfer_lastio = server.unixtime;
        return;
    } else if (buf[0] != '$') {serverLog(LL_WARNING,&quot;Bad protocol from MASTER, the first byte is not '$' (we received '%s'), are you sure the host and port are right?&quot;, buf);
        goto error;
    }

  /* 有两种可能的 bulk payload 格式，正常的是 $&lt;count&gt;
   * 还有一种可能就是无磁盘化主从同步时，因为这个时候不知道后面要传输数据的长度，因此会发送一个分隔符，
   * 格式为 $EOF:&lt;40 bytes delimiter&gt;
   * 在发送完 rdb 数据后，分隔符会再次被发送，以便让接收端知道数据发送完成了。
   * 分隔符足够的长和随机，因此真实文件内容碰撞的可能性可以被忽略。*/
    if (strncmp(buf+1,&quot;EOF:&quot;,4) == 0 &amp;&amp; strlen(buf+5) &gt;= CONFIG_RUN_ID_SIZE) {
      usemark = 1;
      memcpy(eofmark,buf+5,CONFIG_RUN_ID_SIZE);
      memset(lastbytes,0,CONFIG_RUN_ID_SIZE);
      server.repl_transfer_size = 0;
      serverLog(LL_NOTICE,
                &quot;MASTER &lt;-&gt; SLAVE sync: receiving streamed RDB from master&quot;);
    } else {
      usemark = 0;
      server.repl_transfer_size = strtol(buf+1,NULL,10);
      serverLog(LL_NOTICE,
                &quot;MASTER &lt;-&gt; SLAVE sync: receiving %lld bytes from master&quot;,
                (long long) server.repl_transfer_size);
    }
    return;
}
</code></pre><p>同步读取第一行内容，当开启了无磁盘化同步时，有一点需要注意，保存完 eofmark 后，要把 <code>repl_transfer_size</code> 变量置为一个非 -1 的值，防止下次事件触发后又进到这个逻辑里来了。而正常同步时，可以读到 <code>repl_transfer_size</code> 的大小。<br> 通过 <code>usemark</code> 来标记同步类型，值为 1 表示无磁盘化的同步，值为 0 表示磁盘化同步。</p><pre><code class="language-c">/* Read bulk data */
if (usemark) {readlen = sizeof(buf);
} else {
    left = server.repl_transfer_size - server.repl_transfer_read;
    readlen = (left &lt; (signed)sizeof(buf)) ? left : (signed)sizeof(buf);
}
</code></pre><p>以上逻辑来调整每次从 socket 中读取数据的长度，因为 usemark 时，不知道要读取的数据总长度。</p><pre><code class="language-c">nread = read(fd,buf,readlen);
if (nread &lt;= 0) {
    serverLog(LL_WARNING,&quot;I/O error trying to sync with MASTER: %s&quot;,
              (nread == -1) ? strerror(errno) : &quot;connection lost&quot;);
    cancelReplicationHandshake();
    return;
}
</code></pre><p>计算出 readlen 后，读取数据，如果读错了，要断开连接，清理 fd ，重置同步状态等，<code>cancelReplicationHandshake</code> 的逻辑在上面已经说过。<br> 如果是 usemark，那么需要校验 eofmark，以便知道数据是否已经读完。</p><pre><code class="language-c">int eof_reached = 0;

if (usemark) {
    /* Update the last bytes array, and check if it matches our delimiter.*/
    if (nread &gt;= CONFIG_RUN_ID_SIZE) {memcpy(lastbytes,buf+nread-CONFIG_RUN_ID_SIZE,CONFIG_RUN_ID_SIZE);
    } else {
        int rem = CONFIG_RUN_ID_SIZE-nread;
        memmove(lastbytes,lastbytes+nread,rem);
        memcpy(lastbytes+rem,buf,nread);
    }
    /* 读到 EOF 了 */
    if (memcmp(lastbytes,eofmark,CONFIG_RUN_ID_SIZE) == 0) eof_reached = 1;
}
</code></pre><p>如果读到的数据长度 &gt;= 40，那么截取 buf 最后 40 个字符。否则使用 <code>memmove</code> 和 <code>memcpy</code> 将最后的 40 个字节填满，这部分操作有点绕，画了个图帮助理解，</p><p><img src="http://ww1.sinaimg.cn/large/71ca8e3cly1g5w95590gbj20h60873z7.jpg" srcset="/img/loading.gif" alt="lastbytes"></p><p>然后根据前面记录 eofmark 去判断是不是数据接收结束了，如果是，<code>eof_reached</code> 置为 1。<br> 读完一次数据需要将其写入本地的临时 rdb 文件里，</p><pre><code class="language-c">if (write(server.repl_transfer_fd,buf,nread) != nread) {serverLog(LL_WARNING,&quot;Write error or short write writing to the DB dump file needed for MASTER &lt;-&gt; SLAVE synchronization: %s&quot;, strerror(errno));
    goto error;
}
server.repl_transfer_read += nread; // 更新读了多少数据量
</code></pre><p>如果是已经读到末尾了，那么需要从文件中删掉 eofmark，因为它不是 rdb 数据嘛，只是个辅助标识。</p><pre><code class="language-c">if (usemark &amp;&amp; eof_reached) {
    if (ftruncate(server.repl_transfer_fd,
                  server.repl_transfer_read - CONFIG_RUN_ID_SIZE) == -1)
    {serverLog(LL_WARNING,&quot;Error truncating the RDB file received from the master for SYNC: %s&quot;, strerror(errno));
        goto error;
    }
}
</code></pre><p>光是 <code>write</code> 了还不够，这只是写到了系统的 cache，还需要做 <code>fsync</code> 将数据落盘。</p><pre><code class="language-c">if (server.repl_transfer_read &gt;=
    server.repl_transfer_last_fsync_off + REPL_MAX_WRITTEN_BEFORE_FSYNC)
{
    off_t sync_size = server.repl_transfer_read -
      server.repl_transfer_last_fsync_off;
    rdb_fsync_range(server.repl_transfer_fd,
                    server.repl_transfer_last_fsync_off, sync_size);
    server.repl_transfer_last_fsync_off += sync_size;
}
</code></pre><p>刷盘策略是每 8M 一次。<br> 如果不是无磁盘化的主从同步，就要依赖于接收到的数据 size 与第一次传过来的值作比较。</p><pre><code class="language-c">if (!usemark) {if (server.repl_transfer_read == server.repl_transfer_size)
        eof_reached = 1;
}
</code></pre><p>如果完全接收完数据了了，那么需要做一些善后工作，如下代码，</p><pre><code class="language-c"> if (eof_reached) {....}
</code></pre><p>首先，把本地 rdb 文件的名字改成配置文件里配置的名字<code>server.rdb_filename</code>。</p><pre><code class="language-c">if (rename(server.repl_transfer_tmpfile,server.rdb_filename) == -1) {serverLog(LL_WARNING,&quot;Failed trying to rename the temp DB into dump.rdb in MASTER &lt;-&gt; SLAVE 				synchronization: %s&quot;, strerror(errno));
    cancelReplicationHandshake();
    return;
}
</code></pre><p>然后需要为加载新的 rdb 文件做一些准备。</p><pre><code class="language-c">signalFlushedDb(-1); // 使得本实例的所有客户端感知到接下来要清空数据库
emptyDb(replicationEmptyDbCallback); // 清空所有数据，给 master 发一个 \n
</code></pre><pre><code class="language-c">long long emptyDb(void(callback)(void*)) {
    int j;
    long long removed = 0;

    for (j = 0; j &lt; server.dbnum; j++) {removed += dictSize(server.db[j].dict);
        dictEmpty(server.db[j].dict,callback);
        dictEmpty(server.db[j].expires,callback);
    }
    if (server.cluster_enabled) slotToKeyFlush();
    return removed;
}

/* Callback used by emptyDb() while flushing away old data to load
 * the new dataset received by the master. */
void replicationEmptyDbCallback(void *privdata) {UNUSED(privdata);
    replicationSendNewlineToMaster();}

/* 给 master 发 \n 表明自己还活着，在加载数据 */
void replicationSendNewlineToMaster(void) {
    static time_t newline_sent;
    if (time(NULL) != newline_sent) {newline_sent = time(NULL);
        if (write(server.repl_transfer_s,&quot;\n&quot;,1) == -1) {/* Pinging back in this stage is best-effort. */}
    }
}
</code></pre><p>清空老数据完老数据，下面开始加载新数据。</p><pre><code class="language-c">aeDeleteFileEvent(server.el,server.repl_transfer_s,AE_READABLE);
serverLog(LL_NOTICE, &quot;MASTER &lt;-&gt; SLAVE sync: Loading DB in memory&quot;);
if (rdbLoad(server.rdb_filename) != C_OK) {serverLog(LL_WARNING,&quot;Failed trying to load the MASTER synchronization DB from disk&quot;);
    cancelReplicationHandshake();
    return;
}
</code></pre><p>在加载新数据之前，需要先删除 socket fd 的可读事件，这是因为在调用 <code>rdbLoad</code> 加载 rdb 数据时，每次调用<code>rioRead</code> 都会因为要计算 checksum 而调用 <code>processEventsWhileBlocked</code> 处理当前已触发的事件，如果不删除该可读事件的话，就会递归进入的本函数中（因此，slave 在加载 rdb 数据时，是不能处理主节点发来的其他数据的）。<br> 然后做一些清理工作。</p><pre><code class="language-c">zfree(server.repl_transfer_tmpfile);
close(server.repl_transfer_fd);
</code></pre><p>根据 socket fd 创建一个 master 的 client。</p><pre><code class="language-c"> /* 创建 master 相关的变量 */
replicationCreateMasterClient(server.repl_transfer_s);
</code></pre><p>然后可以看下这个 <code>replicationCreateMasterClient</code> 这个函数都干了些什么事情。</p><pre><code class="language-c">void replicationCreateMasterClient(int fd) {server.master = createClient(fd);
    server.master-&gt;flags |= CLIENT_MASTER;
    server.master-&gt;authenticated = 1;
    server.repl_state = REPL_STATE_CONNECTED;
    server.master-&gt;reploff = server.repl_master_initial_offset;
    memcpy(server.master-&gt;replrunid, server.repl_master_runid,
        sizeof(server.repl_master_runid));
    if (server.master-&gt;reploff == -1)
        server.master-&gt;flags |= CLIENT_PRE_PSYNC;
}
</code></pre><p>需要注意一点，如果 master 不支持 PSYNC 的话，那么 salve 不会得到 <code>+FULLRESYNC</code> 的回复，也就不会更新 <code>server.repl_master_initial_offset</code> 变量，它就一直是 -1，在这里创建 master client 时，会给它一个标记 <strong>CLIENT_PRE_PSYNC</strong>。</p><p>这里会把状态机更新为 <strong>REPL_STATE_CONNECTED</strong>。<br> 最后，如果 aof 功能没有关闭的话，需要重新生成 aof 文件，因为数据已经改变了。</p><pre><code class="language-c">if (server.aof_state != AOF_OFF) {
    int retry = 10;

    stopAppendOnly();
    while (retry-- &amp;&amp; startAppendOnly() == C_ERR) {serverLog(LL_WARNING,&quot;Failed enabling the AOF after successful master synchronization! 							Trying it again in one second.&quot;);
        sleep(1);
    }
    if (!retry) {serverLog(LL_WARNING,&quot;FATAL: this slave instance finished the synchronization with its 							master, but the AOF can't be turned on. Exiting now.&quot;);
        exit(1);
    }
}
</code></pre><p>到这里，<code>readSyncBulkPayload</code> 函数读取并加载新 rdb 文件的流程就走完了。</p><p>当复制状态变为 <strong>REPL_STATE_CONNECTED</strong> 后，表示进入了命令传播阶段。后续 slave 将 master 当成一个客户端，并接收其发来的命令请求，像处理普通客户端一样处理即可。命令传播在前面的博客已经详细讲过。</p><h3 id="探活机制">探活机制</h3><p>在 master-slave 连接建立以后，他们就通过心跳进行相互探活，这些机制都在 <code>replicationCron</code> 函数里。</p><h4 id="master- 探活">master 探活</h4><p>master 会定期给它所有的 slave 发送 PING。</p><pre><code class="language-c">if ((replication_cron_loops % server.repl_ping_slave_period) == 0) {ping_argv[0] = createStringObject(&quot;PING&quot;,4);
    replicationFeedSlaves(server.slaves, server.slaveseldb,
                          ping_argv, 1);
    decrRefCount(ping_argv[0]);
}
</code></pre><p>给 slave 发送命令是通过 <code>replicationFeedSlaves</code> 函数实现的。</p><pre><code class="language-c">void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {....}
</code></pre><p>下面看一下该函数的详细实现。</p><pre><code class="language-c">if (server.repl_backlog == NULL &amp;&amp; listLength(slaves) == 0) return;
</code></pre><p>如果 <code>repl_backlog</code> 为空，或者是没有 slave，那么这个过程是不必要的，直接返回。必要的时候生成 SELECT 命令，告知 slave 切换数据库。<code>slaveseldb</code> 中保存的是上一次 replication 输出时选择的数据库。</p><pre><code class="language-c">if (server.repl_backlog) {char aux[LONG_STR_SIZE+3];

    /* Add the multi bulk reply length. */
    aux[0] = '*';
    len = ll2string(aux+1,sizeof(aux)-1,argc);
    aux[len+1] = '\r';
    aux[len+2] = '\n';
    feedReplicationBacklog(aux,len+3);

    for (j = 0; j &lt; argc; j++) {long objlen = stringObjectLen(argv[j]);
        aux[0] = '$';
        len = ll2string(aux+1,sizeof(aux)-1,objlen);
        aux[len+1] = '\r';
        aux[len+2] = '\n';
        feedReplicationBacklog(aux,len+3);
        feedReplicationBacklogWithObject(argv[j]);
        feedReplicationBacklog(aux+len+1,2);
    }
}
</code></pre><p>如果 <code>repl_backlog</code> 不为空，那么组装 redis 协议的命令，这里是 <code>*1\r\n$4\r\nPING</code>，放到 <code>repl_backlog</code> 变量里。</p><h4 id="slave- 探活">slave 探活</h4><pre><code class="language-c">void replicationCron(void) {
    ...
    if (server.masterhost &amp;&amp; server.master &amp;&amp;
          !(server.master-&gt;flags &amp; CLIENT_PRE_PSYNC)) {replicationSendAck();
    }
    ...
}

void replicationSendAck(void) {
    client *c = server.master;

    if (c != NULL) {
        c-&gt;flags |= CLIENT_MASTER_FORCE_REPLY;
        addReplyMultiBulkLen(c,3);
        addReplyBulkCString(c,&quot;REPLCONF&quot;);
        addReplyBulkCString(c,&quot;ACK&quot;);
        addReplyBulkLongLong(c,c-&gt;reploff);
        c-&gt;flags &amp;= ~CLIENT_MASTER_FORCE_REPLY;
    }
}
</code></pre><p>对于非老版本的 master，slave 向它定期发送 <code>REPLCONF ACK &lt;offset&gt;</code> 命令，以便告诉它复制偏移量。</p><h2 id="cluster- 模式">cluster 模式</h2><p>cluster 模式下，使用 <code>CLUSTER REPLICATE &lt;NODE ID&gt;</code> 命令来进行新的主从关系的构建。</p><pre><code class="language-c">void clusterCommand(client *c) {
    ...
    else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;replicate&quot;) &amp;&amp; c-&gt;argc == 3) {
        /* CLUSTER REPLICATE &lt;NODE ID&gt; */
        clusterNode *n = clusterLookupNode(c-&gt;argv[2]-&gt;ptr);

        /* Lookup the specified node in our table. */
        if (!n) {addReplyErrorFormat(c,&quot;Unknown node %s&quot;, (char*)c-&gt;argv[2]-&gt;ptr);
            return;
        }
        /* I can't replicate myself. */
        if (n == myself) {addReplyError(c,&quot;Can't replicate myself&quot;);
            return;
        }
        /* Can't replicate a slave. */
        if (nodeIsSlave(n)) {addReplyError(c,&quot;I can only replicate a master, not a slave.&quot;);
            return;
        }
        // 我要做别人的 slave， 那么不是不能够有 slots 和数据库数据的
        if (nodeIsMaster(myself) &amp;&amp;
            (myself-&gt;numslots != 0 || dictSize(server.db[0].dict) != 0)) {
            addReplyError(c,
                &quot;To set a master the node must be empty and &quot;
                &quot;without assigned slots.&quot;);
            return;
        }

        /* Set the master. */
        clusterSetMaster(n);
        clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
        addReply(c,shared.ok);
    }
    .....
}
</code></pre><p><strong>很重要的一个检查</strong> 是，有 slot 或者有数据的 master 节点，不能做此操作，防止丢数据。<br> 跳过一些合理性检查，重点函数就是 <code>clusterSetMaster</code> 了，那么它做了什么呢？</p><pre><code class="language-c">void clusterSetMaster(clusterNode *n) {serverAssert(n != myself);
    serverAssert(myself-&gt;numslots == 0);

    if (nodeIsMaster(myself)) {myself-&gt;flags &amp;= ~(CLUSTER_NODE_MASTER|CLUSTER_NODE_MIGRATE_TO);
        myself-&gt;flags |= CLUSTER_NODE_SLAVE;
        clusterCloseAllSlots();} else {if (myself-&gt;slaveof)
            clusterNodeRemoveSlave(myself-&gt;slaveof,myself); // 解除原有的主从关系
    }
    myself-&gt;slaveof = n;
    clusterNodeAddSlave(n,myself);
    replicationSetMaster(n-&gt;ip, n-&gt;port);
    resetManualFailover();}
</code></pre><p>首先，如果本身是个 master，那么取消掉 master 和 migrating 的 flag，因为该 master 没有数据，可以大胆地取消迁移的叫标记，然后加上 slave 的标记 <strong>CLUSTER_NODE_SLAVE</strong>。<br> 如果原本就是个 slave 节点，那么调整自己的主从归属信息，置空以手动主从切换有关的变量值，关于 cluster mf 的逻辑以后会专门去讨论。<br> 然后就是前面说过的 <code>replicationSetMaster</code> 函数，触发上也是在 cron 里，就不啰嗦了。</p><p>以上，主从复制中，slave 的逻辑就介绍完了。</p></div><hr><div><p><span><i class="iconfont icon-inbox"></i> <a class="hover-with-bg" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a> &nbsp;</span> &nbsp;&nbsp;<span><i class="iconfont icon-tag"></i> <a class="hover-with-bg" href="/tags/redis/">redis</a></span></p><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="post-prevnext row"><div class="post-prev col-6"><a href="/9025979a.html"><i class="fa fa-chevron-left"></i> <span class="hidden-mobile">Redis 源码之主从复制 (4)</span> <span class="visible-mobile">上一篇</span></a></div><div class="post-next col-6"> <a href="/8f9133db.html"><span class="hidden-mobile">Redis 源码之主从复制 (2)</span> <span class="visible-mobile">下一篇</span><i class="fa fa-chevron-right"></i></a></div></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script type="text/javascript">!function(e,t){var r,n=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((r=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",r.defer=!0,n.parentNode.insertBefore(r,n))}(document,"script")</script><noscript> 为正常使用来必力评论功能请激活JavaScript</noscript></div></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc-start"></div><div id="toc"><p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-md"><div class="container custom post-content mx-auto"> <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px;height:150px"></div></div></main><a class="z-depth-1" id="scroll-top-button" href="#" role="button"><i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4> <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"> <span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"> <input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a><i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><b>Fluid</b></a></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script><script>$(document).ready(function(){var s=$("#navbar").height(),c=$("#toc"),t=$("#board-ctn"),o=t.offset().top,i=2*o+t.height();$(window).scroll(function(){var t=$("#toc-start").offset().top-s,o=document.body.scrollTop+document.documentElement.scrollTop;t<=o&&o<=i?c.css({display:"block",position:"fixed",top:s}):o<=t?c.css({position:"",top:""}):i<o&&c.css("display","none")}),tocbot.init({tocSelector:"#tocbot",contentSelector:".post-content",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,headingsOffset:-o}),0<$(".toc-list-item").length&&$("#toc > p").css("visibility","visible");var l=t.css("margin-right");$("#toc-ctn").css({right:l})})</script><script defer="defer" src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer="defer" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script defer="defer">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?882b48640075e00a238ae94a7eec0d40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script defer="defer">var _mtac={};!function(){var t=document.createElement("script");t.src="//pingjs.qq.com/h5/stats.js?v2.0.4",t.setAttribute("name","MTAH5"),t.setAttribute("sid","");var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js"></script><script>$(document).ready(function(){$("pre").addClass("prettyprint  "),prettyPrint()})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","Redis 源码之主从复制 (3)&nbsp;"],cursorChar:"_",typeSpeed:80,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){getSearchFile(path),this.onclick=null}</script><script defer="defer" src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><script>$("#post img:not(.no-zoom img, img[no-zoom])").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>