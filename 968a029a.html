<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Redis 源码之主从复制(3)"><meta name="keywords" content="redis"><meta name="author" content="Happen"><meta name="copyright" content="Happen"><title>Redis 源码之主从复制(3) | Happen's Memo</title><link rel="shortcut icon" href="/images/dolphin.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?882b48640075e00a238ae94a7eec0d40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,c,g,o){e.GoogleAnalyticsObject=c,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,g=a.createElement(t),o=a.getElementsByTagName(t)[0],g.async=1,g.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(g,o)}(window,document,"script",0,"ga"),ga("create","RRBput3V2WYVZd2lq058Z4IwJEhViOwuMElqkWh6bcA","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#单机模式下的主从复制"><span class="toc-number">1.</span> <span class="toc-text">单机模式下的主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#触发方式"><span class="toc-number">1.1.</span> <span class="toc-text">触发方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SLAVEOF-NO-ONE-命令"><span class="toc-number">1.1.1.</span> <span class="toc-text">SLAVEOF NO ONE 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SLAVEOF-host-port-命令"><span class="toc-number">1.1.2.</span> <span class="toc-text">SLAVEOF host port 命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主从建立连接"><span class="toc-number">1.2.</span> <span class="toc-text">主从建立连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主从-handshake-过程"><span class="toc-number">1.3.</span> <span class="toc-text">主从 handshake 过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#发送-ping"><span class="toc-number">1.3.1.</span> <span class="toc-text">发送 ping</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#验证-AUTH"><span class="toc-number">1.3.2.</span> <span class="toc-text">验证 AUTH</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#发送-REPLCONF-命令"><span class="toc-number">1.3.3.</span> <span class="toc-text">发送 REPLCONF 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#尝试做部分重同步"><span class="toc-number">1.3.4.</span> <span class="toc-text">尝试做部分重同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#几个超时保证"><span class="toc-number">1.3.5.</span> <span class="toc-text">几个超时保证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接收-RDB-文件"><span class="toc-number">1.4.</span> <span class="toc-text">接收 RDB 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#探活机制"><span class="toc-number">1.5.</span> <span class="toc-text">探活机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#master-探活"><span class="toc-number">1.5.1.</span> <span class="toc-text">master 探活</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slave-探活"><span class="toc-number">1.5.2.</span> <span class="toc-text">slave 探活</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cluster-模式"><span class="toc-number">2.</span> <span class="toc-text">cluster 模式</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.png"></div><div class="author-info__name text-center">Happen</div><div class="author-info__description text-center">浮生若梦，为欢几何</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">37</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://renrenlove.me/" target="_blank" rel="noopener">Galway</a><a class="author-info-links__name text-center" href="http://kvguru.com/" target="_blank" rel="noopener">Wangbin</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div id="page-header"> <span class="pull-left"><a id="site-name" href="/">Happen's Memo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Redis 源码之主从复制(3)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-05</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a><div class="post-meta-wordcount"><span>字数总计:</span> <span class="word-count">7.3k</span><span class="post-meta__separator">|</span><span>阅读时长: 31 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>redis 代码中主从复制流程的核心部分在于<strong>状态机的流转</strong>。</p><a id="more"></a><p>单机模式下以 <strong>SLAVEOF</strong> 命令触发；<br>cluster 模式下以 <strong>REPLICATE</strong> 命令触发，且 cluster 模式下不支持 <strong>SLAVEOF</strong> 命令。</p><p>在该过程中，master 与 slave 各有不同的流转逻辑，交互频繁，本文以下内容试图介绍 slave 的处理逻辑,以下流程图可以辅助理解。<br><img src="https://s2.ax1x.com/2019/09/09/nGjlXd.png" alt="nGjlXd.png"></p><p>代码中在 <code>redisServer</code> 结构体里定义的很多 <strong>repl</strong> 前缀的变量都用于此过程，如<code>repl_transfer_fd</code>。<br>各变量的作用在源码注释里已经写得非常详细了，不做赘述。</p><h2 id="单机模式下的主从复制"><a href="#单机模式下的主从复制" class="headerlink" title="单机模式下的主从复制"></a>单机模式下的主从复制</h2><p>redis 实例以单机模式启动，即在 <span id="inline-blue">redis.conf</span> 中配置 <strong>cluster-enabled no</strong>。</p><h3 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h3><p>有以下三种方式可触发主从复制流程。<br>① <span id="inline-blue">redis.conf</span> 中配置 <code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>；<br>② redis-server 命令启动服务时指定参数 <code>--slaveof [masterip] [masterport]</code>；<br>③ 对一个实例执行 <code>slaveof [masterip] [masterport]</code> 命令。</p><p>①② 逻辑相似，直接标记 <code>server.repl_state</code> 为 <strong>REPL_STATE_CONNECT</strong> 状态，以 ① 为例简要说明，加载配置文件时有如下逻辑，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadServerConfigFromString</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">config</span>)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">"slaveof"</span>) &amp;&amp; argc == <span class="number">3</span>) &#123;</span><br><span class="line">        slaveof_linenum = linenum;</span><br><span class="line">        server.masterhost = sdsnew(argv[<span class="number">1</span>]);</span><br><span class="line">        server.masterport = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">        server.repl_state = REPL_STATE_CONNECT;</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 ③ 在标记 <code>REPL_STATE_CONNECT</code> 状态前需要做一些检查。<br>首先，检查实例是否开启了 cluster 模式，如果开启了，那么直接返回，不支持这个命令。<br>接着，通过检查 <code>slaveof</code> 命令后面的参数来判断使用的是哪个命令，代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slaveofCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* cluster 模式开启后，禁用 slaveof 命令 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"SLAVEOF not allowed in cluster mode."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// SLAVEOF NO ONE</span></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"no"</span>) &amp;&amp;</span><br><span class="line">        !strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">"one"</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.masterhost) &#123; <span class="comment">// 如果之前有 master</span></span><br><span class="line">            replicationUnsetMaster();</span><br><span class="line">            sds client = catClientInfoString(sdsempty(),c);</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"MASTER MODE enabled (user request from '%s')"</span>, client);</span><br><span class="line">            sdsfree(client);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> port;</span><br><span class="line">        <span class="comment">// 从参数中获得 port</span></span><br><span class="line">        <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;port, <span class="literal">NULL</span>) != C_OK))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果现在的 master 已经是要设置的，那么就不必再做操作了，直接返回吧</span></span><br><span class="line">        <span class="keyword">if</span> (server.masterhost &amp;&amp; !strcasecmp(server.masterhost,c-&gt;argv[<span class="number">1</span>]-&gt;ptr)</span><br><span class="line">            &amp;&amp; server.masterport == port) &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"SLAVE OF would result into synchronization with the master we are already connected with. No operation performed."</span>);</span><br><span class="line">            addReplySds(c,sdsnew(<span class="string">"+OK Already connected to specified master\r\n"</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        replicationSetMaster(c-&gt;argv[<span class="number">1</span>]-&gt;ptr, port);</span><br><span class="line">        sds client = catClientInfoString(sdsempty(),c);</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"SLAVE OF %s:%d enabled (user request from '%s')"</span>,</span><br><span class="line">            server.masterhost, server.masterport, client);</span><br><span class="line">        sdsfree(client);</span><br><span class="line">    &#125;</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SLAVEOF-NO-ONE-命令"><a href="#SLAVEOF-NO-ONE-命令" class="headerlink" title="SLAVEOF NO ONE 命令"></a>SLAVEOF NO ONE 命令</h4><p>该命令会取消现有的主从关系，使 slave 变为 master，主要函数如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationUnsetMaster</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 已经是 master 了，无需继续操作</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    sdsfree(server.masterhost);</span><br><span class="line">    server.masterhost = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.master) &#123;</span><br><span class="line">        <span class="keyword">if</span> (listLength(server.slaves) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 继承 master 的 repl offset</span></span><br><span class="line">            server.master_repl_offset = server.master-&gt;reploff;</span><br><span class="line">            freeReplicationBacklog();</span><br><span class="line">        &#125;</span><br><span class="line">        freeClient(server.master);</span><br><span class="line">    &#125;</span><br><span class="line">    replicationDiscardCachedMaster();</span><br><span class="line">    cancelReplicationHandshake();</span><br><span class="line">    server.repl_state = REPL_STATE_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要涉及到一些与 master 相关的变量的内存释放。<br>如果该实例有 master，且不是其他实例的 master，即 <code>listLength(server.slaves) == 0</code>，也就是说未形成链式结构，那么记录下原 master 的 replication offset。在某些特定条件下，副本的数据新鲜度可以通过 replication offset 来比较，有时由于网络等原因暂时断开了，隔了一段时间又重新连上原 master，有了这个偏移量可以减少做完全重同步的可能性(我是这么理解的)。<br><strong>freeClient</strong> 函数会释放掉原来的 master，做一些内存释放，一些标志位重置等。</p><p>接下来的 <code>replicationDiscardCachedMaster</code> 函数中会释放掉 <code>server.cached_master</code>，因为这里缓存以前的 mater 已经没用了，不知道下次要连的是哪个 master，或者自己以后成为一个 master，避免不必要的内存浪费。</p><p><code>cancelReplicationHandshake</code> 函数则会取消一个正在进行尝试 handshake 的主从复制过程。<br>最后重置状态机为 <strong>REPL_STATE_NONE</strong>。</p><h4 id="SLAVEOF-host-port-命令"><a href="#SLAVEOF-host-port-命令" class="headerlink" title="SLAVEOF host port 命令"></a>SLAVEOF host port 命令</h4><p>通过执行该命令，可以将当前实例变成某个实例的 slave。<br>如果指定的主从关系已经存在，那本次命令没必要继续执行了，直接返回；否则，通过 <code>replicationSetMaster</code> 函数设置新的主从关系，代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationSetMaster</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    sdsfree(server.masterhost);</span><br><span class="line">    server.masterhost = sdsnew(ip);</span><br><span class="line">    server.masterport = port;</span><br><span class="line">    <span class="comment">// 如果原来有 master了，需要释放掉</span></span><br><span class="line">    <span class="keyword">if</span> (server.master) freeClient(server.master);</span><br><span class="line">    disconnectAllBlockedClients();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放掉所有的 slave，让它们重新连</span></span><br><span class="line">    disconnectSlaves();</span><br><span class="line">    replicationDiscardCachedMaster();</span><br><span class="line">    freeReplicationBacklog();</span><br><span class="line"></span><br><span class="line">    cancelReplicationHandshake();</span><br><span class="line">    server.repl_state = REPL_STATE_CONNECT;</span><br><span class="line">    server.master_repl_offset = <span class="number">0</span>;</span><br><span class="line">    server.repl_down_since = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上函数中，<br>先保存下要连接的 ip 和 port，方便后面进行建立网络连接。<br>如果，该节点之前有 master 了，那么需要释放掉原来的 master，跟上面一节的逻辑类似，前面详细说过了。<br><strong>disconnectAllBlockedClients</strong> 函数会 unlock 已经 lock 在这个实例上的 client，并返回 <strong>-UNBLOCKED</strong> 开头的错误。这是因为该实例已经改变了角色，block 已经没什么意义。比如当一个实例从 master 变为 slave，那么由于 list 选项而阻塞在该实例上的 client 就不安全了，<strong>因为数据随着从新的 slave 同步数据，该实例的数据集可能会发生变化</strong>。<br><strong>disconnectSlaves</strong> 函数释放掉所有的 slave，重新同步新的数据。<br>释放掉 <code>server.cached_master</code>，同样因为数据集变化了，cache 的数据并不能用了。<br>释放掉 <code>server.repl_backlog</code>，理由同上。<br><code>cancelReplicationHandshake</code> 函数在上面讲过了。<br>将 <code>server.repl_state</code> 置为 <strong>REPL_STATE_CONNECT</strong> 状态，复制偏离量归零等。<br>最后返回 OK，也就是这个命令的返回值<code>+OK\r\n</code>。</p><h3 id="主从建立连接"><a href="#主从建立连接" class="headerlink" title="主从建立连接"></a>主从建立连接</h3><p>redis 中有很多 cron 任务，其中就有一个负责 replication 的，即每秒执行一次的 <strong>replicationCron</strong> 函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">run_with_period(<span class="number">1000</span>) replicationCron();</span><br></pre></td></tr></table></figure><p>在上一步中，状态机已经流转到 <strong>REPL_STATE_CONNECT</strong> 状态，这里直接就进入到主从建连的逻辑。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">true......</span><br><span class="line">    <span class="comment">// 开始一段新的主从关系</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECT) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Connecting to MASTER %s:%d"</span>,</span><br><span class="line">            server.masterhost, server.masterport);</span><br><span class="line">        <span class="keyword">if</span> (connectWithMaster() == C_OK) &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"MASTER &lt;-&gt; SLAVE sync started"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>server.masterhost</code> 和 <code>server.masterport</code> 向 master 发起 connect 请求， fd 设置为<strong>非阻塞</strong>。成功后，为 fd 的读写事件注册 <code>syncWithMaster</code> 回调函数，用于处理 master 与 slave 之间的 handshake 过程。这部分逻辑在 <strong>connectWithMaster</strong> 函数中实现，代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connectWithMaster</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接 master，获得 fd</span></span><br><span class="line">    fd = anetTcpNonBlockBestEffortBindConnect(<span class="literal">NULL</span>, server.masterhost,server.masterport,NET_FIRST_BIND_ADDR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Unable to connect to MASTER: %s"</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为 fd 设置读写事件回调 syncWithMaster</span></span><br><span class="line">    <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE,syncWithMaster,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Can't create readable event for SYNC"</span>);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.repl_transfer_lastio = server.unixtime;</span><br><span class="line">    server.repl_transfer_s = fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态机更新</span></span><br><span class="line">    server.repl_state = REPL_STATE_CONNECTING;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>server.repl_transfer_lastio</code> 用于记录上一次 fd 读事件的时刻，<code>server.repl_transfer_s</code> 记录主从复制使用到的 socket fd。</p><p>更新状态机为 <strong>REPL_STATE_CONNECTING</strong>。</p><h3 id="主从-handshake-过程"><a href="#主从-handshake-过程" class="headerlink" title="主从 handshake 过程"></a>主从 handshake 过程</h3><h4 id="发送-ping"><a href="#发送-ping" class="headerlink" title="发送 ping"></a>发送 ping</h4><p>主从建连成功后，通过 fd 的读写事件触发 <code>syncWithMaster</code> 回调函数。</p><p>如果该事件在用户把本实例用 <strong>SLAVEOF NO ONE</strong> 变成 master 后出触发，那么没有执行下去的必要，判断逻辑如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_NONE) &#123;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是同步发送 PING 的代码逻辑，更新状态机为 <strong>REPL_STATE_RECEIVE_PONG</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECTING) &#123;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"Non blocking connect for SYNC fired the event."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为了等待 pong 的返回，删除 fd 上的可写事件，但保留可读事件 */</span></span><br><span class="line">    aeDeleteFileEvent(server.el,fd,AE_WRITABLE);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_PONG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 同步发送 ping，这里不检查是否 err，因为已经有超时限制做保证 */</span></span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,<span class="string">"PING"</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sendSynchronousCommand</code> 函数通过 flag 标识读写命令，此处写命令标识为 <strong>SYNC_CMD_WRITE</strong>。</p><h4 id="验证-AUTH"><a href="#验证-AUTH" class="headerlink" title="验证 AUTH"></a>验证 AUTH</h4><p>使用 <strong>sendSynchronousCommand</strong> 函数同步读取 master 对 PING 的回复。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_PONG) &#123;</span><br><span class="line">    <span class="comment">/* 读取上面发送的 ping 命令的 response */</span></span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] != <span class="string">'+'</span> &amp;&amp; <span class="built_in">strncmp</span>(err,<span class="string">"-NOAUTH"</span>,<span class="number">7</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(err,<span class="string">"-ERR operation not permitted"</span>,<span class="number">28</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Error reply to PING from master: '%s'"</span>,err);</span><br><span class="line">        sdsfree(err);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">          <span class="string">"Master replied to PING, replication can continue..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_AUTH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回复只可能有 3 种情况：<strong>+PONG</strong>，<strong>-NOAUTH</strong> 和 <strong>-ERR operation not permitted</strong>（老版本的 redis 主节点）。如果不是，直接进入错误处理代码流程。</p><p><strong>注意</strong>：这里的读操作会更新变量 <code>server.repl_transfer_lastio</code>。</p><p>调整状态机为 <strong>REDIS_REPL_SEND_AUTH</strong>。这里没有 <code>return</code>，直接往下执行，进入鉴权的逻辑，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_AUTH) &#123;</span><br><span class="line">    <span class="keyword">if</span> (server.masterauth) &#123;</span><br><span class="line">        err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,<span class="string">"AUTH"</span>,server.masterauth,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">        server.repl_state = REPL_STATE_RECEIVE_AUTH;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     	 server.repl_state = REPL_STATE_SEND_PORT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果配置文件中没有设置 <strong>masterauth</strong> 选项，那么状态机置为 <strong>REPL_STATE_SEND_PORT</strong>。<br>否则，需要发送 <code>AUTH</code> 命令鉴权。状态机置为 <strong>REPL_STATE_RECEIVE_AUTH</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Receive AUTH reply. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_AUTH) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Unable to AUTH to MASTER: %s"</span>,err);</span><br><span class="line">        sdsfree(err);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_PORT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证 auth 通过后，状态机置为 <strong>REPL_STATE_SEND_PORT</strong>，否则，直接跳到的 err 处理流程。</p><h4 id="发送-REPLCONF-命令"><a href="#发送-REPLCONF-命令" class="headerlink" title="发送 REPLCONF 命令"></a>发送 REPLCONF 命令</h4><p>slave 将发送一连串的 <code>REPLCONF</code> 命令，以告知 master 自己的一些信息。<br><code>slave-announce-ip</code> 和 <code>slave-announce-port</code> 主要是针对转发或者 NAT 场景下，master 无法通过 socket 连接获得对端信息时使用。</p><p>首先发送自己的 port 信息，<code>REPLCONF listening-port &lt;port&gt;</code>，状态机置为 <strong>REPL_STATE_RECEIVE_PORT</strong>，返回，等下一次事件触发。<br>接着，同步读取 master 的回复，即使返回错误也没有关系，状态机置为 <strong>REPL_STATE_SEND_IP</strong>。<br>代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set the slave port, so that Master's INFO command can list the</span></span><br><span class="line"><span class="comment"> * slave listening port correctly. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_PORT) &#123;</span><br><span class="line">    sds port = sdsfromlonglong(server.slave_announce_port ?</span><br><span class="line">                               server.slave_announce_port : server.port);</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,<span class="string">"REPLCONF"</span>,</span><br><span class="line">                                 <span class="string">"listening-port"</span>,port, <span class="literal">NULL</span>);</span><br><span class="line">    sdsfree(port);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_PORT;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_PORT) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">      	serverLog(LL_NOTICE,<span class="string">"(Non critical) Master does not understand "</span></span><br><span class="line">                <span class="string">"REPLCONF listening-port: %s"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_IP;</span><br></pre></td></tr></table></figure><p>如果没有配置 <code>slave-announce-ip</code> 时，直接将状态机调跳转到 <strong>REPL_STATE_SEND_CAPA</strong>，跳过发送 REPLCONF ip-address 的步骤。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_IP &amp;&amp;</span><br><span class="line">    server.slave_announce_ip == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  server.repl_state = REPL_STATE_SEND_CAPA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送 REPLCONF ip-address，接收回复，将状态机置为 <strong>REPL_STATE_SEND_CAPA</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* REPLCONF ip-address &lt;ip&gt;  */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_IP) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,<span class="string">"REPLCONF"</span>,</span><br><span class="line">                                 <span class="string">"ip-address"</span>,server.slave_announce_ip, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_IP;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Receive REPLCONF ip-address reply. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_IP) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">      serverLog(LL_NOTICE,<span class="string">"(Non critical) Master does not understand "</span></span><br><span class="line">                <span class="string">"REPLCONF ip-address: %s"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_CAPA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态机置为 <strong>REPL_STATE_SEND_CAPA</strong>，告知 master 自己的能力，现在只有 eof，表示支持无磁盘化主从复制，以后可能会有更多，格式为 <code>REPLCONF capa X capa Y capa Z ...</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_CAPA) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,<span class="string">"REPLCONF"</span>,</span><br><span class="line">                                 <span class="string">"capa"</span>,<span class="string">"eof"</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_CAPA;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_CAPA) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,fd,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* Ignore the error if any, not all the Redis versions support</span></span><br><span class="line"><span class="comment">           * REPLCONF capa. */</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">      	serverLog(LL_NOTICE,<span class="string">"(Non critical) Master does not understand "</span></span><br><span class="line">                <span class="string">"REPLCONF capa: %s"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_PSYNC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态机置为 <strong>REPL_STATE_SEND_PSYNC</strong>。</p><h4 id="尝试做部分重同步"><a href="#尝试做部分重同步" class="headerlink" title="尝试做部分重同步"></a>尝试做部分重同步</h4><p>为解决旧版本 redis 在处理断线情况下完全复制的低效问题， 从 2.8 版本开始，使用 PSYNC 命令代替 SYNC 命令来执行复制时的同步操作，这个点在前面的博客讲过了。</p><p>为高效起见，首先尝试做部分重同步，试探逻辑在函数 <strong>slaveTryPartialResynchronization</strong> 中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_PSYNC) &#123;</span><br><span class="line">    <span class="keyword">if</span> (slaveTryPartialResynchronization(fd,<span class="number">0</span>) == PSYNC_WRITE_ERROR) &#123;</span><br><span class="line">        err = sdsnew(<span class="string">"Write error sending the PSYNC command."</span>);</span><br><span class="line">        <span class="keyword">goto</span> write_error;</span><br><span class="line">    &#125;</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_PSYNC;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>slaveTryPartialResynchronization</strong> 里包含了读写两部分，其中写的部分在上半部，当第二个参数为 0 时，发送 PSYNC 命令，命令格式为 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code>。<br>发送 PSYNC 时，分两种情况，首次连接或非首次连接。首次连接时，runid 未知，用 <code>?</code> 代替，offset 置为初始值 -1。<br>代码逻辑如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!read_reply) &#123;</span><br><span class="line">trueserver.repl_master_initial_offset = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.cached_master) &#123; <span class="comment">// 重连</span></span><br><span class="line">        psync_runid = server.cached_master-&gt;replrunid;</span><br><span class="line">        <span class="built_in">snprintf</span>(psync_offset,<span class="keyword">sizeof</span>(psync_offset),<span class="string">"%lld"</span>, server.cached_master-&gt;reploff+<span class="number">1</span>);</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Trying a partial resynchronization (request %s:%s)."</span>, psync_runid, psync_offset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 首次连接 master</span></span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Partial resynchronization not possible (no cached master)"</span>);</span><br><span class="line">        psync_runid = <span class="string">"?"</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(psync_offset,<span class="string">"-1"</span>,<span class="number">3</span>); <span class="comment">/* psync ? -1 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reply = sendSynchronousCommand(SYNC_CMD_WRITE,fd,<span class="string">"PSYNC"</span>,psync_runid,psync_offset,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Unable to send PSYNC to master: %s"</span>,reply);</span><br><span class="line">        sdsfree(reply);</span><br><span class="line">        <span class="comment">/* 发送出错了，需要删掉 fd 上的可读事件 */</span></span><br><span class="line">        aeDeleteFileEvent(server.el,fd,AE_READABLE);</span><br><span class="line">        <span class="keyword">return</span> PSYNC_WRITE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PSYNC_WAIT_REPLY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送出错后，需要删掉 fd 上的可读事件。<br>回到 <strong>syncWithMaster</strong> 函数中，状态机置为 <strong>REPL_STATE_RECEIVE_PSYNC</strong>。</p><p>代码逻辑走到这一步，如果状态机的状态不是 <strong>REPL_STATE_RECEIVE_PSYNC</strong>，一定是哪里出错了，进入错误处理流程，即，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* If reached this point, we should be in REPL_STATE_RECEIVE_PSYNC. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state != REPL_STATE_RECEIVE_PSYNC) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"syncWithMaster(): state machine error, "</span></span><br><span class="line">        <span class="string">"state should be RECEIVE_PSYNC but is %d"</span>, server.repl_state);</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着去读取 master 的给的回复信息，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">psync_result = slaveTryPartialResynchronization(fd,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>可能会读到三种，<code>+FULLRESYNC</code>、<code>+CONTINUE</code>以及<code>-ERR</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reply = sendSynchronousCommand(SYNC_CMD_READ,fd,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (sdslen(reply) == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 为了保活，master 可能在收到 PSYNC 后且回复前发送空行</span></span><br><span class="line">  sdsfree(reply);</span><br><span class="line">  <span class="keyword">return</span> PSYNC_WAIT_REPLY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 删除 fd 可读事件，方便后面为 f'd重新注册新的回调 */</span></span><br><span class="line">aeDeleteFileEvent(server.el,fd,AE_READABLE);</span><br></pre></td></tr></table></figure><p>【1】<code>+FULLRESYNC</code> 回复表示不能进行部分重同步，slave 告诉给 master 的 offset 不在 master 的复制积压缓冲区范围内，只能进行完全重同步，返回给上层函数 <strong>PSYNC_FULLRESYNC</strong>，代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 完全重同步得到 response 为 +FULLRESYNC &lt;master_runid&gt; &lt;offset&gt; */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(reply,<span class="string">"+FULLRESYNC"</span>,<span class="number">11</span>)) &#123;</span><br><span class="line">    <span class="keyword">char</span> *runid = <span class="literal">NULL</span>, *offset = <span class="literal">NULL</span>;</span><br><span class="line">    runid = <span class="built_in">strchr</span>(reply,<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">if</span> (runid) &#123;</span><br><span class="line">        runid++;</span><br><span class="line">        offset = <span class="built_in">strchr</span>(runid,<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span> (offset) offset++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 有可能是 master 发送格式有问题，先把 repl_master_runid 置空 */</span></span><br><span class="line">    <span class="keyword">if</span> (!runid || !offset || (offset-runid<span class="number">-1</span>) != CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">"Master replied with wrong +FULLRESYNC syntax."</span>);</span><br><span class="line">        <span class="built_in">memset</span>(server.repl_master_runid,<span class="number">0</span>,CONFIG_RUN_ID_SIZE+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(server.repl_master_runid, runid, offset-runid<span class="number">-1</span>);</span><br><span class="line">        server.repl_master_runid[CONFIG_RUN_ID_SIZE] = <span class="string">'\0'</span>;</span><br><span class="line">        server.repl_master_initial_offset = strtoll(offset,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Full resync from master: %s:%lld"</span>,</span><br><span class="line">                  server.repl_master_runid,</span><br><span class="line">                  server.repl_master_initial_offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We are going to full resync, discard the cached master structure. */</span></span><br><span class="line">    replicationDiscardCachedMaster();</span><br><span class="line">    sdsfree(reply);</span><br><span class="line">    <span class="keyword">return</span> PSYNC_FULLRESYNC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码解析出 master 的 runid，以及 offset，分别赋值给 <code>repl_master_runid</code> 和 <code>repl_master_initial_offset</code>。因为要进行全同步，<code>cached_master</code> 保存的信息就失效了，需要重置，即函数 <code>replicationDiscardCachedMaster</code> 的调用。</p><p>【2】<code>+CONTINUE</code> 表示可以进行部分重同步，返回给上层函数 <strong>PSYNC_CONTINUE</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(reply,<span class="string">"+CONTINUE"</span>,<span class="number">9</span>)) &#123;</span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">              <span class="string">"Successful partial resynchronization with master."</span>);</span><br><span class="line">    sdsfree(reply);</span><br><span class="line">    replicationResurrectCachedMaster(fd);</span><br><span class="line">    <span class="keyword">return</span> PSYNC_CONTINUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationResurrectCachedMaster</span><span class="params">(<span class="keyword">int</span> newfd)</span> </span>&#123;</span><br><span class="line">    server.master = server.cached_master;</span><br><span class="line">    server.cached_master = <span class="literal">NULL</span>;</span><br><span class="line">    server.master-&gt;fd = newfd;</span><br><span class="line">    server.master-&gt;flags &amp;= ~(CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP);</span><br><span class="line">    server.master-&gt;authenticated = <span class="number">1</span>;</span><br><span class="line">    server.master-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    server.repl_state = REPL_STATE_CONNECTED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Re-add to the list of clients. */</span></span><br><span class="line">    listAddNodeTail(server.clients,server.master);</span><br><span class="line">    <span class="keyword">if</span> (aeCreateFileEvent(server.el, newfd, AE_READABLE,</span><br><span class="line">                          readQueryFromClient, server.master)) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Error resurrecting the cached master, impossible to add the readable handler: %s"</span>, strerror(errno));</span><br><span class="line">        freeClientAsync(server.master); <span class="comment">/* Close ASAP. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clientHasPendingReplies(server.master)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, newfd, AE_WRITABLE,</span><br><span class="line">                          sendReplyToClient, server.master)) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"Error resurrecting the cached master, impossible to add the writable handler: %s"</span>, strerror(errno));</span><br><span class="line">            freeClientAsync(server.master); <span class="comment">/* Close ASAP. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，从 <code>cached_master</code> 恢复 master，将状态机置为 <strong>REPL_STATE_CONNECTED</strong>。<br>为 fd 的读事件注册新的回调函数 readQueryFromClient。<br>如果在<code>server.master</code> 上仍然有 reply，或者是在写 buffer 里有数据，那么需要为写事件注册回调函数 <code>sendReplyToClient</code>。</p><p>【3】<code>-ERR</code> 的情况。需要清理现有的 <code>cached_master</code>，返回给上层函数 <strong>PSYNC_NOT_SUPPORTED</strong> 。</p><p>回到 <strong>syncWithMaster</strong> 函数里，处理 PSYNC 命令的返回值。<br>当返回的是 <strong>PSYNC_CONTINUE</strong> 时，表示进行的是部分重同步，该函数结束。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_CONTINUE) &#123; <span class="comment">/* 部分重同步 ，不会走到下面接收 rdb 的流程 */</span></span><br><span class="line">  serverLog(LL_NOTICE, <span class="string">"MASTER &lt;-&gt; SLAVE sync: Master accepted a Partial Resynchronization."</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则，有两种可能，进行完全重同步，或者 master 不支持 PSYNC 命令(老版本的 master)，但是无论如何都需要断开现有的所有 slave，因为新 master 可能会传过来一份不同的数据。<br>同时清空复制积压缓冲区，即 repl_backlog，不允许我的 slave 做 psync 了（<strong>毕竟数据不同了嘛</strong>）。</p><p>如果新 master 不支持 PSYNC 命令，那么同步发送 SYNC 命令。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_NOT_SUPPORTED) &#123;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"Retrying with SYNC..."</span>);</span><br><span class="line">    <span class="keyword">if</span> (syncWrite(fd,<span class="string">"SYNC\r\n"</span>,<span class="number">6</span>,server.repl_syncio_timeout*<span class="number">1000</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"I/O error writing to MASTER: %s"</span>,</span><br><span class="line">                  strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有出错，接下来准备完全重同步阶段 master 发过来的 rdb 数据。创建一个名字以 tmp 为前缀的临时 rdb 接收文件，打开，并记录 fd，最多 5 次，要是还不能成功创建一个临时文件，那么就走错误处理的流程了。代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(maxtries--) &#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,</span><br><span class="line">             <span class="string">"temp-%d.%ld.rdb"</span>,(<span class="keyword">int</span>)server.unixtime,(<span class="keyword">long</span> <span class="keyword">int</span>)getpid());</span><br><span class="line">    dfd = <span class="built_in">open</span>(tmpfile,O_CREAT|O_WRONLY|O_EXCL,<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (dfd != <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dfd == <span class="number">-1</span>) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Opening the temp file needed for MASTER &lt;-&gt; SLAVE synchronization: %s"</span>,strerror(errno));</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着为 fd 的读事件注册回调函数 <code>readSyncBulkPayload</code>，用来处理从 master 读到的数据 rdb 文件。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 为 fd 的可读事件注册新的函数 readSyncBulkPayload */</span></span><br><span class="line"><span class="keyword">if</span> (aeCreateFileEvent(server.el,fd, AE_READABLE,readSyncBulkPayload,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">&#123;</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">              <span class="string">"Can't create readable event for SYNC: %s (fd=%d)"</span>,</span><br><span class="line">              strerror(errno),fd);</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是一些 server 变量的赋值。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server.repl_state = REPL_STATE_TRANSFER;</span><br><span class="line"><span class="comment">/* 初始化 RDB 文件大小 */</span></span><br><span class="line">server.repl_transfer_size = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">/* 已读数据大小 */</span></span><br><span class="line">server.repl_transfer_read = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 最近一次执行的 fsync 偏移量 */</span></span><br><span class="line">server.repl_transfer_last_fsync_off = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 本地临时 rdb 文件的 fd */</span></span><br><span class="line">server.repl_transfer_fd = dfd;</span><br><span class="line"><span class="comment">/* 最近一次读数据的时间 */</span></span><br><span class="line">server.repl_transfer_lastio = server.unixtime;</span><br><span class="line"><span class="comment">/* 本地临时 rdb 文件的名字 */</span></span><br><span class="line">server.repl_transfer_tmpfile = zstrdup(tmpfile);</span><br></pre></td></tr></table></figure><p>状态机置为 <strong>REPL_STATE_TRANSFER</strong>，<code>repl_transfer_fd</code> 记录 rdb 临时文件的 fd。</p><h4 id="几个超时保证"><a href="#几个超时保证" class="headerlink" title="几个超时保证"></a>几个超时保证</h4><p>在 <strong>replicationCron</strong> 函数中的开始部分，有一些超时保证。</p><p>与 master 建立连接后，一直没能发 PING，说明连接可能有问题。<br>在鉴权和确认capa 的流程中，花了过多的时间。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp;</span><br><span class="line">    (server.repl_state == REPL_STATE_CONNECTING ||  slaveIsInHandshakeState()) &amp;&amp;</span><br><span class="line">        (time(<span class="literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout) <span class="comment">// 默认 60s 超时</span></span><br><span class="line">&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Timeout connecting to the MASTER..."</span>);</span><br><span class="line">    cancelReplicationHandshake();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slaveIsInHandshakeState</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> server.repl_state &gt;= REPL_STATE_RECEIVE_PONG &amp;&amp;</span><br><span class="line">        server.repl_state &lt;= REPL_STATE_RECEIVE_PSYNC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收 rdb 文件的时长做限制。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Bulk transfer I/O timeout? */</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_TRANSFER &amp;&amp;</span><br><span class="line">    (time(<span class="literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout) <span class="comment">// 默认 60s 超时</span></span><br><span class="line">&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Timeout receiving bulk data from MASTER... If the problem persists try to set the 'repl-timeout' parameter in redis.conf to a larger value."</span>);</span><br><span class="line">    cancelReplicationHandshake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成为 slave 以后，没有数据发过来。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* Timed out master when we are an already connected slave? */</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_CONNECTED &amp;&amp;</span><br><span class="line">    (time(<span class="literal">NULL</span>)-server.master-&gt;lastinteraction) &gt; server.repl_timeout)</span><br><span class="line">&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"MASTER timeout: no data nor PING received..."</span>);</span><br><span class="line">    freeClient(server.master);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收-RDB-文件"><a href="#接收-RDB-文件" class="headerlink" title="接收 RDB 文件"></a>接收 RDB 文件</h3><p>接收 rdb 数据有两种方式，一种是磁盘化的，一种是无磁盘化的。</p><blockquote><p> 从 V2.8.18 开始，redis 引入了“无硬盘复制”选项，开启该选项时，redis 在与 slave 进行复制初始化时将不会将快照内容存储到硬盘上，而是直接通过网络发送给slave，避免了硬盘的性能瓶颈，可以在配置文件中使用 <strong>repl-diskless-sync</strong> 选项来配置开启该功能。</p></blockquote><p>两种方式发送的数据格式是不一样的。<br>磁盘化复制时，master 先生成 rdb 文件，然后将文件内容加上 <code>$&lt;len&gt;/r/n</code> 的头部后，发送给 slave。<br>而无磁盘化复制时，master 直接把 rdb 数据发送给你 slave 时，以 <code>$EOF:&lt;XXX&gt;\r\n</code> 开头，并以 <code>&lt;XXX&gt;</code> 结尾，开头和结尾的 <code>&lt;XXX&gt;</code> 内容相同，都是 40 个字节，是由 <strong>0123456789abcdef</strong> 中的字符组成的随机字符串，为了校验数据的是否发送完成。</p><p>该流程主要是回调函数 <code>readSyncBulkPayload</code> 中的逻辑。<br>首先读取 master 传过来的辅助信息。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_transfer_size == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 第一行内容 $&lt;len&gt;/r/n */</span></span><br><span class="line">    <span class="keyword">if</span> (syncReadLine(fd,buf,<span class="number">1024</span>,server.repl_syncio_timeout*<span class="number">1000</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">"I/O error reading bulk count from MASTER: %s"</span>,</span><br><span class="line">                  strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">"MASTER aborted replication with an error: %s"</span>,</span><br><span class="line">                  buf+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">        server.repl_transfer_lastio = server.unixtime;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">'$'</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Bad protocol from MASTER, the first byte is not '$' (we received '%s'), are you sure the host and port are right?"</span>, buf);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 有两种可能的 bulk payload 格式，正常的是 $&lt;count&gt;</span></span><br><span class="line"><span class="comment">   * 还有一种可能就是无磁盘化主从同步时，因为这个时候不知道后面要传输数据的长度，因此会发送一个分隔符，</span></span><br><span class="line"><span class="comment">   * 格式为 $EOF:&lt;40 bytes delimiter&gt;</span></span><br><span class="line"><span class="comment">   * 在发送完 rdb 数据后，分隔符会再次被发送，以便让接收端知道数据发送完成了。</span></span><br><span class="line"><span class="comment">   * 分隔符足够的长和随机，因此真实文件内容碰撞的可能性可以被忽略。*/</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf+<span class="number">1</span>,<span class="string">"EOF:"</span>,<span class="number">4</span>) == <span class="number">0</span> &amp;&amp; <span class="built_in">strlen</span>(buf+<span class="number">5</span>) &gt;= CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">      usemark = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">memcpy</span>(eofmark,buf+<span class="number">5</span>,CONFIG_RUN_ID_SIZE);</span><br><span class="line">      <span class="built_in">memset</span>(lastbytes,<span class="number">0</span>,CONFIG_RUN_ID_SIZE);</span><br><span class="line">      server.repl_transfer_size = <span class="number">0</span>;</span><br><span class="line">      serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"MASTER &lt;-&gt; SLAVE sync: receiving streamed RDB from master"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      usemark = <span class="number">0</span>;</span><br><span class="line">      server.repl_transfer_size = strtol(buf+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">      serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"MASTER &lt;-&gt; SLAVE sync: receiving %lld bytes from master"</span>,</span><br><span class="line">                (<span class="keyword">long</span> <span class="keyword">long</span>) server.repl_transfer_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步读取第一行内容，当开启了无磁盘化同步时，有一点需要注意，保存完 eofmark 后，要把 <code>repl_transfer_size</code> 变量置为一个非 -1 的值，防止下次事件触发后又进到这个逻辑里来了。而正常同步时，可以读到 <code>repl_transfer_size</code> 的大小。<br>通过 <code>usemark</code> 来标记同步类型，值为 1 表示无磁盘化的同步，值为 0 表示磁盘化同步。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Read bulk data */</span></span><br><span class="line"><span class="keyword">if</span> (usemark) &#123;</span><br><span class="line">    readlen = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    left = server.repl_transfer_size - server.repl_transfer_read;</span><br><span class="line">    readlen = (left &lt; (<span class="keyword">signed</span>)<span class="keyword">sizeof</span>(buf)) ? left : (<span class="keyword">signed</span>)<span class="keyword">sizeof</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上逻辑来调整每次从 socket 中读取数据的长度，因为 usemark 时，不知道要读取的数据总长度。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nread = <span class="built_in">read</span>(fd,buf,readlen);</span><br><span class="line"><span class="keyword">if</span> (nread &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"I/O error trying to sync with MASTER: %s"</span>,</span><br><span class="line">              (nread == <span class="number">-1</span>) ? strerror(errno) : <span class="string">"connection lost"</span>);</span><br><span class="line">    cancelReplicationHandshake();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算出 readlen 后，读取数据，如果读错了，要断开连接，清理 fd ，重置同步状态等，<code>cancelReplicationHandshake</code> 的逻辑在上面已经说过。<br>如果是 usemark，那么需要校验 eofmark，以便知道数据是否已经读完。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> eof_reached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (usemark) &#123;</span><br><span class="line">    <span class="comment">/* Update the last bytes array, and check if it matches our delimiter.*/</span></span><br><span class="line">    <span class="keyword">if</span> (nread &gt;= CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(lastbytes,buf+nread-CONFIG_RUN_ID_SIZE,CONFIG_RUN_ID_SIZE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> rem = CONFIG_RUN_ID_SIZE-nread;</span><br><span class="line">        memmove(lastbytes,lastbytes+nread,rem);</span><br><span class="line">        <span class="built_in">memcpy</span>(lastbytes+rem,buf,nread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 读到 EOF 了 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(lastbytes,eofmark,CONFIG_RUN_ID_SIZE) == <span class="number">0</span>) eof_reached = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果读到的数据长度 &gt;= 40，那么截取 buf 最后 40 个字符。否则使用 <code>memmove</code> 和 <code>memcpy</code> 将最后的 40 个字节填满，这部分操作有点绕，画了个图帮助理解，</p><p><img src="http://ww1.sinaimg.cn/large/71ca8e3cly1g5w95590gbj20h60873z7.jpg" alt="lastbytes"></p><p>然后根据前面记录 eofmark 去判断是不是数据接收结束了，如果是，<code>eof_reached</code> 置为 1。<br>读完一次数据需要将其写入本地的临时 rdb 文件里，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">write</span>(server.repl_transfer_fd,buf,nread) != nread) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Write error or short write writing to the DB dump file needed for MASTER &lt;-&gt; SLAVE synchronization: %s"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line">server.repl_transfer_read += nread; <span class="comment">// 更新读了多少数据量</span></span><br></pre></td></tr></table></figure><p>如果是已经读到末尾了，那么需要从文件中删掉 eofmark，因为它不是 rdb 数据嘛，只是个辅助标识。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (usemark &amp;&amp; eof_reached) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ftruncate(server.repl_transfer_fd,</span><br><span class="line">                  server.repl_transfer_read - CONFIG_RUN_ID_SIZE) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Error truncating the RDB file received from the master for SYNC: %s"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>光是 <code>write</code> 了还不够，这只是写到了系统的 cache，还需要做 <code>fsync</code> 将数据落盘。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_transfer_read &gt;=</span><br><span class="line">    server.repl_transfer_last_fsync_off + REPL_MAX_WRITTEN_BEFORE_FSYNC)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">off_t</span> sync_size = server.repl_transfer_read -</span><br><span class="line">      server.repl_transfer_last_fsync_off;</span><br><span class="line">    rdb_fsync_range(server.repl_transfer_fd,</span><br><span class="line">                    server.repl_transfer_last_fsync_off, sync_size);</span><br><span class="line">    server.repl_transfer_last_fsync_off += sync_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刷盘策略是每 8M 一次。<br>如果不是无磁盘化的主从同步，就要依赖于接收到的数据 size 与第一次传过来的值作比较。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!usemark) &#123;</span><br><span class="line">    <span class="keyword">if</span> (server.repl_transfer_read == server.repl_transfer_size)</span><br><span class="line">        eof_reached = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果完全接收完数据了了，那么需要做一些善后工作，如下代码，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (eof_reached) &#123;....&#125;</span><br></pre></td></tr></table></figure><p>首先，把本地 rdb 文件的名字改成配置文件里配置的名字<code>server.rdb_filename</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (rename(server.repl_transfer_tmpfile,server.rdb_filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Failed trying to rename the temp DB into dump.rdb in MASTER &lt;-&gt; SLAVE 				synchronization: %s"</span>, strerror(errno));</span><br><span class="line">    cancelReplicationHandshake();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要为加载新的 rdb 文件做一些准备。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signalFlushedDb(<span class="number">-1</span>); <span class="comment">// 使得本实例的所有客户端感知到接下来要清空数据库</span></span><br><span class="line">emptyDb(replicationEmptyDbCallback); <span class="comment">// 清空所有数据，给 master 发一个 \n</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">emptyDb</span><span class="params">(<span class="keyword">void</span>(callback)(<span class="keyword">void</span>*))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> removed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">        removed += dictSize(server.db[j].dict);</span><br><span class="line">        dictEmpty(server.db[j].dict,callback);</span><br><span class="line">        dictEmpty(server.db[j].expires,callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) slotToKeyFlush();</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Callback used by emptyDb() while flushing away old data to load</span></span><br><span class="line"><span class="comment"> * the new dataset received by the master. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationEmptyDbCallback</span><span class="params">(<span class="keyword">void</span> *privdata)</span> </span>&#123;</span><br><span class="line">    UNUSED(privdata);</span><br><span class="line">    replicationSendNewlineToMaster();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给 master 发 \n 表明自己还活着，在加载数据 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationSendNewlineToMaster</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">time_t</span> newline_sent;</span><br><span class="line">    <span class="keyword">if</span> (time(<span class="literal">NULL</span>) != newline_sent) &#123;</span><br><span class="line">        newline_sent = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(server.repl_transfer_s,<span class="string">"\n"</span>,<span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">/* Pinging back in this stage is best-effort. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空老数据完老数据，下面开始加载新数据。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">aeDeleteFileEvent(server.el,server.repl_transfer_s,AE_READABLE);</span><br><span class="line">serverLog(LL_NOTICE, <span class="string">"MASTER &lt;-&gt; SLAVE sync: Loading DB in memory"</span>);</span><br><span class="line"><span class="keyword">if</span> (rdbLoad(server.rdb_filename) != C_OK) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Failed trying to load the MASTER synchronization DB from disk"</span>);</span><br><span class="line">    cancelReplicationHandshake();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在加载新数据之前，需要先删除socket fd 的可读事件，这是因为在调用 <code>rdbLoad</code> 加载 rdb 数据时，每次调用<code>rioRead</code> 都会因为要计算 checksum 而调用 <code>processEventsWhileBlocked</code> 处理当前已触发的事件，如果不删除该可读事件的话，就会递归进入的本函数中（因此，slave 在加载 rdb 数据时，是不能处理主节点发来的其他数据的）。<br>然后做一些清理工作。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">zfree(server.repl_transfer_tmpfile);</span><br><span class="line"><span class="built_in">close</span>(server.repl_transfer_fd);</span><br></pre></td></tr></table></figure><p>根据 socket fd 创建一个 master 的 client。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* 创建 master 相关的变量 */</span></span><br><span class="line">replicationCreateMasterClient(server.repl_transfer_s);</span><br></pre></td></tr></table></figure><p>然后可以看下这个 <code>replicationCreateMasterClient</code> 这个函数都干了些什么事情。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationCreateMasterClient</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    server.master = createClient(fd);</span><br><span class="line">    server.master-&gt;flags |= CLIENT_MASTER;</span><br><span class="line">    server.master-&gt;authenticated = <span class="number">1</span>;</span><br><span class="line">    server.repl_state = REPL_STATE_CONNECTED;</span><br><span class="line">    server.master-&gt;reploff = server.repl_master_initial_offset;</span><br><span class="line">    <span class="built_in">memcpy</span>(server.master-&gt;replrunid, server.repl_master_runid,</span><br><span class="line">        <span class="keyword">sizeof</span>(server.repl_master_runid));</span><br><span class="line">    <span class="keyword">if</span> (server.master-&gt;reploff == <span class="number">-1</span>)</span><br><span class="line">        server.master-&gt;flags |= CLIENT_PRE_PSYNC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意一点，如果 master 不支持 PSYNC 的话，那么 salve 不会得到 <code>+FULLRESYNC</code> 的回复，也就不会更新 <code>server.repl_master_initial_offset</code> 变量，它就一直是 -1，在这里创建 master client 时，会给它一个标记 <strong>CLIENT_PRE_PSYNC</strong>。</p><p>这里会把状态机更新为 <strong>REPL_STATE_CONNECTED</strong>。<br>最后，如果 aof 功能没有关闭的话，需要重新生成 aof 文件，因为数据已经改变了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.aof_state != AOF_OFF) &#123;</span><br><span class="line">    <span class="keyword">int</span> retry = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    stopAppendOnly();</span><br><span class="line">    <span class="keyword">while</span> (retry-- &amp;&amp; startAppendOnly() == C_ERR) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Failed enabling the AOF after successful master synchronization! 							Trying it again in one second."</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!retry) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"FATAL: this slave instance finished the synchronization with its 							master, but the AOF can't be turned on. Exiting now."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，<code>readSyncBulkPayload</code> 函数读取并加载新 rdb 文件的流程就走完了。</p><p>当复制状态变为 <strong>REPL_STATE_CONNECTED</strong> 后，表示进入了命令传播阶段。后续 slave 将 master 当成一个客户端，并接收其发来的命令请求，像处理普通客户端一样处理即可。命令传播在前面的博客已经详细讲过。</p><h3 id="探活机制"><a href="#探活机制" class="headerlink" title="探活机制"></a>探活机制</h3><p>在 master-slave 连接建立以后，他们就通过心跳进行相互探活，这些机制都在 <code>replicationCron</code> 函数里。</p><h4 id="master-探活"><a href="#master-探活" class="headerlink" title="master 探活"></a>master 探活</h4><p>master 会定期给它所有的 slave 发送 PING。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((replication_cron_loops % server.repl_ping_slave_period) == <span class="number">0</span>) &#123;</span><br><span class="line">    ping_argv[<span class="number">0</span>] = createStringObject(<span class="string">"PING"</span>,<span class="number">4</span>);</span><br><span class="line">    replicationFeedSlaves(server.slaves, server.slaveseldb,</span><br><span class="line">                          ping_argv, <span class="number">1</span>);</span><br><span class="line">    decrRefCount(ping_argv[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给 slave 发送命令是通过 <code>replicationFeedSlaves</code> 函数实现的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationFeedSlaves</span><span class="params">(<span class="built_in">list</span> *slaves, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123;....&#125;</span><br></pre></td></tr></table></figure><p>下面看一下该函数的详细实现。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_backlog == <span class="literal">NULL</span> &amp;&amp; listLength(slaves) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>如果 <code>repl_backlog</code> 为空，或者是没有 slave，那么这个过程是不必要的，直接返回。必要的时候生成 SELECT 命令，告知 slave 切换数据库。<code>slaveseldb</code> 中保存的是上一次 replication 输出时选择的数据库。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_backlog) &#123;</span><br><span class="line">    <span class="keyword">char</span> aux[LONG_STR_SIZE+<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add the multi bulk reply length. */</span></span><br><span class="line">    aux[<span class="number">0</span>] = <span class="string">'*'</span>;</span><br><span class="line">    len = ll2string(aux+<span class="number">1</span>,<span class="keyword">sizeof</span>(aux)<span class="number">-1</span>,argc);</span><br><span class="line">    aux[len+<span class="number">1</span>] = <span class="string">'\r'</span>;</span><br><span class="line">    aux[len+<span class="number">2</span>] = <span class="string">'\n'</span>;</span><br><span class="line">    feedReplicationBacklog(aux,len+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        <span class="keyword">long</span> objlen = stringObjectLen(argv[j]);</span><br><span class="line">        aux[<span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">        len = ll2string(aux+<span class="number">1</span>,<span class="keyword">sizeof</span>(aux)<span class="number">-1</span>,objlen);</span><br><span class="line">        aux[len+<span class="number">1</span>] = <span class="string">'\r'</span>;</span><br><span class="line">        aux[len+<span class="number">2</span>] = <span class="string">'\n'</span>;</span><br><span class="line">        feedReplicationBacklog(aux,len+<span class="number">3</span>);</span><br><span class="line">        feedReplicationBacklogWithObject(argv[j]);</span><br><span class="line">        feedReplicationBacklog(aux+len+<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>repl_backlog</code> 不为空，那么组装 redis 协议的命令，这里是 <code>*1\r\n$4\r\nPING</code>，放到 <code>repl_backlog</code> 变量里。</p><h4 id="slave-探活"><a href="#slave-探活" class="headerlink" title="slave 探活"></a>slave 探活</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.master &amp;&amp;</span><br><span class="line">          !(server.master-&gt;flags &amp; CLIENT_PRE_PSYNC)) &#123;</span><br><span class="line">      	replicationSendAck();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationSendAck</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    client *c = server.master;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        c-&gt;flags |= CLIENT_MASTER_FORCE_REPLY;</span><br><span class="line">        addReplyMultiBulkLen(c,<span class="number">3</span>);</span><br><span class="line">        addReplyBulkCString(c,<span class="string">"REPLCONF"</span>);</span><br><span class="line">        addReplyBulkCString(c,<span class="string">"ACK"</span>);</span><br><span class="line">        addReplyBulkLongLong(c,c-&gt;reploff);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_MASTER_FORCE_REPLY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于非老版本的 master，slave 向它定期发送 <code>REPLCONF ACK &lt;offset&gt;</code> 命令，以便告诉它复制偏移量。</p><h2 id="cluster-模式"><a href="#cluster-模式" class="headerlink" title="cluster 模式"></a>cluster 模式</h2><p>cluster 模式下，使用 <code>CLUSTER REPLICATE &lt;NODE ID&gt;</code> 命令来进行新的主从关系的构建。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"replicate"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">/* CLUSTER REPLICATE &lt;NODE ID&gt; */</span></span><br><span class="line">        clusterNode *n = clusterLookupNode(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Lookup the specified node in our table. */</span></span><br><span class="line">        <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">            addReplyErrorFormat(c,<span class="string">"Unknown node %s"</span>, (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* I can't replicate myself. */</span></span><br><span class="line">        <span class="keyword">if</span> (n == myself) &#123;</span><br><span class="line">            addReplyError(c,<span class="string">"Can't replicate myself"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Can't replicate a slave. */</span></span><br><span class="line">        <span class="keyword">if</span> (nodeIsSlave(n)) &#123;</span><br><span class="line">            addReplyError(c,<span class="string">"I can only replicate a master, not a slave."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 我要做别人的 slave， 那么不是不能够有 slots 和数据库数据的</span></span><br><span class="line">        <span class="keyword">if</span> (nodeIsMaster(myself) &amp;&amp;</span><br><span class="line">            (myself-&gt;numslots != <span class="number">0</span> || dictSize(server.db[<span class="number">0</span>].dict) != <span class="number">0</span>)) &#123;</span><br><span class="line">            addReplyError(c,</span><br><span class="line">                <span class="string">"To set a master the node must be empty and "</span></span><br><span class="line">                <span class="string">"without assigned slots."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set the master. */</span></span><br><span class="line">        clusterSetMaster(n);</span><br><span class="line">        clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);</span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>很重要的一个检查</strong>是，有 slot 或者有数据的 master 节点，不能做此操作，防止丢数据。<br>跳过一些合理性检查，重点函数就是 <code>clusterSetMaster</code> 了，那么它做了什么呢？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterSetMaster</span><span class="params">(clusterNode *n)</span> </span>&#123;</span><br><span class="line">    serverAssert(n != myself);</span><br><span class="line">    serverAssert(myself-&gt;numslots == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nodeIsMaster(myself)) &#123;</span><br><span class="line">        myself-&gt;flags &amp;= ~(CLUSTER_NODE_MASTER|CLUSTER_NODE_MIGRATE_TO);</span><br><span class="line">        myself-&gt;flags |= CLUSTER_NODE_SLAVE;</span><br><span class="line">        clusterCloseAllSlots();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (myself-&gt;slaveof)</span><br><span class="line">            clusterNodeRemoveSlave(myself-&gt;slaveof,myself); <span class="comment">// 解除原有的主从关系</span></span><br><span class="line">    &#125;</span><br><span class="line">    myself-&gt;slaveof = n;</span><br><span class="line">    clusterNodeAddSlave(n,myself);</span><br><span class="line">    replicationSetMaster(n-&gt;ip, n-&gt;port);</span><br><span class="line">    resetManualFailover();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，如果本身是个 master，那么取消掉 master 和 migrating 的 flag，因为该 master 没有数据，可以大胆地取消迁移的叫标记，然后加上 slave 的标记 <strong>CLUSTER_NODE_SLAVE</strong>。<br>如果原本就是个 slave 节点，那么调整自己的主从归属信息，置空以手动主从切换有关的变量值，关于 cluster mf 的逻辑以后会专门去讨论。<br>然后就是前面说过的 <code>replicationSetMaster</code> 函数，触发上也是在 cron 里，就不啰嗦了。</p><p>以上，主从复制中，slave 的逻辑就介绍完了。</p></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="social-share" data-disabled="google,facebook,qzone,twitter,diandian,linkedin,qzone,tencent"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/9025979a.html"><i class="fa fa-chevron-left"></i><span>Redis源码之主从复制(4)</span></a></div><div class="next-post pull-right"><a href="/8f9133db.html"><span>Redis 源码之主从复制(2)</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script>!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script></div></div></div><footer class="footer-bg" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;&nbsp;2016 - 2019 By Happen</div><div class="framework-info"><span>Powered by</span> <a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>