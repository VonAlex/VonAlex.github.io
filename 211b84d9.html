<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="irqbalance 详解之一"><meta name="keywords" content="shell"><meta name="author" content="Happen"><meta name="copyright" content="Happen"><title>irqbalance 详解之一 | Happen's Memo</title><link rel="shortcut icon" href="/images/dolphin.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?882b48640075e00a238ae94a7eec0d40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,c,g,o){e.GoogleAnalyticsObject=c,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,g=a.createElement(t),o=a.getElementsByTagName(t)[0],g.async=1,g.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(g,o)}(window,document,"script",0,"ga"),ga("create","RRBput3V2WYVZd2lq058Z4IwJEhViOwuMElqkWh6bcA","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前置知识"><span class="toc-number">1.</span> <span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#中断"><span class="toc-number">1.1.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NUMA架构"><span class="toc-number">1.2.</span> <span class="toc-text">NUMA架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-相关"><span class="toc-number">1.3.</span> <span class="toc-text">CPU 相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#irq-亲缘绑定"><span class="toc-number">1.4.</span> <span class="toc-text">irq 亲缘绑定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#irqbalance-代码分析"><span class="toc-number">2.</span> <span class="toc-text">irqbalance 代码分析</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.png"></div><div class="author-info__name text-center">Happen</div><div class="author-info__description text-center">浮生若梦，为欢几何</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">37</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://renrenlove.me/" target="_blank" rel="noopener">Galway</a><a class="author-info-links__name text-center" href="http://kvguru.com/" target="_blank" rel="noopener">Wangbin</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div id="page-header"> <span class="pull-left"><a id="site-name" href="/">Happen's Memo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">irqbalance 详解之一</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-06-29</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/linux/">linux</a><div class="post-meta-wordcount"><span>字数总计:</span> <span class="word-count">2.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 9 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>irqbalance 是什么？<a href="https://github.com/Irqbalance/irqbalance" target="_blank" rel="noopener">项目主页</a>上有以下描述：</p><blockquote><p>Irqbalance is a daemon to help balance the cpu load generated by interrupts across all of a systems cpus.</p></blockquote><a id="more"></a><p>它避免了单 cpu 负载过重情况的出现。用法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@a7661ef9b2f8 test]# irqbalance -h</span><br><span class="line">irqbalance: option requires an argument -- &apos;h&apos;</span><br><span class="line">irqbalance [--oneshot | -o] [--debug | -d] [--foreground | -f] [--hintpolicy= | -h [exact|subset|ignore]] [--banscript= | -b &lt;script&gt;]</span><br><span class="line">true[--powerthresh= | -p &lt;off&gt; | &lt;n&gt;] [--banirq= | -i &lt;n&gt;] [--policyscript= | -l &lt;script&gt;] [--pid= | -s &lt;file&gt;] [--deepestcache= | -c &lt;n&gt;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看当前运行情况</span><br><span class="line">service irqbalance status</span><br><span class="line"></span><br><span class="line"># 终止服务</span><br><span class="line">service irqbalance stop</span><br></pre></td></tr></table></figure><hr><p>首先有一些前置知识需要说明，这涉及到 irqbalance cputree 的分层。</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>每个硬件设备都需要和 CPU 有某种形式的通信以便 CPU 及时知道发生了什么，这样 CPU 可能就会放下手中的事情去处理应急事件，硬件设备主动打扰 CPU 的现象就可称为硬件中断。就像正在一心一意的写代码时，突然钉钉“噔噔”地响起来，这时我们就知道有事情需要处理，这里的“噔噔”声就可以理解成一次中断。<br>CPU 和硬件沟通的方式中，还有一种叫做轮询（polling），就是让 CPU 定时对硬件状态进行查询然后做相应处理，这比较浪费 CPU，属于一种硬件被动的方式。相比下来，硬件主动的方式（中断）更有效一些。<br>那每个硬件设备都有中断，很简单啊，给它们分个唯一的号码，也就是 irq 号，在 <code>/proc/interrupts</code> 文件中的第一列可以看到所有的irq。<br>只有 kernel 2.4 以后的版本才支持的把不同的硬件中断请求（IRQs）分配到特定的 CPU 上的绑定技术被称为 SMP IRQ Affinity，这个后面还会详细说。</p><h4 id="NUMA架构"><a href="#NUMA架构" class="headerlink" title="NUMA架构"></a>NUMA架构</h4><p>简要介绍一下 NUMA 架构。<br>NUMA 架构出现前，CPU 频率一路欢脱越来越高，直至碰到物理极限的天花板，后转向核数越来越多的方向发展。</p><blockquote><p>如果每个 core 的工作性质都是 share-nothing（类似于map-reduce的node节点的作业属性），那么也许就不会有NUMA。由于所有CPU Core都是通过共享一个北桥来读取内存，随着核数如何的发展，<strong>北桥</strong> 在响应时间上的性能瓶颈越来越明显。于是，聪明的硬件设计师们，先到了把内存控制器（原本北桥中读取内存的部分）也做个拆分，平分到了每个die上。于是 NUMA 就出现了！<br>NUMA 架构中，内存访问有远近之分，只有当 CPU 访问自身直接 attach 内存对应的物理地址时，才会有较短的响应时间（Local Access）。而如果需要访问其他 CPU attach 的内存的数据时，就需要通过 inter-connect 通道访问，响应时间就相比之前变慢了（Remote Access），NUMA（Non-Uniform Memory Access）就此得名。 — 引自 <a href="http://cenalulu.github.io/linux/numa/" target="_blank" rel="noopener">http://cenalulu.github.io/linux/numa/</a></p></blockquote><p>图画下来大概是下面这个样子：<br><img src="https://s1.ax1x.com/2018/10/28/icwcV0.jpg" width="600"></p><p><code>numactl --hardware</code> 命令可以查看的那个机器的 numa 拓扑，比如这台机器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@d2b9eb755bb1 ~]# numactl --hardware</span><br><span class="line">available: 2 nodes (0-1)</span><br><span class="line">node 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 24 25 26 27 28 29 30 31 32 33 34 35</span><br><span class="line">node 0 size: 130946 MB</span><br><span class="line">node 0 free: 9892 MB</span><br><span class="line">node 1 cpus: 12 13 14 15 16 17 18 19 20 21 22 23 36 37 38 39 40 41 42 43 44 45 46 47</span><br><span class="line">node 1 size: 131072 MB</span><br><span class="line">node 1 free: 35969 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0   1</span><br><span class="line">  0:  10  21</span><br><span class="line">  1:  21  10</span><br></pre></td></tr></table></figure><p>或者用这个脚本也行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@d2b9eb755bb1 ~]# for i in `ls /sys/devices/system/node | grep node`;do echo -ne &quot;$i\t&quot;;cat /sys/devices/system/node/$i/cpulist;done</span><br><span class="line">node0	0-11,24-35</span><br><span class="line">node1	12-23,36-47</span><br></pre></td></tr></table></figure><p>或者用 <code>lscpu</code> 这个命令，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@d2b9eb755bb1 ~]# lscpu</span><br><span class="line">Architecture:          x86_64</span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                48</span><br><span class="line">On-line CPU(s) list:   0-47</span><br><span class="line">Thread(s) per core:    2</span><br><span class="line">Core(s) per socket:    12</span><br><span class="line">Socket(s):             2</span><br><span class="line">NUMA node(s):          2</span><br><span class="line">Vendor ID:             GenuineIntel</span><br><span class="line">CPU family:            6</span><br><span class="line">Model:                 79</span><br><span class="line">Stepping:              1</span><br><span class="line">CPU MHz:               2197.264</span><br><span class="line">BogoMIPS:              4401.60</span><br><span class="line">Virtualization:        VT-x</span><br><span class="line">L1d cache:             32K</span><br><span class="line">L1i cache:             32K</span><br><span class="line">L2 cache:              256K</span><br><span class="line">L3 cache:              30720K</span><br><span class="line">NUMA node0 CPU(s):     0-11,24-35</span><br><span class="line">NUMA node1 CPU(s):     12-23,36-47</span><br></pre></td></tr></table></figure><h4 id="CPU-相关"><a href="#CPU-相关" class="headerlink" title="CPU 相关"></a>CPU 相关</h4><p>cpu cache 结构图如下：<br><img src="https://s1.ax1x.com/2018/10/28/icww8g.jpg" width="650"><br>从硬件的角度，上图的 L1 和 L2 Cache 都被两个 HT 共享，且在同一个物理 Core。而 L3 Cache 则在物理 CPU 里，被多个 Core 来共享。 而从 OS 内核角度，每个 HT 都是一个逻辑 CPU。<br>以 <strong>cpu0</strong> 为例，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@d2b9eb755bb1 ~]# tree -L 1 /sys/devices/system/cpu/cpu0/cache/</span><br><span class="line">/sys/devices/system/cpu/cpu0/cache/</span><br><span class="line">├── index0   -&gt; L1 data缓存</span><br><span class="line">├── index1   -&gt; L1 Instruction缓存</span><br><span class="line">├── index2   -&gt; L2 缓存</span><br><span class="line">└── index3   -&gt; L3 缓存</span><br></pre></td></tr></table></figure><p>点到为止，想了解更多可以翻翻以前的课本。更多 cpu 信息可以从 <code>/proc/cpuinfo</code> 文件中获取到。</p><h4 id="irq-亲缘绑定"><a href="#irq-亲缘绑定" class="headerlink" title="irq 亲缘绑定"></a>irq 亲缘绑定</h4><p>下面基于实践简单说下这个事情。<br><code>/proc/interrupts</code> 文件中可以看到各个 cpu 上的中断情况。<br><code>/proc/irq/#/smp_affinity_list</code> 可以查看指定中断当前绑定的 CPU，当然也 可以看 <code>smp_affinity</code> 这个文件，它是一个16进制bitmask，以逗号分隔，比如 <code>0000,00000020</code>表示该 irq 分给了 CPU5。</p><p>所以，通过如下脚本获得<strong>各网卡中断</strong>的当前 cpu 的整体情况（平时只对网卡中断感兴趣）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /proc/interrupts | grep eth0- | cut -d: -f1 | while read i; do echo -ne irq&quot;:$i\t bind_cpu: &quot;; cat /proc/irq/$i/smp_affinity_list; done | sort -n -t&apos; &apos; -k3</span><br></pre></td></tr></table></figure><p>效果大约是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">irq:113	 bind_cpu: 0</span><br><span class="line">irq:117	 bind_cpu: 1</span><br><span class="line">irq:136	 bind_cpu: 2</span><br><span class="line">irq:109	 bind_cpu: 3</span><br><span class="line">irq:137	 bind_cpu: 4</span><br><span class="line">irq:106	 bind_cpu: 5</span><br><span class="line">irq:112	 bind_cpu: 6</span><br><span class="line">irq:111	 bind_cpu: 7</span><br><span class="line">irq:115	 bind_cpu: 8</span><br><span class="line">irq:149	 bind_cpu: 8</span><br><span class="line">irq:152	 bind_cpu: 8</span><br><span class="line">irq:133	 bind_cpu: 9</span><br><span class="line">irq:110	 bind_cpu: 10</span><br><span class="line">irq:114	 bind_cpu: 11</span><br><span class="line">irq:130	 bind_cpu: 24</span><br><span class="line">irq:148	 bind_cpu: 24</span><br><span class="line">irq:131	 bind_cpu: 25</span><br><span class="line">irq:139	 bind_cpu: 26</span><br><span class="line">irq:118	 bind_cpu: 27</span><br><span class="line">irq:132	 bind_cpu: 27</span><br><span class="line">irq:123	 bind_cpu: 28</span><br><span class="line">irq:128	 bind_cpu: 28</span><br><span class="line">irq:134	 bind_cpu: 28</span><br><span class="line">irq:142	 bind_cpu: 28</span><br><span class="line">irq:150	 bind_cpu: 28</span><br><span class="line">irq:135	 bind_cpu: 29</span><br><span class="line">irq:108	 bind_cpu: 30</span><br><span class="line">irq:116	 bind_cpu: 31</span><br><span class="line">irq:119	 bind_cpu: 32</span><br><span class="line">irq:124	 bind_cpu: 32</span><br><span class="line">irq:126	 bind_cpu: 32</span><br><span class="line">irq:127	 bind_cpu: 32</span><br><span class="line">irq:138	 bind_cpu: 32</span><br><span class="line">irq:151	 bind_cpu: 32</span><br><span class="line">irq:107	 bind_cpu: 33</span><br><span class="line">irq:121	 bind_cpu: 34</span><br><span class="line">irq:140	 bind_cpu: 34</span><br><span class="line">irq:120	 bind_cpu: 35</span><br><span class="line">irq:122	 bind_cpu: 35</span><br><span class="line">irq:125	 bind_cpu: 35</span><br><span class="line">irq:129	 bind_cpu: 35</span><br><span class="line">irq:141	 bind_cpu: 35</span><br><span class="line">irq:143	 bind_cpu: 35</span><br><span class="line">irq:144	 bind_cpu: 35</span><br><span class="line">irq:145	 bind_cpu: 35</span><br><span class="line">irq:146	 bind_cpu: 35</span><br><span class="line">irq:147	 bind_cpu: 35</span><br><span class="line">irq:153	 bind_cpu: 35</span><br></pre></td></tr></table></figure><p>可以看到，我这台机器有一半cpu 是空闲的，已经绑定的 cpu 绑定的 irq 也不太均衡。<br>假如要更改的话，可以有如下类似的操作 <code>echo 3 &gt; /proc/irq/24/smp_affinity</code>。<br>这个也是后面 irqbalance 用来调整中断的方法。</p><h3 id="irqbalance-代码分析"><a href="#irqbalance-代码分析" class="headerlink" title="irqbalance 代码分析"></a>irqbalance 代码分析</h3><p>下面以 v1.07 为例来进行分析。</p><p>irqbalance 中把中断分成了 8 种 class, 4 种 type。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * IRQ Classes</span><br><span class="line"> */</span><br><span class="line">#define IRQ_OTHER       0</span><br><span class="line">#define IRQ_LEGACY      1</span><br><span class="line">#define IRQ_SCSI        2</span><br><span class="line">#define IRQ_VIDEO       3</span><br><span class="line">#define IRQ_ETH         4</span><br><span class="line">#define IRQ_GBETH       5</span><br><span class="line">#define IRQ_10GBETH     6</span><br><span class="line">#define IRQ_VIRT_EVENT  7</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * IRQ Types</span><br><span class="line"> */</span><br><span class="line">#define IRQ_TYPE_LEGACY     0</span><br><span class="line">#define IRQ_TYPE_MSI        1</span><br><span class="line">#define IRQ_TYPE_MSIX       2</span><br><span class="line">#define IRQ_TYPE_VIRT_EVENT 3</span><br></pre></td></tr></table></figure><p>为啥是 8 种 class 呢？这个是依据 pci 设备初始化时注册的类型，可以通过以下脚本来查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@d2b9eb755bb1 ~]# for i in `ls /sys/bus/pci/devices/*/class`;do echo $(( `cat $i` &gt;&gt; 16));done  | sort -nu | wc -l</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>以上的 class 对应 IRQ Classes 使用如下的数组：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static short class_codes[MAX_CLASS] = &#123;</span><br><span class="line">trueIRQ_OTHER,</span><br><span class="line">trueIRQ_SCSI,</span><br><span class="line">trueIRQ_ETH,</span><br><span class="line">trueIRQ_VIDEO,</span><br><span class="line">trueIRQ_OTHER,</span><br><span class="line">trueIRQ_OTHER,</span><br><span class="line">trueIRQ_LEGACY,</span><br><span class="line">trueIRQ_OTHER,</span><br><span class="line">trueIRQ_OTHER,</span><br><span class="line">trueIRQ_LEGACY,</span><br><span class="line">trueIRQ_OTHER,</span><br><span class="line">trueIRQ_OTHER,</span><br><span class="line">trueIRQ_LEGACY,</span><br><span class="line">trueIRQ_ETH,</span><br><span class="line">trueIRQ_SCSI,</span><br><span class="line">trueIRQ_OTHER,</span><br><span class="line">trueIRQ_OTHER,</span><br><span class="line">trueIRQ_OTHER,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>MAX_CLASS = 0x12</code> 即 18。<br>不同 class 的中断平衡的时候作用域不同，有的在PACKAGE，有的在CACHE，有的在CORE。这个关系对应依靠以下数组进行转换:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int map_class_to_level[8] =</span><br><span class="line">&#123; BALANCE_PACKAGE, BALANCE_CACHE, BALANCE_CORE, BALANCE_CORE, BALANCE_CORE, BALANCE_CORE, BALANCE_CORE, BALANCE_CORE &#125;;</span><br></pre></td></tr></table></figure><p>irqbalance 会根据cpu的结构由上到下建立了一个树形结构，最顶层是 numa_nodes，向下以此为 CPU packages、Cache domains以及CPU cores，自顶向下。</p><p>irqbalance 的主函数很简单，10s 一个周期，做以下事情：<br>【1】清除上次统计结果<br>【2】分析中断情况<br>【3】分析中断的负载情况<br>【4】计算如何平衡中断<br>【5】实施上面指定的方案</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// irqbalance.c</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    // ...</span><br><span class="line">    while (keep_going) &#123;</span><br><span class="line">        sleep_approx(SLEEP_INTERVAL); // 10s</span><br><span class="line">        clear_work_stats();</span><br><span class="line">truetrue parse_proc_interrupts();</span><br><span class="line">truetrue parse_proc_stat();</span><br><span class="line">truetrue // ...</span><br><span class="line">truetrue // ...</span><br><span class="line">truetruecalculate_placement();</span><br><span class="line">truetrueactivate_mappings();</span><br><span class="line">truetrue// ...</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中断最终是运行在某一个cpu上的，所以有的中断虽然分配在cache、package层次上，但是最终还是在cpu上运行，所有每个cpu执行中断数大概等于所有父节点的中断数一级一级平均下来。然后用该cpu的负载除以该cpu平均处理的中断数，得到单位中断所占用的负载，那么每个中断的负载就等于该中断在单位时间内新增的个数乘以单位中断所占用的负载。那问题来了，如何计算负载的呢？<br>答案是通过<code>/proc/stat</code> 文件的 <strong>irq + softirq</strong> 获得的，以 cpu0 为例，一个可能的数据如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpu0 200118431 1258 112897097 1062445972 321829 0 1048436 0 0 0</span><br></pre></td></tr></table></figure><p>以上的数组表示从系统启动开始累计到当前时刻的 <strong>jiffies</strong>数(jiffies 是内核中的一个全局变量，用来记录自系统启动一来产生的节拍数，在linux中，一个节拍大致可理解为操作系统进程调度的最小时间片，不同linux内核可能值有不同，通常在1ms到10ms之间)。<br>以上各字段的含义如下表：</p><table><thead><tr><th align="left">数值</th><th align="left">参数</th><th align="right">含义</th></tr></thead><tbody><tr><td align="left">200118431</td><td align="left">user</td><td align="right">处于用户态的运行时间，不包含 nice值为负进程。</td></tr><tr><td align="left">1258</td><td align="left">nice</td><td align="right">nice值为负的进程所占用的CPU时间</td></tr><tr><td align="left">112897097</td><td align="left">system</td><td align="right">处于核心态的运行时间</td></tr><tr><td align="left">1062445972</td><td align="left">idle</td><td align="right">除IO等待时间以外的其它等待时间</td></tr><tr><td align="left">321829</td><td align="left">iowait</td><td align="right">IO等待时间(since 2.5.41)</td></tr><tr><td align="left">0</td><td align="left">irq</td><td align="right">硬中断时间</td></tr><tr><td align="left">1048436</td><td align="left">softirq</td><td align="right">软中断时间</td></tr><tr><td align="left">0</td><td align="left">steal</td><td align="right">-</td></tr><tr><td align="left">0</td><td align="left">guest</td><td align="right">-</td></tr><tr><td align="left">0</td><td align="left">guest_nice</td><td align="right">-</td></tr><tr><td align="left">具体可以看 <a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener">/proc 目录详解</a>。</td><td align="left"></td><td align="right"></td></tr><tr><td align="left">所以，<code>cpu-&gt;last_load = (irq_load + softirq_load)</code>。</td><td align="left"></td><td align="right"></td></tr><tr><td align="left">每个CORE的负载是附在上面的中断的负载的总和，</td><td align="left"></td><td align="right"></td></tr><tr><td align="left">每个DOMAIN是包含的CORE的总和，</td><td align="left"></td><td align="right"></td></tr><tr><td align="left">每个PACKAGE包含的DOMAIN的总和，就像树层次一样的计算。</td><td align="left"></td><td align="right"></td></tr></tbody></table><p>关于如何平衡上面得到的 load 值呢？下一篇再做讲解。</p><p><strong>To be continued…</strong></p></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/shell/">shell</a></div><div class="social-share" data-disabled="google,facebook,qzone,twitter,diandian,linkedin,qzone,tencent"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/fe52c850.html"><i class="fa fa-chevron-left"></i><span>dstat工具使用</span></a></div><div class="next-post pull-right"><a href="/1f742d6d.html"><span>从tcpdump抓包看TCP/IP协议</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script>!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script></div></div></div><footer class="footer-bg" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;&nbsp;2016 - 2019 By Happen</div><div class="framework-info"><span>Powered by</span> <a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>