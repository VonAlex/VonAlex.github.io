<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/dolphin.png"><link rel="icon" type="image/png" href="/images/dolphin.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="Happen"><meta name="keywords" content=""><title>Redis 持久化之 AOF 重写 - Happen&#39;s Memo</title><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css"><link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"><link rel="stylesheet" href="/css/main.css"><link defer="defer" rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="/css/custom.css"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"> <a class="navbar-brand" href="/">&nbsp;<strong>Happen's Memo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"> <a class="nav-link" href="/">首页</a></li><li class="nav-item"> <a class="nav-link" href="/archives/">归档</a></li><li class="nav-item"> <a class="nav-link" href="/categories/">分类</a></li><li class="nav-item"> <a class="nav-link" href="/tags/">标签</a></li><li class="nav-item"> <a class="nav-link" href="/about/">关于</a></li><li class="nav-item" id="search-btn"> <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" parallax="true" style="background:url(/images/about-banner.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask rgba-black-light flex-center"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><p class="mt-3 post-meta"><i class="fas fa-calendar-alt" aria-hidden="true"></i> 2019/01/20, 星期日, 01:55</p><p class="mt-1"><span class="post-meta"><i class="far fa-chart-bar"></i> 3.7k 字</span><span class="post-meta"><i class="far fa-clock"></i> 16 分钟</span><span id="busuanzi_container_page_pv" class="post-meta" style="display:none"><i class="far fa-eye" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span> 次</span></p></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5 z-depth-3" id="board"><div class="post-content mx-auto" id="post"><p class="note note-warning">本文最后更新于：2020/04/03, 星期五, 01:46</p><div class="markdown-body"><blockquote><p>因为 AOF 持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF 文件中的内容会原来越多，文件的体积也会越来越大，若不加以控制，体积过大的 AOF 文件很可能对 Redis 服务器、甚至整个宿主计算机造成影响，并且其体积越大，使用 AOF 文件来进行数据还原所需要的时间就越长。</p></blockquote><a id="more"></a><p>为防止 aofrewrite 过程阻塞服务器，Redis 服务器会 <code>fork</code> 一个子进程执行该过程，且任何时刻只能有一个子进程做这件事。</p><h2 id="server- 相关变量">server 相关变量</h2><p>为了保证 AOF 的连续性，父进程把 aofrewrite 期间的写命令缓存起来，等子进程重写之后再追加到新的 AOF 文件。如果 aofrewrite 期间写命令写入量较大的话，子进程结束后，父进程的追加就涉及到 <strong>大量的写磁盘操作</strong>，造成服务性能下降。</p><p>Redis 通过在父子进程间建立 pipe，把 aofrewrite 期间的写命令通过 pipe 同步给子进程，这样一来，追加写盘的操作也就转嫁给了子进程。Redis server 中与之相关的变量主要有以下几个，主要三个 pipe。</p><pre><code class="language-c">int aof_pipe_write_data_to_child;
int aof_pipe_read_data_from_parent;
int aof_pipe_write_ack_to_parent;
int aof_pipe_read_ack_from_child;
int aof_pipe_write_ack_to_child;
int aof_pipe_read_ack_from_parent;
int aof_stop_sending_diff; /*If true stop sending accumulated diffs to child process. */
sds aof_child_diff;        /* AOF diff accumulator child side. */
</code></pre><h2 id="实现原理">实现原理</h2><p>aofrewrite 的入口逻辑在 <code>rewriteAppendOnlyFileBackground</code> 函数。</p><pre><code class="language-c">int rewriteAppendOnlyFileBackground(void) {
    ...
    if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;
    ...
}
</code></pre><p>要确保没有后台进程做 aofrewrite 或者 rdb，才会考虑做本次的 aofrewrite。</p><h3 id="pipe- 初始化">pipe 初始化</h3><pre><code class="language-c">int rewriteAppendOnlyFileBackground(void) {
   ...
   if (aofCreatePipes() != C_OK) return C_ERR;
   ...
}
</code></pre><pre><code class="language-c">int aofCreatePipes(void) {int fds[6] = {-1, -1, -1, -1, -1, -1};
    int j;

    if (pipe(fds) == -1) goto error; /* parent -&gt; children data. */
    if (pipe(fds+2) == -1) goto error; /* children -&gt; parent ack. */
    if (pipe(fds+4) == -1) goto error; /* children -&gt; parent ack. */
    /* Parent -&gt; children data is non blocking. */
    if (anetNonBlock(NULL,fds[0]) != ANET_OK) goto error;
    if (anetNonBlock(NULL,fds[1]) != ANET_OK) goto error;

    /* 注册读事件处理函数，负责处理子进程要求停止数据传输的消息 */
    if (aeCreateFileEvent(server.el, fds[2], AE_READABLE, aofChildPipeReadable, NULL) == AE_ERR) goto error;

    server.aof_pipe_write_data_to_child = fds[1];
    server.aof_pipe_read_data_from_parent = fds[0];
    server.aof_pipe_write_ack_to_parent = fds[3];
    server.aof_pipe_read_ack_from_child = fds[2];
    server.aof_pipe_write_ack_to_child = fds[5];
    server.aof_pipe_read_ack_from_parent = fds[4];
    server.aof_stop_sending_diff = 0; /* 是否停止管道传输标记位 */
    return C_OK;

error:
    serverLog(LL_WARNING,&quot;Error opening /setting AOF rewrite IPC pipes: %s&quot;,
        strerror(errno));
    for (j = 0; j &lt; 6; j++) if(fds[j] != -1) close(fds[j]);
    return C_ERR;
}
</code></pre><p>在 <code>aofCreatePipes</code> 函数中，对 pipe 进行初始化，pipe 各变量的用处从名字也可以看出来，一共有三条 pipe，每条 pipe 一来一回，占用两个 fd。</p><p>pipe 1 用于父进程向子进程发送缓存的新数据。子进程在 aofrewrite 时，会定期从该管道中读取数据并缓存起来，并在最后将缓存的数据写入重写的新 AOF 文件，这两个 fd 都设置为非阻塞式的。</p><p>pipe 2 负责子进程向父进程发送结束信号。父进程监听 <strong>fds[2]</strong> 读事件，回调函数为 <strong>aofChildPipeReadable</strong>。父进程不断地接收客户端命令，但是子进程不可能无休止地等待父进程的数据，因此，子进程在遍历完数据库所有数据之后，从 pipe 1 中执行一段时间的读取操作后，就会向 pipe 2 中发送一个特殊标记 “<strong>!</strong>”，父进程收到子进程的 “<strong>!</strong>” 后，就会置 <strong>server.aof_stop_sending_diff</strong> 为 1，表示不再向父进程发送缓存数据了。</p><p>pipe 3 负责父进程向子进程发送应答信号。父进程收到子进程的 “<strong>!</strong>” 后，会通过该管道也向子进程应答一个 “<strong>!</strong>”，表示已收到了停止信号。</p><p>详细过程后面会细说。</p><h3 id="父进程处理逻辑">父进程处理逻辑</h3><h4 id="rewriteAppendOnlyFileBackground- 函数">rewriteAppendOnlyFileBackground 函数</h4><p>接着上面的逻辑，server <code>fork</code> 出一个子进程，两个进程分别做各有不同的处理，下面先看父进程的一些主要处理（代码有删减）。</p><pre><code class="language-c">int rewriteAppendOnlyFileBackground(void) {
    ...
    if ((childpid = fork()) == 0) {... ...} else {
        server.aof_rewrite_scheduled = 0;
        server.aof_child_pid = childpid;
        updateDictResizePolicy();
        server.aof_selected_db = -1;
        replicationScriptCacheFlush();
        return C_OK;
    }
    ...
}
</code></pre><p><strong>server.aof_rewrite_scheduled</strong> 置零，防止在 <code>serverCron</code> 函数中重复触发 aofrewrite，这时因为 <code>serverCron</code> 中有如下逻辑，</p><pre><code class="language-c">int rewriteAppendOnlyFileBackground(void) {
    ...
    if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1 &amp;&amp;
        server.aof_rewrite_scheduled)
    {rewriteAppendOnlyFileBackground();
    }
    ...
}
</code></pre><p>这里，<code>updateDictResizePolicy</code> 函数所做的操作是很重要的，如下，</p><pre><code class="language-c">void updateDictResizePolicy(void) {if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1)
        dictEnableResize();
    else
        dictDisableResize();}
</code></pre><p>也就是说，在后台有子进程做 aofrewrite 或 rdb 时，就不要做 dict rehash 了。现在大多数操作系统都采用 <strong>写时复制（copy-on-write）来优化子进程的使用效率</strong>，所以在子进程存在期间，应该避免不必要的内存写入，否则会引起大量的内存 copy，影响性能。COW 的知识可以参考文档 《<a href="https://juejin.im/post/5bd96bcaf265da396b72f855" target="_blank" rel="noopener">Copy On Write 机制了解一下</a>》。</p><p>另外，<strong>server.aof_selected_db</strong> 置为 -1，是为了在子进程进行数据库扫描时插入 select 命令，以便选择正确的数据库。</p><p>####aofRewriteBufferAppend 函数</p><p>在上一篇博客中说过，在 <code>feedAppendOnlyFile</code> 函数 append 写命令时，如果当前有子进程在做 aofrewrite 时，需要将写命令写到 <strong>server.aof_rewrite_buf_blocks</strong> 中一份。该变量是一个链表，其中每个节点最大 10MB。</p><pre><code class="language-c">void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) {
    ...
    if (server.aof_child_pid != -1)
        aofRewriteBufferAppend((unsigned char*)buf,sdslen(buf));
}
</code></pre><pre><code class="language-c">void aofRewriteBufferAppend(unsigned char *s, unsigned long len) {
    ... ...
    /* Install a file event to send data to the rewrite child if there is
     * not one already. */
    if (aeGetFileEvents(server.el,server.aof_pipe_write_data_to_child) == 0) {
        aeCreateFileEvent(server.el, server.aof_pipe_write_data_to_child,
            AE_WRITABLE, aofChildWriteDiffData, NULL);
    }
}
</code></pre><p>为 <strong>server.aof_pipe_write_data_to_child</strong> 注册写事件，回调函数为 <code>aofChildWriteDiffData</code>。</p><pre><code class="language-c">void aofChildWriteDiffData(aeEventLoop *el, int fd, void *privdata, int mask) {
    listNode *ln;
    aofrwblock *block;
    ssize_t nwritten;
    UNUSED(el);
    UNUSED(fd);
    UNUSED(privdata);
    UNUSED(mask);

    while(1) {ln = listFirst(server.aof_rewrite_buf_blocks);
        block = ln ? ln-&gt;value : NULL;
        if (server.aof_stop_sending_diff || !block) {
            aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,
                              AE_WRITABLE);
            return;
        }
        if (block-&gt;used &gt; 0) {
            nwritten = write(server.aof_pipe_write_data_to_child,
                             block-&gt;buf,block-&gt;used);
            if (nwritten &lt;= 0) return;
            memmove(block-&gt;buf,block-&gt;buf+nwritten,block-&gt;used-nwritten);
            block-&gt;used -= nwritten;
        }
        if (block-&gt;used == 0) listDelNode(server.aof_rewrite_buf_blocks,ln);
    }
}
</code></pre><p>当子进程告诉父进程不要发数据（<strong>server.aof_stop_sending_diff = 1</strong>）或者 <strong>server.aof_rewrite_buf_blocks</strong> 为空时，删除写事件。</p><p>否则，往 pipe1 中写入数据，然后写入的数据从 <strong>server.aof_rewrite_buf_blocks</strong> 删掉。</p><h3 id="子进程处理逻辑">子进程处理逻辑</h3><pre><code class="language-c">int rewriteAppendOnlyFileBackground(void) {
    ...
    char tmpfile[256];
    closeListeningSockets(0);               /* child 关闭不必要的 socket */
    redisSetProcTitle(&quot;redis-aof-rewrite&quot;); /* 修改进程名为 redis-aof-rewrite */
    snprintf(tmpfile,256,&quot;temp-rewriteaof-bg-%d.aof&quot;, (int) getpid());
    ...
}
</code></pre><p>首先做一些必要的处理，临时 AOF 文件名为 <strong>temp-rewriteaof-bg-%d.aof</strong>。</p><p>然后进入正式的处理函数 <code>rewriteAppendOnlyFile</code>，以下贴上主要代码（有删减）。</p><pre><code class="language-c">int rewriteAppendOnlyFile(char *filename) {
    ...
    snprintf(tmpfile,256,&quot;temp-rewriteaof-%d.aof&quot;, (int) getpid());
    fp = fopen(tmpfile,&quot;w&quot;);
    server.aof_child_diff = sdsempty(); /* 初始化 aof_child_diff */
    ...
}
</code></pre><p><strong>aof_child_diff</strong> 变量中存放在 aofwrite 期间，子进程接收到父进程通过 pipe 传过来的缓存数据。</p><p>然后就是扫描数据库的操作。</p><pre><code class="language-c">int rewriteAppendOnlyFile(char *filename) {
    ...
    rio aof;
    for (j = 0; j &lt; server.dbnum; j++) {
        redisDb *db = server.db+j;
        dict *d = db-&gt;dict;
        if (dictSize(d) == 0) continue; // skip empty database
        di = dictGetSafeIterator(d);
        while((de = dictNext(di)) != NULL) {
            ... ...
            if (aof.processed_bytes &gt; processed+1024*10) { // 10K
                processed = aof.processed_bytes;
                aofReadDiffFromParent();}
        }
        dictReleaseIterator(di);
        di = NULL;
    }
    if (fflush(fp) == EOF) goto werr;
    if (fsync(fileno(fp)) == -1) goto werr;
    ...
}
</code></pre><p>以上逻辑里，子进程会挨个 db 扫描每一个 key，根据 key 的类型使用不同的函数进行数据重写，带过期时间的数据，都需要 append 一个 <strong>PEXPIREAT</strong> 命令。</p><p>有一点需要注意，前面说到利用 pipe 优化 aofwrite，可以看到上面的逻辑，每遍历一个 db，如果 rio 写入的数据量超过了 <strong>10K</strong>，那么就通过 pipe 从父进程读一次数据，将数据累加到 <strong>server.aof_child_diff</strong>。</p><pre><code class="language-c">ssize_t aofReadDiffFromParent(void) {char buf[65536]; /* Default pipe buffer size on most Linux systems. */
    ssize_t nread, total = 0;

    while ((nread = read(server.aof_pipe_read_data_from_parent,buf,sizeof(buf))) &gt; 0) {server.aof_child_diff = sdscatlen(server.aof_child_diff,buf,nread);
        total += nread;
    }
    return total;
}
</code></pre><p>因为，有客户端可能不断有流量打到父进程，子进程不可能一直等父进程，所以要有一个结束的时刻， Redis 中做了如下决定。</p><pre><code class="language-c">int rewriteAppendOnlyFile(char *filename) {
    ...
    int nodata = 0;
    mstime_t start = mstime();
    while(mstime()-start &lt; 1000 &amp;&amp; nodata &lt; 20) {/* 在 1ms 之内，查看从父进程读数据的 fd 是否变成可读的，若不可读则 aeWait()函数返回 0 */
        if (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, 1) &lt;= 0)
        {
            nodata++;
            continue;
        }
        // 当管道的读端可读时，清零 nodata
        nodata = 0;
        aofReadDiffFromParent();}
    ...
}
</code></pre><p>1ms 超时等待父进程从 pipe 传来数据，如果在 1ms 内有 20 次父进程没传来数据，那么就放弃 <strong>ReadDiffFromParent</strong>。由于 <strong>server.aof_pipe_read_data_from_parent</strong> 在初始化时设置为非阻塞，因此 <code>aeWait</code> 调用返回很快。</p><pre><code class="language-c">if (write(server.aof_pipe_write_ack_to_parent,&quot;!&quot;,1) != 1) goto werr;
</code></pre><p>接着通过 pipe2 告诉父进程（发特殊符号 ！）不要再发来缓存数据了。</p><p>还记得前面初始化时，父进程一直在监听 <strong>server.aof_pipe_read_ack_from_child</strong> 的可读事件吧？当收到 “<strong>!</strong>” 后，父进程调用处理函数 <code>aofChildPipeReadable</code>。</p><pre><code class="language-c">void aofChildPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {
    char byte;
    if (read(fd,&amp;byte,1) == 1 &amp;&amp; byte == '!') {serverLog(LL_NOTICE,&quot;AOF rewrite child asks to stop sending diffs.&quot;);
        server.aof_stop_sending_diff = 1;
        if (write(server.aof_pipe_write_ack_to_child,&quot;!&quot;,1) != 1) {
            serverLog(LL_WARNING,&quot;Can't send ACK to AOF child: %s&quot;,
                strerror(errno));
        }
    }
    /* Remove the handler since this can be called only one time during a
     * rewrite. */
    aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);
}
</code></pre><p>可以看到 <code>server.aof_stop_sending_diff</code> 置为 1，表示不再给子进程发送缓存数据，接着删除 <strong>server.aof_pipe_read_ack_from_child</strong> 上可读事件，给子进程回复一个 “<strong>!</strong>”。</p><p>现在回来看子进程的行为。</p><pre><code class="language-c">int rewriteAppendOnlyFile(char *filename) {
    ...
    if (syncRead(server.aof_pipe_read_ack_from_parent,&amp;byte,1,5000) != 1 || byte != '!')
        goto werr;
    ...
}
</code></pre><p>子进程阻塞 5s 等待父进程发来确认标记 <strong>“!”</strong>，之后就开始做自己的收尾工作，如下：</p><pre><code class="language-c">int rewriteAppendOnlyFile(char *filename) {
    ...
    aofReadDiffFromParent(); /* 最后一次从父进程累计写入的缓冲区的差异 */

    /* 将子进程 aof_child_diff 中保存的差异数据写到 AOF 文件中 */
    if (rioWrite(&amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == 0)
        goto werr;

    /* Make sure data will not remain on the OS's output buffers */
    if (fflush(fp) == EOF) goto werr;
    if (fsync(fileno(fp)) == -1) goto werr;
    if (fclose(fp) == EOF) goto werr;

    /* 原子性修改临时文件的名字为 temp-rewriteaof-bg-&lt;pid&gt;.aof */
    if (rename(tmpfile,filename) == -1) {unlink(tmpfile);
        return C_ERR;
    }
    ...
}
</code></pre><p>最后再读取一次 pipe 中的数据，将子进程进行 aofrewrite 期间，<strong>aof_child_diff</strong> 从父进程累积的数据刷盘，最后进行 <code>rename</code> 系统调用。</p><p>经过以上的逻辑处理，server 交给子进程的 aofrewrite 工作就完成了，最终得到一个文件 <strong>temp-rewriteaof-bg-<pid>.aof</pid></strong>，成功返回 0，否则返回 1。</p><h3 id="父进程的收尾工作">父进程的收尾工作</h3><p>子进程在执行完 aofrewrite 后退出，父进程 <code>wait3</code> 到子进程的退出状态后，进行 aofrewrite 的收尾工作。在 <code>serverCron</code> 函数里，有如下逻辑，</p><pre><code class="language-c">int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    ...
    if ((pid = wait3(&amp;statloc,WNOHANG,NULL)) != 0) { /* wait3 等待所有子进程 */
        int exitcode = WEXITSTATUS(statloc);
        int bysignal = 0;

        if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);

        if (pid == -1) {serverLog(LL_WARNING,&quot;wait3() returned an error: %s. &quot;
                      &quot;rdb_child_pid = %d, aof_child_pid = %d&quot;,
                      strerror(errno),
                      (int) server.rdb_child_pid,
                      (int) server.aof_child_pid);
        } else if (pid == server.rdb_child_pid) {backgroundSaveDoneHandler(exitcode,bysignal);
        } else if (pid == server.aof_child_pid) { /* aof 子进程结束 */
            backgroundRewriteDoneHandler(exitcode,bysignal);
        } else {if (!ldbRemoveChild(pid)) {
                serverLog(LL_WARNING,
                          &quot;Warning, detected child with unmatched pid: %ld&quot;,
                          (long)pid);
            }
        }
        updateDictResizePolicy(); /* 更新 dict resize 为可用状态 */}
    ...
}
</code></pre><p><code>wait3</code> 函数表示父进程等待所有子进程的返回值， <strong>WNOHANG</strong> 选项表示没有子进程 exit 时立即返回，man 中对该选项有如下说明， ”<strong>WNOHANG return immediately if no child has exited</strong>“。</p><p>可以看到如果等到 aofwrite 的子进程 exit，那么使用 <code>backgroundRewriteDoneHandler</code> 函数进行处理，主要如下（代码有删减），</p><pre><code class="language-c">void backgroundRewriteDoneHandler(int exitcode, int bysignal) {
    ...
    snprintf(tmpfile,256,&quot;temp-rewriteaof-bg-%d.aof&quot;, (int)server.aof_child_pid);
    newfd = open(tmpfile,O_WRONLY|O_APPEND);
    if (aofRewriteBufferWrite(newfd) == -1) {close(newfd);
        goto cleanup;
    }
    ...
}
</code></pre><p>打开子进程生成的临时文件 <strong>temp-rewriteaof-bg-<pid>.aof</pid></strong>，调用 <code>aofRewriteBufferWrite</code>，将服务器缓存的剩下的新数据写入该临时文件中，这样该 AOF 临时文件就完全与当前数据库状态一致了。</p><p>那么，下面还有两件事要做，一是将临时 AOF 文件改名，二是切换 fd。</p><pre><code class="language-c">void backgroundRewriteDoneHandler(int exitcode, int bysignal) {
    ...
    if (server.aof_fd == -1) {
        /* AOF disabled */
        oldfd = open(server.aof_filename,O_RDONLY|O_NONBLOCK);
    } else {
        /* AOF enabled */
        oldfd = -1; /* We'll set this to the current AOF filedes later. */
    }
    if (rename(tmpfile,server.aof_filename) == -1) {close(newfd);
        if (oldfd != -1) close(oldfd);
        goto cleanup;
    }

    if (server.aof_fd == -1) {
        /* AOF disabled, we don't need to set the AOF file descriptor
         * to this new file, so we can close it. */
        close(newfd);
    } else {
        /* AOF enabled, replace the old fd with the new one. */
        oldfd = server.aof_fd;
        server.aof_fd = newfd;
        if (server.aof_fsync == AOF_FSYNC_ALWAYS)
            aof_fsync(newfd);
        else if (server.aof_fsync == AOF_FSYNC_EVERYSEC)
            aof_background_fsync(newfd);
        server.aof_selected_db = -1; /* Make sure SELECT is re-issued */
        aofUpdateCurrentSize();
        server.aof_rewrite_base_size = server.aof_current_size;

        /* Clear regular AOF buffer since its contents was just written to
         * the new AOF from the background rewrite buffer. */
        sdsfree(server.aof_buf);
        server.aof_buf = sdsempty();}
    ...  ...
    /* Asynchronously close the overwritten AOF. */
    if (oldfd != -1) bioCreateBackgroundJob(BIO_CLOSE_FILE,(void*)(long)oldfd,NULL,NULL);
    ...
}
</code></pre><p>如上，首先将临时 AOF 文件改名，然后就是 oldfd 和 newfd 的处理了，分 <strong>两种情况</strong>：</p><p>当 AOF 功能关闭时，打开原来的 AOF 文件，获得 oldfd，这里并不关心该操作是否是成功的，如果失败了，那么 oldfd 值为 -1，<code>close(newfd)</code>。</p><p>当 AOF 功能开启时，oldfd 直接置为 -1，将 <strong>aof_fd</strong> 切换成 newfd，根据不同的数据刷盘策略进行 AOF 刷盘，更新相应的参数。</p><p>然后是关闭 oldfd 的逻辑，由于 oldfd 可能是对旧 AOF 文件的最后一个引用，直接 <code>close</code> 可能会阻塞 server，因此创建后台任务去关闭文件。</p><p>最后进行清理工作，如下，</p><pre><code class="language-c">void backgroundRewriteDoneHandler(int exitcode, int bysignal) {
    ...
    cleanup:
        aofClosePipes();
        aofRewriteBufferReset();
        aofRemoveTempFile(server.aof_child_pid);
        server.aof_child_pid = -1;
        server.aof_rewrite_time_last = time(NULL)-server.aof_rewrite_time_start;
        server.aof_rewrite_time_start = -1;
        /* Schedule a new rewrite if we are waiting for it to switch the AOF ON. */
        if (server.aof_state == AOF_WAIT_REWRITE)
            server.aof_rewrite_scheduled = 1;
    ...
}
</code></pre><p>以上， 父进程就完成了收尾工作，写命令就 <code>write</code> 到 newfd 了。</p><h3 id="时序图">时序图</h3><p>可以将以上父子进程的交互整理出时序图如下，</p><p><img src="http://ww1.sinaimg.cn/large/71ca8e3cly1fznp1jin66j20kk0jh77k.jpg" srcset="/img/loading.gif" alt=""></p><p>上图参考 <a href="http://mysql.taobao.org/monthly/2018/12/06/" target="_blank" rel="noopener">Redis · 原理介绍 · 利用管道优化 aofrewrite</a></p><h2 id="何时重写">何时重写</h2><p>有两个时刻可以触发 AOF 重写。</p><p>【1】手动执行 <code>BGREWRITEAOF</code> 命令。</p><p>【2】自动执行，在 <code>serverCron</code> 函数中根据一定逻辑进行判定。</p><pre><code class="language-c">int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    ...
          /* Trigger an AOF rewrite if needed */
    if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1 &amp;&amp;
        server.aof_rewrite_perc &amp;&amp;
        server.aof_current_size &gt; server.aof_rewrite_min_size) /* 默认 64M */
    {
        long long base = server.aof_rewrite_base_size ? server.aof_rewrite_base_size : 1;
        long long growth = (server.aof_current_size*100/base) - 100;
        if (growth &gt;= server.aof_rewrite_perc) {rewriteAppendOnlyFileBackground();
        }
     }
}
</code></pre><p>也就是说 AOF 文件大小超过了 <strong>server.aof_rewrite_min_size</strong>，并且增长率大于 <strong>server.aof_rewrite_perc</strong> 时就会触发，增长率计算的基数 <strong>server.aof_rewrite_base_size</strong> 是上次 aofrewrite 结束后 AOF 文件的大小。</p><h2 id="附录">附录</h2><p>几个解释。</p><blockquote><p><strong>阻塞模式</strong> 下，进程或是线程执行到这些函数时必须等待某个事件的发生，如果事件没有发生，进程或线程就被阻塞(死等在被阻塞的地方)，函数不会立即返回。</p><p><strong>非阻塞 non-block 模式</strong> 下，进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生则返回一个代码来告知事件未发生，而进程或线程继续执行，所以非阻塞模式效率较高。</p></blockquote></div><hr><div><p><span><i class="iconfont icon-inbox"></i> <a class="hover-with-bg" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a> &nbsp;</span> &nbsp;&nbsp;<span><i class="iconfont icon-tag"></i> <a class="hover-with-bg" href="/tags/redis/">redis</a></span></p><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="post-prevnext row"><div class="post-prev col-6"><a href="/54df012b.html"><i class="fa fa-chevron-left"></i> <span class="hidden-mobile">Redis 源码之故障转移</span> <span class="visible-mobile">上一篇</span></a></div><div class="post-next col-6"> <a href="/fd3e9e30.html"><span class="hidden-mobile">Redis 持久化之 AOF</span> <span class="visible-mobile">下一篇</span><i class="fa fa-chevron-right"></i></a></div></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script type="text/javascript">!function(e,t){var r,n=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((r=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",r.defer=!0,n.parentNode.insertBefore(r,n))}(document,"script")</script><noscript> 为正常使用来必力评论功能请激活JavaScript</noscript></div></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc-start"></div><div id="toc"><p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-md"><div class="container custom post-content mx-auto"> <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px;height:150px"></div></div></main><a class="z-depth-1" id="scroll-top-button" href="#" role="button"><i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4> <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"> <span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"> <input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a><i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><b>Fluid</b></a></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script><script>$(document).ready(function(){var s=$("#navbar").height(),c=$("#toc"),t=$("#board-ctn"),o=t.offset().top,i=2*o+t.height();$(window).scroll(function(){var t=$("#toc-start").offset().top-s,o=document.body.scrollTop+document.documentElement.scrollTop;t<=o&&o<=i?c.css({display:"block",position:"fixed",top:s}):o<=t?c.css({position:"",top:""}):i<o&&c.css("display","none")}),tocbot.init({tocSelector:"#tocbot",contentSelector:".post-content",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,headingsOffset:-o}),0<$(".toc-list-item").length&&$("#toc > p").css("visibility","visible");var l=t.css("margin-right");$("#toc-ctn").css({right:l})})</script><script defer="defer" src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer="defer" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script defer="defer">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?882b48640075e00a238ae94a7eec0d40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script defer="defer">var _mtac={};!function(){var t=document.createElement("script");t.src="//pingjs.qq.com/h5/stats.js?v2.0.4",t.setAttribute("name","MTAH5"),t.setAttribute("sid","");var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js"></script><script>$(document).ready(function(){$("pre").addClass("prettyprint  "),prettyPrint()})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","Redis 持久化之 AOF 重写&nbsp;"],cursorChar:"_",typeSpeed:75,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){getSearchFile(path),this.onclick=null}</script><script defer="defer" src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><script>$("#post img:not(.no-zoom img, img[no-zoom])").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>