<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/dolphin.png"><link rel="icon" type="image/png" href="/images/dolphin.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#433d3c"><meta name="description" content=""><meta name="author" content="Happen"><meta name="keywords" content=""><title>Redis 持久化之 AOF 重写 - HappenのMemo</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/monokai.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body><header style="height:60vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>HappenのMemo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(/images/about-banner.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"><span class="h2" id="subtitle"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Happen </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2019-01-20 01:55" pubdate>2019-01-20 01:55</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.8k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 53 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">Redis 持久化之 AOF 重写</h1><p class="note note-info">本文最后更新于：2019-01-20 01:55</p><div class="markdown-body" id="post-body"><blockquote><p>因为 AOF 持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF 文件中的内容会原来越多，文件的体积也会越来越大，若不加以控制，体积过大的 AOF 文件很可能对 Redis 服务器、甚至整个宿主计算机造成影响，并且其体积越大，使用 AOF 文件来进行数据还原所需要的时间就越长。</p></blockquote><!--more----><p>为防止 aofrewrite 过程阻塞服务器，Redis 服务器会 <code>fork</code> 一个子进程执行该过程，且任何时刻只能有一个子进程做这件事。</p><h2 id="server- 相关变量"><a href="#server- 相关变量" class="headerlink" title="server 相关变量"></a>server 相关变量</h2><p>为了保证 AOF 的连续性，父进程把 aofrewrite 期间的写命令缓存起来，等子进程重写之后再追加到新的 AOF 文件。如果 aofrewrite 期间写命令写入量较大的话，子进程结束后，父进程的追加就涉及到 <strong>大量的写磁盘操作</strong>，造成服务性能下降。</p><p>Redis 通过在父子进程间建立 pipe，把 aofrewrite 期间的写命令通过 pipe 同步给子进程，这样一来，追加写盘的操作也就转嫁给了子进程。Redis server 中与之相关的变量主要有以下几个，主要三个 pipe。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> aof_pipe_write_data_to_child;
<span class="hljs-keyword">int</span> aof_pipe_read_data_from_parent;
<span class="hljs-keyword">int</span> aof_pipe_write_ack_to_parent;
<span class="hljs-keyword">int</span> aof_pipe_read_ack_from_child;
<span class="hljs-keyword">int</span> aof_pipe_write_ack_to_child;
<span class="hljs-keyword">int</span> aof_pipe_read_ack_from_parent;
<span class="hljs-keyword">int</span> aof_stop_sending_diff; <span class="hljs-comment">/*If true stop sending accumulated diffs to child process. */</span>
sds aof_child_diff;        <span class="hljs-comment">/* AOF diff accumulator child side. */</span></code></pre></div><h2 id="实现原理"><a href="# 实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>aofrewrite 的入口逻辑在 <code>rewriteAppendOnlyFileBackground</code> 函数。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rewriteAppendOnlyFileBackground</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    ...
    <span class="hljs-keyword">if</span> (server.aof_child_pid != <span class="hljs-number">-1</span> || server.rdb_child_pid != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> C_ERR;
    ...
&#125;</code></pre></div><p>要确保没有后台进程做 aofrewrite 或者 rdb，才会考虑做本次的 aofrewrite。</p><h3 id="pipe- 初始化"><a href="#pipe- 初始化" class="headerlink" title="pipe 初始化"></a>pipe 初始化</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rewriteAppendOnlyFileBackground</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
   ...
   <span class="hljs-keyword">if</span> (aofCreatePipes() != C_OK) <span class="hljs-keyword">return</span> C_ERR;
   ...
&#125;</code></pre></div><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">aofCreatePipes</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-keyword">int</span> fds[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;
    <span class="hljs-keyword">int</span> j;

    <span class="hljs-keyword">if</span> (pipe(fds) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> error; <span class="hljs-comment">/* parent -&gt; children data. */</span>
    <span class="hljs-keyword">if</span> (pipe(fds+<span class="hljs-number">2</span>) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> error; <span class="hljs-comment">/* children -&gt; parent ack. */</span>
    <span class="hljs-keyword">if</span> (pipe(fds+<span class="hljs-number">4</span>) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> error; <span class="hljs-comment">/* children -&gt; parent ack. */</span>
    <span class="hljs-comment">/* Parent -&gt; children data is non blocking. */</span>
    <span class="hljs-keyword">if</span> (anetNonBlock(<span class="hljs-literal">NULL</span>,fds[<span class="hljs-number">0</span>]) != ANET_OK) <span class="hljs-keyword">goto</span> error;
    <span class="hljs-keyword">if</span> (anetNonBlock(<span class="hljs-literal">NULL</span>,fds[<span class="hljs-number">1</span>]) != ANET_OK) <span class="hljs-keyword">goto</span> error;

    <span class="hljs-comment">/* 注册读事件处理函数，负责处理子进程要求停止数据传输的消息 */</span>
    <span class="hljs-keyword">if</span> (aeCreateFileEvent(server.el, fds[<span class="hljs-number">2</span>], AE_READABLE, aofChildPipeReadable, <span class="hljs-literal">NULL</span>) == AE_ERR) <span class="hljs-keyword">goto</span> error;

    server.aof_pipe_write_data_to_child = fds[<span class="hljs-number">1</span>];
    server.aof_pipe_read_data_from_parent = fds[<span class="hljs-number">0</span>];
    server.aof_pipe_write_ack_to_parent = fds[<span class="hljs-number">3</span>];
    server.aof_pipe_read_ack_from_child = fds[<span class="hljs-number">2</span>];
    server.aof_pipe_write_ack_to_child = fds[<span class="hljs-number">5</span>];
    server.aof_pipe_read_ack_from_parent = fds[<span class="hljs-number">4</span>];
    server.aof_stop_sending_diff = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 是否停止管道传输标记位 */</span>
    <span class="hljs-keyword">return</span> C_OK;

error:
    serverLog(LL_WARNING,<span class="hljs-string">&quot;Error opening /setting AOF rewrite IPC pipes: %s&quot;</span>,
        strerror(errno));
    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span>; j++) <span class="hljs-keyword">if</span>(fds[j] != <span class="hljs-number">-1</span>) close(fds[j]);
    <span class="hljs-keyword">return</span> C_ERR;
&#125;</code></pre></div><p>在 <code>aofCreatePipes</code> 函数中，对 pipe 进行初始化，pipe 各变量的用处从名字也可以看出来，一共有三条 pipe，每条 pipe 一来一回，占用两个 fd。</p><p>pipe 1 用于父进程向子进程发送缓存的新数据。子进程在 aofrewrite 时，会定期从该管道中读取数据并缓存起来，并在最后将缓存的数据写入重写的新 AOF 文件，这两个 fd 都设置为非阻塞式的。</p><p>pipe 2 负责子进程向父进程发送结束信号。父进程监听 <strong>fds[2]</strong> 读事件，回调函数为 <strong>aofChildPipeReadable</strong>。父进程不断地接收客户端命令，但是子进程不可能无休止地等待父进程的数据，因此，子进程在遍历完数据库所有数据之后，从 pipe 1 中执行一段时间的读取操作后，就会向 pipe 2 中发送一个特殊标记 “<strong>!</strong>“，父进程收到子进程的 “<strong>!</strong>“ 后，就会置 <strong>server.aof_stop_sending_diff</strong> 为 1，表示不再向父进程发送缓存数据了。</p><p>pipe 3 负责父进程向子进程发送应答信号。父进程收到子进程的 “<strong>!</strong>“ 后，会通过该管道也向子进程应答一个 “<strong>!</strong>“，表示已收到了停止信号。</p><p>详细过程后面会细说。</p><h3 id="父进程处理逻辑"><a href="# 父进程处理逻辑" class="headerlink" title="父进程处理逻辑"></a>父进程处理逻辑</h3><h4 id="rewriteAppendOnlyFileBackground- 函数"><a href="#rewriteAppendOnlyFileBackground- 函数" class="headerlink" title="rewriteAppendOnlyFileBackground 函数"></a>rewriteAppendOnlyFileBackground 函数</h4><p>接着上面的逻辑，server <code>fork</code> 出一个子进程，两个进程分别做各有不同的处理，下面先看父进程的一些主要处理（代码有删减）。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rewriteAppendOnlyFileBackground</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    ...
    <span class="hljs-keyword">if</span> ((childpid = fork()) == <span class="hljs-number">0</span>) &#123;
        ... ...
    &#125; <span class="hljs-keyword">else</span> &#123;
        server.aof_rewrite_scheduled = <span class="hljs-number">0</span>;
        server.aof_child_pid = childpid;
        updateDictResizePolicy();
        server.aof_selected_db = <span class="hljs-number">-1</span>;
        replicationScriptCacheFlush();
        <span class="hljs-keyword">return</span> C_OK;
    &#125;
    ...
&#125;</code></pre></div><p><strong>server.aof_rewrite_scheduled</strong> 置零，防止在 <code>serverCron</code> 函数中重复触发 aofrewrite，这时因为 <code>serverCron</code> 中有如下逻辑，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rewriteAppendOnlyFileBackground</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    ...
    <span class="hljs-keyword">if</span> (server.rdb_child_pid == <span class="hljs-number">-1</span> &amp;&amp; server.aof_child_pid == <span class="hljs-number">-1</span> &amp;&amp;
        server.aof_rewrite_scheduled)
    &#123;
        rewriteAppendOnlyFileBackground();
    &#125;
    ...
&#125;</code></pre></div><p>这里，<code>updateDictResizePolicy</code> 函数所做的操作是很重要的，如下，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateDictResizePolicy</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (server.rdb_child_pid == <span class="hljs-number">-1</span> &amp;&amp; server.aof_child_pid == <span class="hljs-number">-1</span>)
        dictEnableResize();
    <span class="hljs-keyword">else</span>
        dictDisableResize();
&#125;</code></pre></div><p>也就是说，在后台有子进程做 aofrewrite 或 rdb 时，就不要做 dict rehash 了。现在大多数操作系统都采用 <strong>写时复制（copy-on-write）来优化子进程的使用效率</strong>，所以在子进程存在期间，应该避免不必要的内存写入，否则会引起大量的内存 copy，影响性能。COW 的知识可以参考文档 《<a target="_blank" rel="noopener" href="https://juejin.im/post/5bd96bcaf265da396b72f855">Copy On Write 机制了解一下</a>》。</p><p>另外，<strong>server.aof_selected_db</strong> 置为 -1，是为了在子进程进行数据库扫描时插入 select 命令，以便选择正确的数据库。</p><h4 id="aofRewriteBufferAppend- 函数"><a href="#aofRewriteBufferAppend- 函数" class="headerlink" title="aofRewriteBufferAppend 函数"></a>aofRewriteBufferAppend 函数</h4><p>在上一篇博客中说过，在 <code>feedAppendOnlyFile</code> 函数 append 写命令时，如果当前有子进程在做 aofrewrite 时，需要将写命令写到 <strong>server.aof_rewrite_buf_blocks</strong> 中一份。该变量是一个链表，其中每个节点最大 10MB。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">feedAppendOnlyFile</span><span class="hljs-params">(struct redisCommand *cmd, <span class="hljs-keyword">int</span> dictid, robj **argv, <span class="hljs-keyword">int</span> argc)</span> </span>&#123;
    ...
    <span class="hljs-keyword">if</span> (server.aof_child_pid != <span class="hljs-number">-1</span>)
        aofRewriteBufferAppend((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)buf,sdslen(buf));
&#125;</code></pre></div><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aofRewriteBufferAppend</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len)</span> </span>&#123;
    ... ...
    <span class="hljs-comment">/* Install a file event to send data to the rewrite child if there is</span>
<span class="hljs-comment">     * not one already. */</span>
    <span class="hljs-keyword">if</span> (aeGetFileEvents(server.el,server.aof_pipe_write_data_to_child) == <span class="hljs-number">0</span>) &#123;
        aeCreateFileEvent(server.el, server.aof_pipe_write_data_to_child,
            AE_WRITABLE, aofChildWriteDiffData, <span class="hljs-literal">NULL</span>);
    &#125;
&#125;</code></pre></div><p>为 <strong>server.aof_pipe_write_data_to_child</strong> 注册写事件，回调函数为 <code>aofChildWriteDiffData</code>。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aofChildWriteDiffData</span><span class="hljs-params">(aeEventLoop *el, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">int</span> mask)</span> </span>&#123;
    listNode *ln;
    aofrwblock *block;
    <span class="hljs-keyword">ssize_t</span> nwritten;
    UNUSED(el);
    UNUSED(fd);
    UNUSED(privdata);
    UNUSED(mask);

    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;
        ln = listFirst(server.aof_rewrite_buf_blocks);
        block = ln ? ln-&gt;value : <span class="hljs-literal">NULL</span>;
        <span class="hljs-keyword">if</span> (server.aof_stop_sending_diff || !block) &#123;
            aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,
                              AE_WRITABLE);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span> (block-&gt;used &gt; <span class="hljs-number">0</span>) &#123;
            nwritten = write(server.aof_pipe_write_data_to_child,
                             block-&gt;buf,block-&gt;used);
            <span class="hljs-keyword">if</span> (nwritten &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
            memmove(block-&gt;buf,block-&gt;buf+nwritten,block-&gt;used-nwritten);
            block-&gt;used -= nwritten;
        &#125;
        <span class="hljs-keyword">if</span> (block-&gt;used == <span class="hljs-number">0</span>) listDelNode(server.aof_rewrite_buf_blocks,ln);
    &#125;
&#125;</code></pre></div><p>当子进程告诉父进程不要发数据（<strong>server.aof_stop_sending_diff = 1</strong>）或者 <strong>server.aof_rewrite_buf_blocks</strong> 为空时，删除写事件。</p><p>否则，往 pipe1 中写入数据，然后写入的数据从 <strong>server.aof_rewrite_buf_blocks</strong> 删掉。</p><h3 id="子进程处理逻辑"><a href="# 子进程处理逻辑" class="headerlink" title="子进程处理逻辑"></a>子进程处理逻辑</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rewriteAppendOnlyFileBackground</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    ...
    <span class="hljs-keyword">char</span> tmpfile[<span class="hljs-number">256</span>];
    closeListeningSockets(<span class="hljs-number">0</span>);               <span class="hljs-comment">/* child 关闭不必要的 socket */</span>
    redisSetProcTitle(<span class="hljs-string">&quot;redis-aof-rewrite&quot;</span>); <span class="hljs-comment">/* 修改进程名为 redis-aof-rewrite */</span>
    <span class="hljs-built_in">snprintf</span>(tmpfile,<span class="hljs-number">256</span>,<span class="hljs-string">&quot;temp-rewriteaof-bg-%d.aof&quot;</span>, (<span class="hljs-keyword">int</span>) getpid());
    ...
&#125;</code></pre></div><p>首先做一些必要的处理，临时 AOF 文件名为 <strong>temp-rewriteaof-bg-%d.aof</strong>。</p><p>然后进入正式的处理函数 <code>rewriteAppendOnlyFile</code>，以下贴上主要代码（有删减）。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rewriteAppendOnlyFile</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *filename)</span> </span>&#123;
    ...
    <span class="hljs-built_in">snprintf</span>(tmpfile,<span class="hljs-number">256</span>,<span class="hljs-string">&quot;temp-rewriteaof-%d.aof&quot;</span>, (<span class="hljs-keyword">int</span>) getpid());
    fp = fopen(tmpfile,<span class="hljs-string">&quot;w&quot;</span>);
    server.aof_child_diff = sdsempty(); <span class="hljs-comment">/* 初始化 aof_child_diff */</span>
    ...
&#125;</code></pre></div><p><strong>aof_child_diff</strong> 变量中存放在 aofwrite 期间，子进程接收到父进程通过 pipe 传过来的缓存数据。</p><p>然后就是扫描数据库的操作。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rewriteAppendOnlyFile</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *filename)</span> </span>&#123;
    ...
    rio aof;
    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; server.dbnum; j++) &#123;
        redisDb *db = server.db+j;
        dict *d = db-&gt;dict;
        <span class="hljs-keyword">if</span> (dictSize(d) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// skip empty database</span>
        di = dictGetSafeIterator(d);
        <span class="hljs-keyword">while</span>((de = dictNext(di)) != <span class="hljs-literal">NULL</span>) &#123;
            ... ...
            <span class="hljs-keyword">if</span> (aof.processed_bytes &gt; processed+<span class="hljs-number">1024</span>*<span class="hljs-number">10</span>) &#123; <span class="hljs-comment">// 10K</span>
                processed = aof.processed_bytes;
                aofReadDiffFromParent();
            &#125;
        &#125;
        dictReleaseIterator(di);
        di = <span class="hljs-literal">NULL</span>;
    &#125;
    <span class="hljs-keyword">if</span> (fflush(fp) == EOF) <span class="hljs-keyword">goto</span> werr;
    <span class="hljs-keyword">if</span> (fsync(fileno(fp)) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> werr;
    ...
&#125;</code></pre></div><p>以上逻辑里，子进程会挨个 db 扫描每一个 key，根据 key 的类型使用不同的函数进行数据重写，带过期时间的数据，都需要 append 一个 <strong>PEXPIREAT</strong> 命令。</p><p>有一点需要注意，前面说到利用 pipe 优化 aofwrite，可以看到上面的逻辑，每遍历一个 db，如果 rio 写入的数据量超过了 <strong>10K</strong>，那么就通过 pipe 从父进程读一次数据，将数据累加到 <strong>server.aof_child_diff</strong>。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">aofReadDiffFromParent</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">65536</span>]; <span class="hljs-comment">/* Default pipe buffer size on most Linux systems. */</span>
    <span class="hljs-keyword">ssize_t</span> nread, total = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> ((nread = read(server.aof_pipe_read_data_from_parent,buf,<span class="hljs-keyword">sizeof</span>(buf))) &gt; <span class="hljs-number">0</span>) &#123;
        server.aof_child_diff = sdscatlen(server.aof_child_diff,buf,nread);
        total += nread;
    &#125;
    <span class="hljs-keyword">return</span> total;
&#125;</code></pre></div><p>因为，有客户端可能不断有流量打到父进程，子进程不可能一直等父进程，所以要有一个结束的时刻， Redis 中做了如下决定。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rewriteAppendOnlyFile</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *filename)</span> </span>&#123;
    ...
    <span class="hljs-keyword">int</span> nodata = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">mstime_t</span> start = mstime();
    <span class="hljs-keyword">while</span>(mstime()-start &lt; <span class="hljs-number">1000</span> &amp;&amp; nodata &lt; <span class="hljs-number">20</span>) &#123;
        <span class="hljs-comment">/* 在 1ms 之内，查看从父进程读数据的 fd 是否变成可读的，若不可读则 aeWait()函数返回 0 */</span>
        <span class="hljs-keyword">if</span> (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, <span class="hljs-number">1</span>) &lt;= <span class="hljs-number">0</span>)
        &#123;
            nodata++;
            <span class="hljs-keyword">continue</span>;
        &#125;
        <span class="hljs-comment">// 当管道的读端可读时，清零 nodata</span>
        nodata = <span class="hljs-number">0</span>;
        aofReadDiffFromParent();
    &#125;
    ...
&#125;</code></pre></div><p>1ms 超时等待父进程从 pipe 传来数据，如果在 1ms 内有 20 次父进程没传来数据，那么就放弃 <strong>ReadDiffFromParent</strong>。由于 <strong>server.aof_pipe_read_data_from_parent</strong> 在初始化时设置为非阻塞，因此 <code>aeWait</code> 调用返回很快。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (write(server.aof_pipe_write_ack_to_parent,<span class="hljs-string">&quot;!&quot;</span>,<span class="hljs-number">1</span>) != <span class="hljs-number">1</span>) <span class="hljs-keyword">goto</span> werr;</code></pre></div><p>接着通过 pipe2 告诉父进程（发特殊符号 ！）不要再发来缓存数据了。</p><p>还记得前面初始化时，父进程一直在监听 <strong>server.aof_pipe_read_ack_from_child</strong> 的可读事件吧？当收到 “<strong>!</strong>” 后，父进程调用处理函数 <code>aofChildPipeReadable</code>。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aofChildPipeReadable</span><span class="hljs-params">(aeEventLoop *el, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">int</span> mask)</span> </span>&#123;
    <span class="hljs-keyword">char</span> byte;
    <span class="hljs-keyword">if</span> (read(fd,&amp;byte,<span class="hljs-number">1</span>) == <span class="hljs-number">1</span> &amp;&amp; byte == <span class="hljs-string">&#x27;!&#x27;</span>) &#123;
        serverLog(LL_NOTICE,<span class="hljs-string">&quot;AOF rewrite child asks to stop sending diffs.&quot;</span>);
        server.aof_stop_sending_diff = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (write(server.aof_pipe_write_ack_to_child,<span class="hljs-string">&quot;!&quot;</span>,<span class="hljs-number">1</span>) != <span class="hljs-number">1</span>) &#123;
            serverLog(LL_WARNING,<span class="hljs-string">&quot;Can&#x27;t send ACK to AOF child: %s&quot;</span>,
                strerror(errno));
        &#125;
    &#125;
    <span class="hljs-comment">/* Remove the handler since this can be called only one time during a</span>
<span class="hljs-comment">     * rewrite. */</span>
    aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);
&#125;</code></pre></div><p>可以看到 <code>server.aof_stop_sending_diff</code> 置为 1，表示不再给子进程发送缓存数据，接着删除 <strong>server.aof_pipe_read_ack_from_child</strong> 上可读事件，给子进程回复一个 “<strong>!</strong>”。</p><p>现在回来看子进程的行为。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rewriteAppendOnlyFile</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *filename)</span> </span>&#123;
    ...
    <span class="hljs-keyword">if</span> (syncRead(server.aof_pipe_read_ack_from_parent,&amp;byte,<span class="hljs-number">1</span>,<span class="hljs-number">5000</span>) != <span class="hljs-number">1</span> || byte != <span class="hljs-string">&#x27;!&#x27;</span>)
        <span class="hljs-keyword">goto</span> werr;
    ...
&#125;</code></pre></div><p>子进程阻塞 5s 等待父进程发来确认标记 <strong>“!”</strong>，之后就开始做自己的收尾工作，如下：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rewriteAppendOnlyFile</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *filename)</span> </span>&#123;
    ...
    aofReadDiffFromParent(); <span class="hljs-comment">/* 最后一次从父进程累计写入的缓冲区的差异 */</span>

    <span class="hljs-comment">/* 将子进程 aof_child_diff 中保存的差异数据写到 AOF 文件中 */</span>
    <span class="hljs-keyword">if</span> (rioWrite(&amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">goto</span> werr;

    <span class="hljs-comment">/* Make sure data will not remain on the OS&#x27;s output buffers */</span>
    <span class="hljs-keyword">if</span> (fflush(fp) == EOF) <span class="hljs-keyword">goto</span> werr;
    <span class="hljs-keyword">if</span> (fsync(fileno(fp)) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> werr;
    <span class="hljs-keyword">if</span> (fclose(fp) == EOF) <span class="hljs-keyword">goto</span> werr;

    <span class="hljs-comment">/* 原子性修改临时文件的名字为 temp-rewriteaof-bg-&lt;pid&gt;.aof */</span>
    <span class="hljs-keyword">if</span> (rename(tmpfile,filename) == <span class="hljs-number">-1</span>) &#123;
        unlink(tmpfile);
        <span class="hljs-keyword">return</span> C_ERR;
    &#125;
    ...
&#125;</code></pre></div><p>最后再读取一次 pipe 中的数据，将子进程进行 aofrewrite 期间，<strong>aof_child_diff</strong> 从父进程累积的数据刷盘，最后进行 <code>rename</code> 系统调用。</p><p>经过以上的逻辑处理，server 交给子进程的 aofrewrite 工作就完成了，最终得到一个文件 <strong>temp-rewriteaof-bg-<pid>.aof</pid></strong>，成功返回 0，否则返回 1。</p><h3 id="父进程的收尾工作"><a href="# 父进程的收尾工作" class="headerlink" title="父进程的收尾工作"></a>父进程的收尾工作</h3><p>子进程在执行完 aofrewrite 后退出，父进程 <code>wait3</code> 到子进程的退出状态后，进行 aofrewrite 的收尾工作。在 <code>serverCron</code> 函数里，有如下逻辑，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">serverCron</span><span class="hljs-params">(struct aeEventLoop *eventLoop, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> id, <span class="hljs-keyword">void</span> *clientData)</span> </span>&#123;
    ...
    <span class="hljs-keyword">if</span> ((pid = wait3(&amp;statloc,WNOHANG,<span class="hljs-literal">NULL</span>)) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* wait3 等待所有子进程 */</span>
        <span class="hljs-keyword">int</span> exitcode = WEXITSTATUS(statloc);
        <span class="hljs-keyword">int</span> bysignal = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);

        <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>) &#123;
            serverLog(LL_WARNING,<span class="hljs-string">&quot;wait3() returned an error: %s. &quot;</span>
                      <span class="hljs-string">&quot;rdb_child_pid = %d, aof_child_pid = %d&quot;</span>,
                      strerror(errno),
                      (<span class="hljs-keyword">int</span>) server.rdb_child_pid,
                      (<span class="hljs-keyword">int</span>) server.aof_child_pid);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == server.rdb_child_pid) &#123;
            backgroundSaveDoneHandler(exitcode,bysignal);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == server.aof_child_pid) &#123; <span class="hljs-comment">/* aof 子进程结束 */</span>
            backgroundRewriteDoneHandler(exitcode,bysignal);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">if</span> (!ldbRemoveChild(pid)) &#123;
                serverLog(LL_WARNING,
                          <span class="hljs-string">&quot;Warning, detected child with unmatched pid: %ld&quot;</span>,
                          (<span class="hljs-keyword">long</span>)pid);
            &#125;
        &#125;
        updateDictResizePolicy(); <span class="hljs-comment">/* 更新 dict resize 为可用状态 */</span>
    &#125;
    ...
&#125;</code></pre></div><p><code>wait3</code> 函数表示父进程等待所有子进程的返回值， <strong>WNOHANG</strong> 选项表示没有子进程 exit 时立即返回，man 中对该选项有如下说明， ”<strong>WNOHANG return immediately if no child has exited</strong>“。</p><p>可以看到如果等到 aofwrite 的子进程 exit，那么使用 <code>backgroundRewriteDoneHandler</code> 函数进行处理，主要如下（代码有删减），</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backgroundRewriteDoneHandler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> exitcode, <span class="hljs-keyword">int</span> bysignal)</span> </span>&#123;
    ...
    <span class="hljs-built_in">snprintf</span>(tmpfile,<span class="hljs-number">256</span>,<span class="hljs-string">&quot;temp-rewriteaof-bg-%d.aof&quot;</span>, (<span class="hljs-keyword">int</span>)server.aof_child_pid);
    newfd = open(tmpfile,O_WRONLY|O_APPEND);
    <span class="hljs-keyword">if</span> (aofRewriteBufferWrite(newfd) == <span class="hljs-number">-1</span>) &#123;
        close(newfd);
        <span class="hljs-keyword">goto</span> cleanup;
    &#125;
    ...
&#125;</code></pre></div><p>打开子进程生成的临时文件 <strong>temp-rewriteaof-bg-<pid>.aof</pid></strong>，调用 <code>aofRewriteBufferWrite</code>，将服务器缓存的剩下的新数据写入该临时文件中，这样该 AOF 临时文件就完全与当前数据库状态一致了。</p><p>那么，下面还有两件事要做，一是将临时 AOF 文件改名，二是切换 fd。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backgroundRewriteDoneHandler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> exitcode, <span class="hljs-keyword">int</span> bysignal)</span> </span>&#123;
    ...
    <span class="hljs-keyword">if</span> (server.aof_fd == <span class="hljs-number">-1</span>) &#123;
        <span class="hljs-comment">/* AOF disabled */</span>
        oldfd = open(server.aof_filename,O_RDONLY|O_NONBLOCK);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">/* AOF enabled */</span>
        oldfd = <span class="hljs-number">-1</span>; <span class="hljs-comment">/* We&#x27;ll set this to the current AOF filedes later. */</span>
    &#125;
    <span class="hljs-keyword">if</span> (rename(tmpfile,server.aof_filename) == <span class="hljs-number">-1</span>) &#123;
        close(newfd);
        <span class="hljs-keyword">if</span> (oldfd != <span class="hljs-number">-1</span>) close(oldfd);
        <span class="hljs-keyword">goto</span> cleanup;
    &#125;

    <span class="hljs-keyword">if</span> (server.aof_fd == <span class="hljs-number">-1</span>) &#123;
        <span class="hljs-comment">/* AOF disabled, we don&#x27;t need to set the AOF file descriptor</span>
<span class="hljs-comment">         * to this new file, so we can close it. */</span>
        close(newfd);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">/* AOF enabled, replace the old fd with the new one. */</span>
        oldfd = server.aof_fd;
        server.aof_fd = newfd;
        <span class="hljs-keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS)
            aof_fsync(newfd);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)
            aof_background_fsync(newfd);
        server.aof_selected_db = <span class="hljs-number">-1</span>; <span class="hljs-comment">/* Make sure SELECT is re-issued */</span>
        aofUpdateCurrentSize();
        server.aof_rewrite_base_size = server.aof_current_size;

        <span class="hljs-comment">/* Clear regular AOF buffer since its contents was just written to</span>
<span class="hljs-comment">         * the new AOF from the background rewrite buffer. */</span>
        sdsfree(server.aof_buf);
        server.aof_buf = sdsempty();
    &#125;
    ...  ...
    <span class="hljs-comment">/* Asynchronously close the overwritten AOF. */</span>
    <span class="hljs-keyword">if</span> (oldfd != <span class="hljs-number">-1</span>) bioCreateBackgroundJob(BIO_CLOSE_FILE,(<span class="hljs-keyword">void</span>*)(<span class="hljs-keyword">long</span>)oldfd,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);
    ...
&#125;</code></pre></div><p>如上，首先将临时 AOF 文件改名，然后就是 oldfd 和 newfd 的处理了，分 <strong>两种情况</strong>：</p><p>当 AOF 功能关闭时，打开原来的 AOF 文件，获得 oldfd，这里并不关心该操作是否是成功的，如果失败了，那么 oldfd 值为 -1，<code>close(newfd)</code>。</p><p>当 AOF 功能开启时，oldfd 直接置为 -1，将 <strong>aof_fd</strong> 切换成 newfd，根据不同的数据刷盘策略进行 AOF 刷盘，更新相应的参数。</p><p>然后是关闭 oldfd 的逻辑，由于 oldfd 可能是对旧 AOF 文件的最后一个引用，直接 <code>close</code> 可能会阻塞 server，因此创建后台任务去关闭文件。</p><p>最后进行清理工作，如下，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backgroundRewriteDoneHandler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> exitcode, <span class="hljs-keyword">int</span> bysignal)</span> </span>&#123;
    ...
    cleanup:
        aofClosePipes();
        aofRewriteBufferReset();
        aofRemoveTempFile(server.aof_child_pid);
        server.aof_child_pid = <span class="hljs-number">-1</span>;
        server.aof_rewrite_time_last = time(<span class="hljs-literal">NULL</span>)-server.aof_rewrite_time_start;
        server.aof_rewrite_time_start = <span class="hljs-number">-1</span>;
        <span class="hljs-comment">/* Schedule a new rewrite if we are waiting for it to switch the AOF ON. */</span>
        <span class="hljs-keyword">if</span> (server.aof_state == AOF_WAIT_REWRITE)
            server.aof_rewrite_scheduled = <span class="hljs-number">1</span>;
    ...
&#125;</code></pre></div><p>以上， 父进程就完成了收尾工作，写命令就 <code>write</code> 到 newfd 了。</p><h3 id="时序图"><a href="# 时序图" class="headerlink" title="时序图"></a>时序图</h3><p>可以将以上父子进程的交互整理出时序图如下，</p><p><img src="http://ww1.sinaimg.cn/large/71ca8e3cly1fznp1jin66j20kk0jh77k.jpg" srcset="/img/loading.gif" alt=""></p><p>上图参考 <a target="_blank" rel="noopener" href="http://mysql.taobao.org/monthly/2018/12/06/">Redis · 原理介绍 · 利用管道优化 aofrewrite</a></p><h2 id="何时重写"><a href="# 何时重写" class="headerlink" title="何时重写"></a>何时重写</h2><p>有两个时刻可以触发 AOF 重写。</p><p>【1】手动执行 <code>BGREWRITEAOF</code> 命令。</p><p>【2】自动执行，在 <code>serverCron</code> 函数中根据一定逻辑进行判定。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">serverCron</span><span class="hljs-params">(struct aeEventLoop *eventLoop, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> id, <span class="hljs-keyword">void</span> *clientData)</span> </span>&#123;
    ...
          <span class="hljs-comment">/* Trigger an AOF rewrite if needed */</span>
    <span class="hljs-keyword">if</span> (server.rdb_child_pid == <span class="hljs-number">-1</span> &amp;&amp; server.aof_child_pid == <span class="hljs-number">-1</span> &amp;&amp;
        server.aof_rewrite_perc &amp;&amp;
        server.aof_current_size &gt; server.aof_rewrite_min_size) <span class="hljs-comment">/* 默认 64M */</span>
    &#123;
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base = server.aof_rewrite_base_size ? server.aof_rewrite_base_size : <span class="hljs-number">1</span>;
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> growth = (server.aof_current_size*<span class="hljs-number">100</span>/base) - <span class="hljs-number">100</span>;
        <span class="hljs-keyword">if</span> (growth &gt;= server.aof_rewrite_perc) &#123;
            rewriteAppendOnlyFileBackground();
        &#125;
     &#125;
&#125;</code></pre></div><p>也就是说 AOF 文件大小超过了 <strong>server.aof_rewrite_min_size</strong>，并且增长率大于 <strong>server.aof_rewrite_perc</strong> 时就会触发，增长率计算的基数 <strong>server.aof_rewrite_base_size</strong> 是上次 aofrewrite 结束后 AOF 文件的大小。</p><h2 id="附录"><a href="# 附录" class="headerlink" title="附录"></a>附录</h2><p>几个解释。</p><blockquote><p><strong>阻塞模式 </strong>下，进程或是线程执行到这些函数时必须等待某个事件的发生，如果事件没有发生，进程或线程就被阻塞(死等在被阻塞的地方)，函数不会立即返回。</p><p><strong>非阻塞 non-block 模式 </strong>下，进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生则返回一个代码来告知事件未发生，而进程或线程继续执行，所以非阻塞模式效率较高。</p></blockquote></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/redis/">redis</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext row"><article class="post-prev col-6"><a href="/54df012b.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Redis 源码之故障转移</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/fd3e9e30.html"><span class="hidden-mobile">Redis 持久化之 AOF</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script type="text/javascript">function loadLivere(){addScript("https://cdn-city.livere.com/js/embed.dist.js")}waitElementVisible("lv-container",loadLivere)</script><noscript>为正常使用来必力评论功能请允许 JavaScript 运行</noscript></div></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:3,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","Redis 持久化之 AOF 重写&nbsp;"],cursorChar:"|",typeSpeed:72,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "§"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>