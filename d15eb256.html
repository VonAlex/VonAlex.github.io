<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Redis 持久化之 AOF 重写"><meta name="keywords" content="redis"><meta name="author" content="Happen"><meta name="copyright" content="Happen"><title>Redis 持久化之 AOF 重写 | Happen's Memo</title><link rel="shortcut icon" href="/images/dolphin.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?882b48640075e00a238ae94a7eec0d40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,c,g,o){e.GoogleAnalyticsObject=c,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,g=a.createElement(t),o=a.getElementsByTagName(t)[0],g.async=1,g.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(g,o)}(window,document,"script",0,"ga"),ga("create","RRBput3V2WYVZd2lq058Z4IwJEhViOwuMElqkWh6bcA","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#server-相关变量"><span class="toc-number">1.</span> <span class="toc-text">server 相关变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现原理"><span class="toc-number">2.</span> <span class="toc-text">实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pipe-初始化"><span class="toc-number">2.1.</span> <span class="toc-text">pipe 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#父进程处理逻辑"><span class="toc-number">2.2.</span> <span class="toc-text">父进程处理逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rewriteAppendOnlyFileBackground-函数"><span class="toc-number">2.2.1.</span> <span class="toc-text">rewriteAppendOnlyFileBackground 函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子进程处理逻辑"><span class="toc-number">2.3.</span> <span class="toc-text">子进程处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#父进程的收尾工作"><span class="toc-number">2.4.</span> <span class="toc-text">父进程的收尾工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时序图"><span class="toc-number">2.5.</span> <span class="toc-text">时序图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#何时重写"><span class="toc-number">3.</span> <span class="toc-text">何时重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附录"><span class="toc-number">4.</span> <span class="toc-text">附录</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.png"></div><div class="author-info__name text-center">Happen</div><div class="author-info__description text-center">浮生若梦，为欢几何</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">39</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://renrenlove.me/" target="_blank" rel="noopener">Galway</a><a class="author-info-links__name text-center" href="http://kvguru.com/" target="_blank" rel="noopener">Wangbin</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div id="page-header"> <span class="pull-left"><a id="site-name" href="/">Happen's Memo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Redis 持久化之 AOF 重写</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a><div class="post-meta-wordcount"><span>字数总计:</span> <span class="word-count">3.8k</span><span class="post-meta__separator">|</span><span>阅读时长: 15 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote><p>因为 AOF 持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF 文件中的内容会原来越多，文件的体积也会越来越大，若不加以控制，体积过大的 AOF 文件很可能对 Redis 服务器、甚至整个宿主计算机造成影响，并且其体积越大，使用 AOF 文件来进行数据还原所需要的时间就越长。</p></blockquote><a id="more"></a><p>为防止 aofrewrite 过程阻塞服务器，Redis 服务器会 <code>fork</code> 一个子进程执行该过程，且任何时刻只能有一个子进程做这件事。</p><h2 id="server-相关变量"><a href="#server-相关变量" class="headerlink" title="server 相关变量"></a>server 相关变量</h2><p>为了保证 AOF 的连续性，父进程把 aofrewrite 期间的写命令缓存起来，等子进程重写之后再追加到新的 AOF 文件。如果 aofrewrite 期间写命令写入量较大的话，子进程结束后，父进程的追加就涉及到<strong>大量的写磁盘操作</strong>，造成服务性能下降。</p><p>Redis 通过在父子进程间建立 pipe，把 aofrewrite 期间的写命令通过 pipe 同步给子进程，这样一来，追加写盘的操作也就转嫁给了子进程。Redis server 中与之相关的变量主要有以下几个，主要三个 pipe。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> aof_pipe_write_data_to_child;</span><br><span class="line"><span class="keyword">int</span> aof_pipe_read_data_from_parent;</span><br><span class="line"><span class="keyword">int</span> aof_pipe_write_ack_to_parent;</span><br><span class="line"><span class="keyword">int</span> aof_pipe_read_ack_from_child;</span><br><span class="line"><span class="keyword">int</span> aof_pipe_write_ack_to_child;</span><br><span class="line"><span class="keyword">int</span> aof_pipe_read_ack_from_parent;</span><br><span class="line"><span class="keyword">int</span> aof_stop_sending_diff; <span class="comment">/*If true stop sending accumulated diffs to child process. */</span></span><br><span class="line">sds aof_child_diff;        <span class="comment">/* AOF diff accumulator child side. */</span></span><br></pre></td></tr></table></figure><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>aofrewrite 的入口逻辑在 <code>rewriteAppendOnlyFileBackground</code> 函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要确保没有后台进程做 aofrewrite 或者 rdb，才会考虑做本次的 aofrewrite。</p><h3 id="pipe-初始化"><a href="#pipe-初始化" class="headerlink" title="pipe 初始化"></a>pipe 初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span> (aofCreatePipes() != C_OK) <span class="keyword">return</span> C_ERR;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aofCreatePipes</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">6</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(fds) == <span class="number">-1</span>) <span class="keyword">goto</span> error; <span class="comment">/* parent -&gt; children data. */</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(fds+<span class="number">2</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> error; <span class="comment">/* children -&gt; parent ack. */</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(fds+<span class="number">4</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> error; <span class="comment">/* children -&gt; parent ack. */</span></span><br><span class="line">    <span class="comment">/* Parent -&gt; children data is non blocking. */</span></span><br><span class="line">    <span class="keyword">if</span> (anetNonBlock(<span class="literal">NULL</span>,fds[<span class="number">0</span>]) != ANET_OK) <span class="keyword">goto</span> error;</span><br><span class="line">    <span class="keyword">if</span> (anetNonBlock(<span class="literal">NULL</span>,fds[<span class="number">1</span>]) != ANET_OK) <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册读事件处理函数，负责处理子进程要求停止数据传输的消息 */</span></span><br><span class="line">    <span class="keyword">if</span> (aeCreateFileEvent(server.el, fds[<span class="number">2</span>], AE_READABLE, aofChildPipeReadable, <span class="literal">NULL</span>) == AE_ERR) <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    server.aof_pipe_write_data_to_child = fds[<span class="number">1</span>];</span><br><span class="line">    server.aof_pipe_read_data_from_parent = fds[<span class="number">0</span>];</span><br><span class="line">    server.aof_pipe_write_ack_to_parent = fds[<span class="number">3</span>];</span><br><span class="line">    server.aof_pipe_read_ack_from_child = fds[<span class="number">2</span>];</span><br><span class="line">    server.aof_pipe_write_ack_to_child = fds[<span class="number">5</span>];</span><br><span class="line">    server.aof_pipe_read_ack_from_parent = fds[<span class="number">4</span>];</span><br><span class="line">    server.aof_stop_sending_diff = <span class="number">0</span>; <span class="comment">/* 是否停止管道传输标记位 */</span></span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Error opening /setting AOF rewrite IPC pipes: %s"</span>,</span><br><span class="line">        strerror(errno));</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) <span class="keyword">if</span>(fds[j] != <span class="number">-1</span>) <span class="built_in">close</span>(fds[j]);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>aofCreatePipes</code> 函数中，对 pipe 进行初始化，pipe 各变量的用处从名字也可以看出来，一共有三条 pipe，每条 pipe 一来一回，占用两个 fd。</p><p>pipe 1 用于父进程向子进程发送缓存的新数据。子进程在 aofrewrite 时，会定期从该管道中读取数据并缓存起来，并在最后将缓存的数据写入重写的新 AOF 文件，这两个 fd 都设置为非阻塞式的。</p><p>pipe 2 负责子进程向父进程发送结束信号。父进程监听 <strong>fds[2]</strong> 读事件，回调函数为 <strong>aofChildPipeReadable</strong>。父进程不断地接收客户端命令，但是子进程不可能无休止地等待父进程的数据，因此，子进程在遍历完数据库所有数据之后，从 pipe 1 中执行一段时间的读取操作后，就会向 pipe 2 中发送一个特殊标记 “<strong>!</strong>“，父进程收到子进程的 “<strong>!</strong>“ 后，就会置 <strong>server.aof_stop_sending_diff</strong> 为 1，表示不再向父进程发送缓存数据了。</p><p>pipe 3 负责父进程向子进程发送应答信号。父进程收到子进程的 “<strong>!</strong>“ 后，会通过该管道也向子进程应答一个 “<strong>!</strong>“，表示已收到了停止信号。</p><p>详细过程后面会细说。</p><h3 id="父进程处理逻辑"><a href="#父进程处理逻辑" class="headerlink" title="父进程处理逻辑"></a>父进程处理逻辑</h3><h4 id="rewriteAppendOnlyFileBackground-函数"><a href="#rewriteAppendOnlyFileBackground-函数" class="headerlink" title="rewriteAppendOnlyFileBackground 函数"></a>rewriteAppendOnlyFileBackground 函数</h4><p>接着上面的逻辑，server <code>fork</code> 出一个子进程，两个进程分别做各有不同的处理，下面先看父进程的一些主要处理（代码有删减）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ... ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        server.aof_rewrite_scheduled = <span class="number">0</span>;</span><br><span class="line">        server.aof_child_pid = childpid;</span><br><span class="line">        updateDictResizePolicy();</span><br><span class="line">        server.aof_selected_db = <span class="number">-1</span>;</span><br><span class="line">        replicationScriptCacheFlush();</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>server.aof_rewrite_scheduled</strong> 置零，防止在 <code>serverCron</code> 函数中重复触发 aofrewrite，这时因为 <code>serverCron</code> 中有如下逻辑，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span> &amp;&amp;</span><br><span class="line">        server.aof_rewrite_scheduled)</span><br><span class="line">    &#123;</span><br><span class="line">        rewriteAppendOnlyFileBackground();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>updateDictResizePolicy</code> 函数所做的操作是很重要的，如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateDictResizePolicy</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span>)</span><br><span class="line">        dictEnableResize();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dictDisableResize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，在后台有子进程做 aofrewrite 或 rdb 时，就不要做 dict rehash 了。现在大多数操作系统都采用<strong>写时复制（copy-on-write）来优化子进程的使用效率</strong>，所以在子进程存在期间，应该避免不必要的内存写入，否则会引起大量的内存 copy，影响性能。COW 的知识可以参考文档 《<a href="https://juejin.im/post/5bd96bcaf265da396b72f855" target="_blank" rel="noopener">Copy On Write机制了解一下</a>》。</p><p>另外，<strong>server.aof_selected_db</strong> 置为 -1，是为了在子进程进行数据库扫描时插入 select 命令，以便选择正确的数据库。</p><p>####aofRewriteBufferAppend 函数</p><p>在上一篇博客中说过，在 <code>feedAppendOnlyFile</code> 函数 append 写命令时，如果当前有子进程在做 aofrewrite 时，需要将写命令写到 <strong>server.aof_rewrite_buf_blocks</strong> 中一份。该变量是一个链表，其中每个节点最大10MB。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>)</span><br><span class="line">        aofRewriteBufferAppend((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,sdslen(buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aofRewriteBufferAppend</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">long</span> len)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">/* Install a file event to send data to the rewrite child if there is</span></span><br><span class="line"><span class="comment">     * not one already. */</span></span><br><span class="line">    <span class="keyword">if</span> (aeGetFileEvents(server.el,server.aof_pipe_write_data_to_child) == <span class="number">0</span>) &#123;</span><br><span class="line">        aeCreateFileEvent(server.el, server.aof_pipe_write_data_to_child,</span><br><span class="line">            AE_WRITABLE, aofChildWriteDiffData, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为 <strong>server.aof_pipe_write_data_to_child</strong> 注册写事件，回调函数为 <code>aofChildWriteDiffData</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aofChildWriteDiffData</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    aofrwblock *block;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    UNUSED(el);</span><br><span class="line">    UNUSED(fd);</span><br><span class="line">    UNUSED(privdata);</span><br><span class="line">    UNUSED(mask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        ln = listFirst(server.aof_rewrite_buf_blocks);</span><br><span class="line">        block = ln ? ln-&gt;value : <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (server.aof_stop_sending_diff || !block) &#123;</span><br><span class="line">            aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,</span><br><span class="line">                              AE_WRITABLE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (block-&gt;used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nwritten = <span class="built_in">write</span>(server.aof_pipe_write_data_to_child,</span><br><span class="line">                             block-&gt;buf,block-&gt;used);</span><br><span class="line">            <span class="keyword">if</span> (nwritten &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            memmove(block-&gt;buf,block-&gt;buf+nwritten,block-&gt;used-nwritten);</span><br><span class="line">            block-&gt;used -= nwritten;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (block-&gt;used == <span class="number">0</span>) listDelNode(server.aof_rewrite_buf_blocks,ln);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当子进程告诉父进程不要发数据（<strong>server.aof_stop_sending_diff = 1</strong>）或者 <strong>server.aof_rewrite_buf_blocks</strong> 为空时，删除写事件。</p><p>否则，往 pipe1 中写入数据，然后写入的数据从 <strong>server.aof_rewrite_buf_blocks</strong> 删掉。</p><h3 id="子进程处理逻辑"><a href="#子进程处理逻辑" class="headerlink" title="子进程处理逻辑"></a>子进程处理逻辑</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line">    closeListeningSockets(<span class="number">0</span>);               <span class="comment">/* child 关闭不必要的 socket */</span></span><br><span class="line">    redisSetProcTitle(<span class="string">"redis-aof-rewrite"</span>); <span class="comment">/* 修改进程名为 redis-aof-rewrite */</span></span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">"temp-rewriteaof-bg-%d.aof"</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先做一些必要的处理，临时 AOF 文件名为 <strong>temp-rewriteaof-bg-%d.aof</strong>。</p><p>然后进入正式的处理函数 <code>rewriteAppendOnlyFile</code>，以下贴上主要代码（有删减）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">"temp-rewriteaof-%d.aof"</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    fp = fopen(tmpfile,<span class="string">"w"</span>);</span><br><span class="line">    server.aof_child_diff = sdsempty(); <span class="comment">/* 初始化 aof_child_diff */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>aof_child_diff</strong> 变量中存放在 aofwrite 期间，子进程接收到父进程通过 pipe 传过来的缓存数据。</p><p>然后就是扫描数据库的操作。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    rio aof;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">        redisDb *db = server.db+j;</span><br><span class="line">        dict *d = db-&gt;dict;</span><br><span class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// skip empty database</span></span><br><span class="line">        di = dictGetSafeIterator(d);</span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ... ...</span><br><span class="line">            <span class="keyword">if</span> (aof.processed_bytes &gt; processed+<span class="number">1024</span>*<span class="number">10</span>) &#123; <span class="comment">// 10K</span></span><br><span class="line">                processed = aof.processed_bytes;</span><br><span class="line">                aofReadDiffFromParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        di = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上逻辑里，子进程会挨个 db 扫描每一个 key，根据 key 的类型使用不同的函数进行数据重写，带过期时间的数据，都需要 append 一个 <strong>PEXPIREAT</strong> 命令。</p><p>有一点需要注意，前面说到利用 pipe 优化 aofwrite，可以看到上面的逻辑，每遍历一个 db，如果 rio 写入的数据量超过了 <strong>10K</strong>，那么就通过 pipe 从父进程读一次数据，将数据累加到 <strong>server.aof_child_diff</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> aofReadDiffFromParent(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">65536</span>]; <span class="comment">/* Default pipe buffer size on most Linux systems. */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread, total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((nread = <span class="built_in">read</span>(server.aof_pipe_read_data_from_parent,buf,<span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        server.aof_child_diff = sdscatlen(server.aof_child_diff,buf,nread);</span><br><span class="line">        total += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为，有客户端可能不断有流量打到父进程，子进程不可能一直等父进程，所以要有一个结束的时刻， Redis 中做了如下决定。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> nodata = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mstime_t</span> start = mstime();</span><br><span class="line">    <span class="keyword">while</span>(mstime()-start &lt; <span class="number">1000</span> &amp;&amp; nodata &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="comment">/* 在1ms之内，查看从父进程读数据的 fd 是否变成可读的，若不可读则aeWait()函数返回0 */</span></span><br><span class="line">        <span class="keyword">if</span> (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nodata++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当管道的读端可读时，清零nodata</span></span><br><span class="line">        nodata = <span class="number">0</span>;</span><br><span class="line">        aofReadDiffFromParent();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1ms 超时等待父进程从 pipe 传来数据，如果在 1ms 内有 20 次父进程没传来数据，那么就放弃 <strong>ReadDiffFromParent</strong>。由于 <strong>server.aof_pipe_read_data_from_parent</strong> 在初始化时设置为非阻塞，因此 <code>aeWait</code> 调用返回很快。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">write</span>(server.aof_pipe_write_ack_to_parent,<span class="string">"!"</span>,<span class="number">1</span>) != <span class="number">1</span>) <span class="keyword">goto</span> werr;</span><br></pre></td></tr></table></figure><p>接着通过 pipe2 告诉父进程（发特殊符号 ！）不要再发来缓存数据了。</p><p>还记得前面初始化时，父进程一直在监听 <strong>server.aof_pipe_read_ack_from_child</strong> 的可读事件吧？当收到 “<strong>!</strong>” 后，父进程调用处理函数 <code>aofChildPipeReadable</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aofChildPipeReadable</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">byte</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(fd,&amp;<span class="keyword">byte</span>,<span class="number">1</span>) == <span class="number">1</span> &amp;&amp; <span class="keyword">byte</span> == <span class="string">'!'</span>) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"AOF rewrite child asks to stop sending diffs."</span>);</span><br><span class="line">        server.aof_stop_sending_diff = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(server.aof_pipe_write_ack_to_child,<span class="string">"!"</span>,<span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"Can't send ACK to AOF child: %s"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Remove the handler since this can be called only one time during a</span></span><br><span class="line"><span class="comment">     * rewrite. */</span></span><br><span class="line">    aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>server.aof_stop_sending_diff</code> 置为 1，表示不再给子进程发送缓存数据，接着删除 <strong>server.aof_pipe_read_ack_from_child</strong> 上可读事件，给子进程回复一个 “<strong>!</strong>”。</p><p>现在回来看子进程的行为。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (syncRead(server.aof_pipe_read_ack_from_parent,&amp;<span class="keyword">byte</span>,<span class="number">1</span>,<span class="number">5000</span>) != <span class="number">1</span> || <span class="keyword">byte</span> != <span class="string">'!'</span>)</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子进程阻塞 5s 等待父进程发来确认标记 <strong>“!”</strong>，之后就开始做自己的收尾工作，如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    aofReadDiffFromParent(); <span class="comment">/* 最后一次从父进程累计写入的缓冲区的差异 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将子进程aof_child_diff 中保存的差异数据写到 AOF 文件中 */</span></span><br><span class="line">    <span class="keyword">if</span> (rioWrite(&amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure data will not remain on the OS's output buffers */</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 原子性修改临时文件的名字为 temp-rewriteaof-bg-&lt;pid&gt;.aof */</span></span><br><span class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">        unlink(tmpfile);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再读取一次 pipe 中的数据，将子进程进行 aofrewrite 期间，<strong>aof_child_diff</strong> 从父进程累积的数据刷盘，最后进行 <code>rename</code> 系统调用。</p><p>经过以上的逻辑处理，server 交给子进程的 aofrewrite 工作就完成了，最终得到一个文件 <strong>temp-rewriteaof-bg-<pid>.aof</pid></strong>，成功返回 0，否则返回1。</p><h3 id="父进程的收尾工作"><a href="#父进程的收尾工作" class="headerlink" title="父进程的收尾工作"></a>父进程的收尾工作</h3><p>子进程在执行完 aofrewrite 后退出，父进程 <code>wait3</code> 到子进程的退出状态后，进行 aofrewrite 的收尾工作。在 <code>serverCron</code> 函数里，有如下逻辑，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serverCron</span><span class="params">(struct aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id, <span class="keyword">void</span> *clientData)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((pid = wait3(&amp;statloc,WNOHANG,<span class="literal">NULL</span>)) != <span class="number">0</span>) &#123; <span class="comment">/* wait3 等待所有子进程 */</span></span><br><span class="line">        <span class="keyword">int</span> exitcode = WEXITSTATUS(statloc);</span><br><span class="line">        <span class="keyword">int</span> bysignal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"wait3() returned an error: %s. "</span></span><br><span class="line">                      <span class="string">"rdb_child_pid = %d, aof_child_pid = %d"</span>,</span><br><span class="line">                      strerror(errno),</span><br><span class="line">                      (<span class="keyword">int</span>) server.rdb_child_pid,</span><br><span class="line">                      (<span class="keyword">int</span>) server.aof_child_pid);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == server.rdb_child_pid) &#123;</span><br><span class="line">            backgroundSaveDoneHandler(exitcode,bysignal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == server.aof_child_pid) &#123; <span class="comment">/* aof 子进程结束 */</span></span><br><span class="line">            backgroundRewriteDoneHandler(exitcode,bysignal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ldbRemoveChild(pid)) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                          <span class="string">"Warning, detected child with unmatched pid: %ld"</span>,</span><br><span class="line">                          (<span class="keyword">long</span>)pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        updateDictResizePolicy(); <span class="comment">/* 更新 dict resize 为可用状态 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wait3</code> 函数表示父进程等待所有子进程的返回值， <strong>WNOHANG</strong> 选项表示没有子进程 exit 时立即返回，man 中对该选项有如下说明， ”<strong>WNOHANG return immediately if no child has exited</strong>“。</p><p>可以看到如果等到 aofwrite 的子进程 exit，那么使用 <code>backgroundRewriteDoneHandler</code> 函数进行处理，主要如下（代码有删减），</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backgroundRewriteDoneHandler</span><span class="params">(<span class="keyword">int</span> exitcode, <span class="keyword">int</span> bysignal)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">"temp-rewriteaof-bg-%d.aof"</span>, (<span class="keyword">int</span>)server.aof_child_pid);</span><br><span class="line">    newfd = <span class="built_in">open</span>(tmpfile,O_WRONLY|O_APPEND);</span><br><span class="line">    <span class="keyword">if</span> (aofRewriteBufferWrite(newfd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">close</span>(newfd);</span><br><span class="line">        <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开子进程生成的临时文件 <strong>temp-rewriteaof-bg-<pid>.aof</pid></strong>，调用 <code>aofRewriteBufferWrite</code>，将服务器缓存的剩下的新数据写入该临时文件中，这样该 AOF 临时文件就完全与当前数据库状态一致了。</p><p>那么，下面还有两件事要做，一是将临时 AOF 文件改名，二是切换 fd。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backgroundRewriteDoneHandler</span><span class="params">(<span class="keyword">int</span> exitcode, <span class="keyword">int</span> bysignal)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (server.aof_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">/* AOF disabled */</span></span><br><span class="line">        oldfd = <span class="built_in">open</span>(server.aof_filename,O_RDONLY|O_NONBLOCK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* AOF enabled */</span></span><br><span class="line">        oldfd = <span class="number">-1</span>; <span class="comment">/* We'll set this to the current AOF filedes later. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rename(tmpfile,server.aof_filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">close</span>(newfd);</span><br><span class="line">        <span class="keyword">if</span> (oldfd != <span class="number">-1</span>) <span class="built_in">close</span>(oldfd);</span><br><span class="line">        <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">/* AOF disabled, we don't need to set the AOF file descriptor</span></span><br><span class="line"><span class="comment">         * to this new file, so we can close it. */</span></span><br><span class="line">        <span class="built_in">close</span>(newfd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* AOF enabled, replace the old fd with the new one. */</span></span><br><span class="line">        oldfd = server.aof_fd;</span><br><span class="line">        server.aof_fd = newfd;</span><br><span class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS)</span><br><span class="line">            aof_fsync(newfd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)</span><br><span class="line">            aof_background_fsync(newfd);</span><br><span class="line">        server.aof_selected_db = <span class="number">-1</span>; <span class="comment">/* Make sure SELECT is re-issued */</span></span><br><span class="line">        aofUpdateCurrentSize();</span><br><span class="line">        server.aof_rewrite_base_size = server.aof_current_size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Clear regular AOF buffer since its contents was just written to</span></span><br><span class="line"><span class="comment">         * the new AOF from the background rewrite buffer. */</span></span><br><span class="line">        sdsfree(server.aof_buf);</span><br><span class="line">        server.aof_buf = sdsempty();</span><br><span class="line">    &#125;</span><br><span class="line">    ...  ...</span><br><span class="line">    <span class="comment">/* Asynchronously close the overwritten AOF. */</span></span><br><span class="line">    <span class="keyword">if</span> (oldfd != <span class="number">-1</span>) bioCreateBackgroundJob(BIO_CLOSE_FILE,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)oldfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，首先将临时 AOF 文件改名，然后就是 oldfd 和 newfd 的处理了，分<strong>两种情况</strong>：</p><p>当 AOF 功能关闭时，打开原来的 AOF 文件，获得 oldfd，这里并不关心该操作是否是成功的，如果失败了，那么 oldfd 值为 -1，<code>close(newfd)</code>。</p><p>当 AOF 功能开启时，oldfd 直接置为 -1，将 <strong>aof_fd</strong> 切换成 newfd，根据不同的数据刷盘策略进行 AOF 刷盘，更新相应的参数。</p><p>然后是关闭 oldfd 的逻辑，由于 oldfd 可能是对旧 AOF 文件的最后一个引用，直接 <code>close</code> 可能会阻塞 server，因此创建后台任务去关闭文件。</p><p>最后进行清理工作，如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backgroundRewriteDoneHandler</span><span class="params">(<span class="keyword">int</span> exitcode, <span class="keyword">int</span> bysignal)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    cleanup:</span><br><span class="line">        aofClosePipes();</span><br><span class="line">        aofRewriteBufferReset();</span><br><span class="line">        aofRemoveTempFile(server.aof_child_pid);</span><br><span class="line">        server.aof_child_pid = <span class="number">-1</span>;</span><br><span class="line">        server.aof_rewrite_time_last = time(<span class="literal">NULL</span>)-server.aof_rewrite_time_start;</span><br><span class="line">        server.aof_rewrite_time_start = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">/* Schedule a new rewrite if we are waiting for it to switch the AOF ON. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_state == AOF_WAIT_REWRITE)</span><br><span class="line">            server.aof_rewrite_scheduled = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上， 父进程就完成了收尾工作，写命令就 <code>write</code> 到 newfd 了。</p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p>可以将以上父子进程的交互整理出时序图如下，</p><p><img src="http://ww1.sinaimg.cn/large/71ca8e3cly1fznp1jin66j20kk0jh77k.jpg" alt=""></p><p>上图参考 <a href="http://mysql.taobao.org/monthly/2018/12/06/" target="_blank" rel="noopener">Redis · 原理介绍 · 利用管道优化aofrewrite</a></p><h2 id="何时重写"><a href="#何时重写" class="headerlink" title="何时重写"></a>何时重写</h2><p>有两个时刻可以触发 AOF 重写。</p><p>【1】手动执行 <code>BGREWRITEAOF</code> 命令。</p><p>【2】自动执行，在 <code>serverCron</code> 函数中根据一定逻辑进行判定。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serverCron</span><span class="params">(struct aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id, <span class="keyword">void</span> *clientData)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">          <span class="comment">/* Trigger an AOF rewrite if needed */</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span> &amp;&amp;</span><br><span class="line">        server.aof_rewrite_perc &amp;&amp;</span><br><span class="line">        server.aof_current_size &gt; server.aof_rewrite_min_size) <span class="comment">/* 默认 64M */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> base = server.aof_rewrite_base_size ? server.aof_rewrite_base_size : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> growth = (server.aof_current_size*<span class="number">100</span>/base) - <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (growth &gt;= server.aof_rewrite_perc) &#123;</span><br><span class="line">            rewriteAppendOnlyFileBackground();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说 AOF 文件大小超过了 <strong>server.aof_rewrite_min_size</strong>，并且增长率大于 <strong>server.aof_rewrite_perc</strong> 时就会触发，增长率计算的基数 <strong>server.aof_rewrite_base_size</strong> 是上次 aofrewrite 结束后 AOF 文件的大小。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>几个解释。</p><blockquote><p><strong>阻塞模式</strong>下，进程或是线程执行到这些函数时必须等待某个事件的发生，如果事件没有发生，进程或线程就被阻塞(死等在被阻塞的地方)，函数不会立即返回。</p><p><strong>非阻塞non-block模式</strong>下，进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生则返回一个代码来告知事件未发生，而进程或线程继续执行，所以非阻塞模式效率较高。</p></blockquote></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="social-share" data-disabled="google,facebook,qzone,twitter,diandian,linkedin,qzone,tencent"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/54df012b.html"><i class="fa fa-chevron-left"></i><span>Redis 源码之故障转移</span></a></div><div class="next-post pull-right"><a href="/fd3e9e30.html"><span>Redis 持久化之 AOF</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script>!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script></div></div></div><footer class="footer-bg" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;&nbsp;2016 - 2020 By Happen</div><div class="framework-info"><span>Powered by</span> <a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>