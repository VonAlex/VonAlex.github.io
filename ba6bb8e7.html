<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/dolphin.png"><link rel="icon" type="image/png" href="/images/dolphin.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="Happen"><meta name="keywords" content=""><title>Redis 基本数据结构之双向链表 - Happen&#39;s Memo</title><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css"><link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"><link rel="stylesheet" href="/css/main.css"><link defer="defer" rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="/css/custom.css"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"> <a class="navbar-brand" href="/">&nbsp;<strong>Happen's Memo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="fa fa-home" aria-hidden="true"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="fa fa-archive" aria-hidden="true"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="fa fa-map-signs" aria-hidden="true"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="fa fa-tags" aria-hidden="true"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="fa fa-child" aria-hidden="true"></i> 关于</a></li><li class="nav-item" id="search-btn"> <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" parallax="true" style="background:url(/images/about-banner.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask rgba-black-light flex-center"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><p class="mt-3 post-meta"><i class="fas fa-calendar-alt" aria-hidden="true"></i> 2018/08/13, 星期一, 20:19</p><p class="mt-1"><span class="post-meta"><i class="far fa-chart-bar"></i> 1.8k 字</span><span class="post-meta"><i class="far fa-clock"></i> 8 分钟</span><span id="busuanzi_container_page_pv" class="post-meta" style="display:none"><i class="far fa-eye" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span> 次</span></p></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5 z-depth-3" id="board"><div class="post-content mx-auto" id="post"><p class="note note-warning">本文最后更新于：2020/04/03, 星期五, 01:46</p><div class="markdown-body"><blockquote><p> 链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。</p></blockquote><p> 链表是一种非常常见的数据结构。由于 redis 使用的 C 语言并没有这种数据结构，因此，作者在 redis 对这一数据结构进行了实现。redis 的链表实现为双向链表，主要用在实现列表键、发布订阅、保存多客户端状态、服务器模块，订阅模块和保存输入命令等方面，使用较广。</p><a id="more"></a><p>redis 源码中关于 adlist 的部分，主要在 <code>adlist.h</code> 和 <code>adlist.c</code> 这两个文件中。</p><h3 id="adlist- 的定义">adlist 的定义</h3><p> 首先在 <code>adlist.h</code> 中找到定义</p><pre><code class="language-c">// list 节点
typedef struct listNode {
    // 前驱节点
    struct listNode *prev;
    // 后继节点
    struct listNode *next;
    // 节点值
    void *value;
} listNode;

// redis 双链表实现
typedef struct list {
    listNode *head;                      // 表头指针
    listNode *tail;                      // 表尾指针
    void *(*dup)(void *ptr);             // 节点值复制函数
    void (*free)(void *ptr);             // 节点值释放函数（函数指针）
    int (*match)(void *ptr, void *key);  // 节点值对比函数
    unsigned long len;                   // 链表包含的节点数量
} list;

</code></pre><p> 可以发现，这就是一个无环双向链表。<br> <code>list</code> 结构中带有一个 <code>len</code> 的变量，可以将获取链表长度的时间复杂度从 O(n) 降到 O(1)。<br> <code>head</code> 指针和 <code>tail</code> 指针让给我们可以快速的找到链表的头尾，时间复杂度都是 O(1)。<br> 三个函数指针，让我们可以对链表有更灵活的操作，使用起来也更加方便。</p><p> 当需要进行链表迭代时，可以使用如下函数：</p><pre><code class="language-c">typedef struct listIter {
    listNode *next; // 指向下一个节点
    int direction;  // 迭代器，正向反向
} listIter;
</code></pre><p><code>direction</code> 决定了遍历的方向，可正向可反向。</p><h3 id="adlist- 宏定义">adlist 宏定义</h3><p> 这部分定义了一些获取 <code>list</code> 结构的宏，简化操作。</p><pre><code class="language-c">#define listLength(l) ((l)-&gt;len)                    // 获取 list 中包含的 node 数量
#define listFirst(l) ((l)-&gt;head)                    // 获取 list 头节点指针
#define listLast(l) ((l)-&gt;tail)                     // 获取 list 尾节点指针
#define listPrevNode(n) ((n)-&gt;prev)                 // 获取当前节点的前驱节点
#define listNextNode(n) ((n)-&gt;next)                 // 获得当前节点的后继节点
#define listNodeValue(n) ((n)-&gt;value)

#define listSetDupMethod(l,m) ((l)-&gt;dup = (m))      // 指定节点复制函数
#define listSetFreeMethod(l,m) ((l)-&gt;free = (m))    // 指定节点释放函数
#define listSetMatchMethod(l,m) ((l)-&gt;match = (m))  // 指定节点的比较函数

#define listGetDupMethod(l) ((l)-&gt;dup)   // 获得节点复制函数
#define listGetFree(l) ((l)-&gt;free)
#define listGetMatchMethod(l) ((l)-&gt;match)
</code></pre><h3 id="adlist- 函数">adlist 函数</h3><p> 这部分定义了一些双向链表的常用操作。</p><pre><code class="language-c">list *listCreate(void); // 创建一个不包含任何节点的新链表
void listRelease(list *list); // 释放给定链表，以及链表中的所有节点

// CRUD 操作
list *listAddNodeHead(list *list, void *value);  // 头部插入节点
list *listAddNodeTail(list *list, void *value);  // 尾部插入节点
list *listInsertNode(list *list, listNode *old_node, void *value, int after); // 中间某个位置插入节点
void listDelNode(list *list, listNode *node); // O(N) 删除指定节点

listIter *listGetIterator(list *list, int direction); // 获取指定迭代器
void listReleaseIterator(listIter *iter);   // 释放迭代器
listNode *listNext(listIter *iter); // 迭代下一个节点

list *listDup(list *orig); // 链表复制
listNode *listSearchKey(list *list, void *key); // O(N) 按 key 找节点
listNode *listIndex(list *list, long index);  // O(N)
void listRewind(list *list, listIter *li); // 重置为正向迭代器
void listRewindTail(list *list, listIter *li); // 重置为逆向迭代器
void listRotate(list *list); // 链表旋转
</code></pre><h4 id="创建 -adlist"> 创建 adlist</h4><pre><code class="language-c">list *listCreate(void)
{
    struct list *list;

    if ((list = zmalloc(sizeof(*list))) == NULL)
        return NULL;
    list-&gt;head = list-&gt;tail = NULL;
    list-&gt;len = 0;
    list-&gt;dup = NULL;
    list-&gt;free = NULL;
    list-&gt;match = NULL;
    return list;
}
</code></pre><p> 创建一个空的 adlist 很简单，就是分配内存，初始化数据结构，而 <code>listRelease</code> 的释放链表过程与之相反，这个自不必多说。</p><h4 id="adlist- 的 -CRUD- 操作">adlist 的 CRUD 操作</h4><p> 首先是插入数据，分三种情况：头部插入、中间插入和尾部插入。<br> (1) 头部插入</p><pre><code class="language-c">// 头部插入值 value
list *listAddNodeHead(list *list, void *value)
{
    listNode *node;

    if ((node = zmalloc(sizeof(*node))) == NULL) // 为新节点分配内存
        return NULL;
    node-&gt;value = value;
    if (list-&gt;len == 0) { // 若之前的 list 为空，那么插入后就只有一个节点
        list-&gt;head = list-&gt;tail = node;
        node-&gt;prev = node-&gt;next = NULL;
    } else {
        node-&gt;prev = NULL;
        node-&gt;next = list-&gt;head;
        list-&gt;head-&gt;prev = node;
        list-&gt;head = node; // 更新 list head 信息
    }
    list-&gt;len++; // 更新链表长度信息
    return list;
}
</code></pre><p>（2）尾部插入节点类似，就不啰嗦了。<br> （3）中间插入</p><pre><code class="language-c">// 在 list 指定节点 old_node 后（after=1）或前插入一个节点
list *listInsertNode(list *list, listNode *old_node, void *value, int after) {
    listNode *node;

    if ((node = zmalloc(sizeof(*node))) == NULL) // 为新节点分配内存
        return NULL;
    node-&gt;value = value;
    if (after) { // 后

        // 处理 node 节点的前后指向
        node-&gt;prev = old_node;
        node-&gt;next = old_node-&gt;next;
        if (list-&gt;tail == old_node) { // node 成了尾节点，更新 list 信息
            list-&gt;tail = node;
        }
    } else { // 前
        node-&gt;next = old_node;
        node-&gt;prev = old_node-&gt;prev;
        if (list-&gt;head == old_node) { // node 成了头节点，更新 list 信息
            list-&gt;head = node;
        }
    }

    // 处理 node 相邻两个节点的指向
    if (node-&gt;prev != NULL) {node-&gt;prev-&gt;next = node;}
    if (node-&gt;next != NULL) {node-&gt;next-&gt;prev = node;}
    list-&gt;len++;
    return list;
}
</code></pre><p> 然后是删除操作。</p><pre><code class="language-c">// 从 list 中删除 node 节点
void listDelNode(list *list, listNode *node)
{if (node-&gt;prev) // 是否有前驱节点，即判断要删除的节点是否为头节点
        node-&gt;prev-&gt;next = node-&gt;next;
    else
        list-&gt;head = node-&gt;next; // 更新 list 的头结点指向
    if (node-&gt;next) // 是否有后继节点，即判断要删除的节点是否为尾节点
        node-&gt;next-&gt;prev = node-&gt;prev;
    else
        list-&gt;tail = node-&gt;prev;
    if (list-&gt;free) list-&gt;free(node-&gt;value);
    zfree(node);
    list-&gt;len--; // 更新节点数量信息
}
</code></pre><p> 最后是查找。</p><pre><code class="language-c">// 从 list 中查找 key
listNode *listSearchKey(list *list, void *key)
{
    listIter iter;
    listNode *node;

    listRewind(list, &amp;iter); // 获得正向遍历器，并从头开始遍历
    while((node = listNext(&amp;iter)) != NULL) {if (list-&gt;match) { // list 中有指定的比较器
            if (list-&gt;match(node-&gt;value, key)) {return node;}
        } else {if (key == node-&gt;value) {return node;}
        }
    }
    return NULL;
}
</code></pre><pre><code class="language-c">// 获得 list 中第 index 个节点，index 为负数表示从尾部倒序往前找
listNode *listIndex(list *list, long index) {
    listNode *n;
    if (index &lt; 0) { // 从尾部查找
        index = (-index)-1;
        n = list-&gt;tail;
        while(index-- &amp;&amp; n) n = n-&gt;prev; // 往前遍历
    } else {
        n = list-&gt;head;
        while(index-- &amp;&amp; n) n = n-&gt;next; // 往后遍历
    }
    return n;
}
</code></pre><h4 id="其他"> 其他</h4><p> 迭代器实现如下：</p><pre><code class="language-c">listIter *listGetIterator(list *list, int direction)
{
    listIter *iter;

    if ((iter = zmalloc(sizeof(*iter))) == NULL) return NULL;
    if (direction == AL_START_HEAD)
        iter-&gt;next = list-&gt;head;
    else
        iter-&gt;next = list-&gt;tail;
    iter-&gt;direction = direction; // 迭代器方向
    return iter;
}
</code></pre><p> 另外，一个旋转 list 的操作，实现效果将 1 → 2 → 3 → 4 变成 4 → 1 → 2 → 3</p><pre><code class="language-c">void listRotate(list *list) {
    listNode *tail = list-&gt;tail;// 取尾节点

    if (listLength(list) &lt;= 1) return; // 1 个节点不需要 rotate

    /* Detach current tail 分离尾部节点 */
    list-&gt;tail = tail-&gt;prev;
    list-&gt;tail-&gt;next = NULL;

    /* Move it as head 转移到 head */
    list-&gt;head-&gt;prev = tail;
    tail-&gt;prev = NULL;
    tail-&gt;next = list-&gt;head;

    list-&gt;head = tail; // 更新 list 的新 head
}

</code></pre><h3 id="总结"> 总结</h3><p>adlist 其实就是把双向链表的基本操作实现了一遍，看了一遍相当于复习了一遍（之前面试总问这些，哈哈），不过作者设计的很巧，值得学习。</p></div><hr><div><p><span><i class="iconfont icon-inbox"></i> <a class="hover-with-bg" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a> &nbsp;</span> &nbsp;&nbsp;<span><i class="iconfont icon-tag"></i> <a class="hover-with-bg" href="/tags/redis/">redis</a></span></p><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="post-prevnext row"><div class="post-prev col-6"><a href="/85f7b0b4.html"><i class="fa fa-chevron-left"></i> <span class="hidden-mobile">Redis 中的事件</span> <span class="visible-mobile">上一篇</span></a></div><div class="post-next col-6"> <a href="/fe52c850.html"><span class="hidden-mobile">dstat 工具使用</span> <span class="visible-mobile">下一篇</span><i class="fa fa-chevron-right"></i></a></div></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script type="text/javascript">!function(e,t){var r,n=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((r=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",r.defer=!0,n.parentNode.insertBefore(r,n))}(document,"script")</script><noscript> 为正常使用来必力评论功能请激活JavaScript</noscript></div></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc-start"></div><div id="toc"><p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-md"><div class="container custom post-content mx-auto"> <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px;height:150px"></div></div></main><a class="z-depth-1" id="scroll-top-button" href="#" role="button"><i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4> <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"> <span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"> <input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a><i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><b>Fluid</b></a></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script><script>$(document).ready(function(){var s=$("#navbar").height(),c=$("#toc"),t=$("#board-ctn"),o=t.offset().top,i=2*o+t.height();$(window).scroll(function(){var t=$("#toc-start").offset().top-s,o=document.body.scrollTop+document.documentElement.scrollTop;t<=o&&o<=i?c.css({display:"block",position:"fixed",top:s}):o<=t?c.css({position:"",top:""}):i<o&&c.css("display","none")}),tocbot.init({tocSelector:"#tocbot",contentSelector:".post-content",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,headingsOffset:-o}),0<$(".toc-list-item").length&&$("#toc > p").css("visibility","visible");var l=t.css("margin-right");$("#toc-ctn").css({right:l})})</script><script defer="defer" src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer="defer" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script defer="defer">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?882b48640075e00a238ae94a7eec0d40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script defer="defer">var _mtac={};!function(){var t=document.createElement("script");t.src="//pingjs.qq.com/h5/stats.js?v2.0.4",t.setAttribute("name","MTAH5"),t.setAttribute("sid","");var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js"></script><script>$(document).ready(function(){$("pre").addClass("prettyprint  "),prettyPrint()})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","Redis 基本数据结构之双向链表&nbsp;"],cursorChar:"_",typeSpeed:80,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){getSearchFile(path),this.onclick=null}</script><script defer="defer" src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><script>$("#post img:not(.no-zoom img, img[no-zoom])").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>