<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/dolphin.png"><link rel="icon" type="image/png" href="/images/dolphin.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#433d3c"><meta name="description" content=""><meta name="author" content="Happen"><meta name="keywords" content=""><title>Redis 持久化之 AOF - HappenのMemo</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/monokai.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body><header style="height:60vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>HappenのMemo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(/images/about-banner.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"><span class="h2" id="subtitle"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Happen </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2019-01-14 16:09" pubdate>2019-01-14 16:09</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 6.2k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 83 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">Redis 持久化之 AOF</h1><p class="note note-info">本文最后更新于：2019-01-14 16:09</p><div class="markdown-body" id="post-body"><p>除了 RDB 持久化功能之外，Redis 还提供了 AOF（Append Only File）持久化功能。与 RDB 持久化通过保存数据库中的键值对来记录数据库状态不同，AOF 持久化是通过保存 Redis 服务器所执行的写命令来记录数据库状态的。</p><!--more----><h2 id="简介">简介</h2><p>AOF 文件中记录了 Redis 服务器所执行的写命令，以此来保存数据库的状态。AOF 文件本质上是一个 redo log，通过它可以恢复数据库状态。</p><p>随着执行命令的增多，AOF 文件的大小会不断增大，这会导致几个问题，比如，磁盘占用增加，重启加载过慢等。因此， Redis 提供了 AOF 重写机制来控制 AOF 文件大小，下面会细说。</p><p>AOF 文件中写入的所有命令以 Redis 的命令请求协议格式去保存，即 <a target="_blank" rel="noopener" href="http://redisdoc.com/topic/protocol.html">RESP</a> 格式。</p><p>有两种方式可以实现 AOF 功能的开关，如下，</p><ul><li>在 redis 配置文件 <strong>redis.conf</strong> 中有配置项 appendonly， yes 打开 AOF 功能，no 关闭 AOF 功能。</li><li>使用客户端命令<code>config set appendonly yes/no</code> 。</li></ul><h2 id="server- 相关变量">server 相关变量</h2><p>与 AOF 相关的 server 成员变量很多，这里只选择几个进行简要说明。先看后面的章节，之后再回头看本章节，也是个不错的主意。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> aof_state;                  <span class="hljs-comment">/* AOF_(ON|OFF|WAIT_REWRITE) */</span>
<span class="hljs-keyword">int</span> aof_fsync;                  <span class="hljs-comment">/* Kind of fsync() policy */</span>
<span class="hljs-keyword">char</span> *aof_filename;             <span class="hljs-comment">/* Name of the AOF file */</span>
<span class="hljs-keyword">int</span> aof_no_fsync_on_rewrite;    <span class="hljs-comment">/* Don&#x27;t fsync if a rewrite is in prog. */</span>
<span class="hljs-keyword">int</span> aof_rewrite_perc;           <span class="hljs-comment">/* Rewrite AOF if % growth is &gt; M and... */</span>
<span class="hljs-keyword">off_t</span> aof_rewrite_min_size;     <span class="hljs-comment">/* the AOF file is at least N bytes. */</span>
<span class="hljs-keyword">off_t</span> aof_rewrite_base_size;    <span class="hljs-comment">/* AOF size on latest startup or rewrite. */</span>
<span class="hljs-keyword">off_t</span> aof_current_size;         <span class="hljs-comment">/* AOF current size. */</span>
<span class="hljs-keyword">int</span> aof_rewrite_scheduled;      <span class="hljs-comment">/* Rewrite once BGSAVE terminates. */</span>
<span class="hljs-keyword">pid_t</span> aof_child_pid;            <span class="hljs-comment">/* PID if rewriting process */</span>
<span class="hljs-built_in">list</span> *aof_rewrite_buf_blocks;   <span class="hljs-comment">/* Hold changes during an AOF rewrite. */</span>
sds aof_buf;                   <span class="hljs-comment">/* AOF buffer, written before entering the event loop */</span>
<span class="hljs-keyword">int</span> aof_fd;                     <span class="hljs-comment">/* File descriptor of currently selected AOF file */</span>
<span class="hljs-keyword">int</span> aof_selected_db;            <span class="hljs-comment">/* Currently selected DB in AOF */</span>
<span class="hljs-keyword">time_t</span> aof_flush_postponed_start; <span class="hljs-comment">/* UNIX time of postponed AOF flush */</span>
<span class="hljs-keyword">time_t</span> aof_last_fsync;            <span class="hljs-comment">/* UNIX time of last fsync() */</span>
<span class="hljs-keyword">time_t</span> aof_rewrite_time_last;     <span class="hljs-comment">/* Time used by last AOF rewrite run. */</span>
<span class="hljs-keyword">time_t</span> aof_rewrite_time_start;    <span class="hljs-comment">/* Current AOF rewrite start time. */</span>
<span class="hljs-keyword">int</span> aof_lastbgrewrite_status;     <span class="hljs-comment">/* C_OK or C_ERR */</span>
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> aof_delayed_fsync;  <span class="hljs-comment">/* delayed AOF fsync() counter */</span>
<span class="hljs-keyword">int</span> aof_rewrite_incremental_fsync;<span class="hljs-comment">/* fsync incrementally while rewriting? */</span>
<span class="hljs-keyword">int</span> aof_last_write_status;        <span class="hljs-comment">/* C_OK or C_ERR */</span>
<span class="hljs-keyword">int</span> aof_last_write_errno;         <span class="hljs-comment">/* Valid if aof_last_write_status is ERR */</span>
<span class="hljs-keyword">int</span> aof_load_truncated;           <span class="hljs-comment">/* Don&#x27;t stop on unexpected AOF EOF. */</span></code></pre></div><h3 id="aof-fsync">aof_fsync</h3><p>表示 AOF 刷盘策略，后面会细说</p><h3 id="aof-child-pid">aof_child_pid</h3><p>由于 aofrewrite 是个耗时操作，因此会 fork 一个子进程去做这件事， aof_child_pid 就标识了子进程的 pid。</p><h3 id="aof-buf">aof_buf</h3><p>该变量保存着所有等待写入到 AOF 文件的协议文本。</p><h3 id="aof-rewrite-buf-blocks">aof_rewrite_buf_blocks</h3><p>该变量用来保存 aofrewrite 期间，server 处理过的需要写入 AOF 文件的协议文本。这个变量采用 list 结构，是考虑到分配到一个非常大的空间并不总是可能的，也可能产生大量的复制工作。</p><h3 id="aof-rewrite-scheduled">aof_rewrite_scheduled</h3><p>可取值有 0 和 1。</p><p>取 1 时，表示此时有子进程正在做 aofrewrite 操作，本次任务后延，等到 <code>serverCron</code> 执行时，合适的情况再执行。或者是执行了 <code>config set appendonly yes</code>, 想把 AOF 功能打开，此时执行的 aofrewrite 失败了，aof_state 仍然处于 <strong>AOF_WAIT_REWRITE</strong> 状态，此时 <strong>aof_rewrite_scheduled</strong> 也会置为 1，等下次再执行 aofrewrite。</p><h3 id="aof-state">aof_state</h3><p>表示 AOF 功能现在的状态，可取值如下，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AOF_OFF 0             <span class="hljs-comment">/* AOF is off */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AOF_ON 1              <span class="hljs-comment">/* AOF is on */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AOF_WAIT_REWRITE 2    <span class="hljs-comment">/* AOF waits rewrite to start appending */</span></span></code></pre></div><p><strong>AOF_OFF</strong> 表示 AOF 功能处于关闭状态，开关在上一节已经说过，默认 AOF 功能是关闭的。AOF 功能从 off switch 到 on 后，<strong>aof_state</strong> 会从 <strong>AOF_OFF</strong> 变为 <strong>AOF_WAIT_REWRITE</strong>，<code>startAppendOnly</code> 函数完成该逻辑。在 aofrewrite 一次之后，该变量才会从 <strong>AOF_WAIT_REWRITE</strong> 变为 <strong>AOF_ON</strong>。</p><p>可以看到从 ON 切换到 OFF 时，要经历一个中间状态 <strong>AOF_WAIT_REWRITE</strong>，那为何要这么设计呢？再来分析一下 <code>startAppendOnly</code> 函数的逻辑（代码去掉了打印日志的部分）。</p><div class="hljs"><pre><code class="hljs c">server.aof_fd = open(server.aof_filename,O_WRONLY|O_APPEND|O_CREAT,<span class="hljs-number">0644</span>);
serverAssert(server.aof_state == AOF_OFF);
<span class="hljs-keyword">if</span> (server.aof_fd == <span class="hljs-number">-1</span>) &#123;
    <span class="hljs-keyword">char</span> *cwdp = getcwd(cwd,MAXPATHLEN);
    <span class="hljs-keyword">return</span> C_ERR;
&#125;
<span class="hljs-keyword">if</span> (server.rdb_child_pid != <span class="hljs-number">-1</span>) &#123;
    server.aof_rewrite_scheduled = <span class="hljs-number">1</span>;
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rewriteAppendOnlyFileBackground() == C_ERR) &#123;
    close(server.aof_fd);
    <span class="hljs-keyword">return</span> C_ERR;
&#125;
server.aof_state = AOF_WAIT_REWRITE;</code></pre></div><p>【1】打开 aof 文件，默认名为 appendonly.aof，没有的话就新建空文件，失败则返回。</p><p>【2】切换后，需要做一次 aofrewrite，将 server 中现有的数据转换成协议文本，写到 AOF 文件。但是，这里要 <strong>注意</strong>，如果此时有子进程在做 bgrdb，那么此次 aofrewrite 需要任务延缓，即 <strong>aof_rewrite_scheduled</strong> 置为 1。</p><p>【3】将 <strong>aof_state</strong> 置为 <strong>AOF_WAIT_REWRITE</strong> 状态。</p><p>而做完第一次 aofrewrite 后，<strong>AOF_WAIT_REWRITE</strong> 转换成 <strong>AOF_ON</strong>，如下，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backgroundRewriteDoneHandler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> exitcode, <span class="hljs-keyword">int</span> bysignal)</span> </span>&#123;
    ...
    <span class="hljs-keyword">if</span> (server.aof_state == AOF_WAIT_REWRITE)
        server.aof_state = AOF_ON;
    ...
&#125;</code></pre></div><p>仔细分析源码发现，在 AOF 持久化的命令追加阶段（后面章节细讲），有如下逻辑,</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">feedAppendOnlyFile</span><span class="hljs-params">(struct redisCommand *cmd, <span class="hljs-keyword">int</span> dictid, robj **argv, <span class="hljs-keyword">int</span> argc)</span> </span>&#123;
    ...
    <span class="hljs-keyword">if</span> (server.aof_state == AOF_ON)
        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));
    <span class="hljs-keyword">if</span> (server.aof_child_pid != <span class="hljs-number">-1</span>)
        aofRewriteBufferAppend((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)buf,sdslen(buf));
    ...
&#125;</code></pre></div><p>很明显，刚开启 AOF 时， <strong>aof_state</strong> 为 <strong>AOF_WAIT_REWRITE</strong> ，处理好的协议文本 buf 无法写入 <strong>aof_buf</strong> 变量 ，但必须写入 <strong>aof_rewrite_buf_blocks</strong> 变量（数据在 aofrewrite 的最后阶段会被写进 AOF 文件）。</p><p>这里是否将命令 append 到 <strong>aof_state</strong> 的判断至关重要，如果修改条件为 <code>server.aof_state != AOF_OFF</code> ，<strong>考虑如下情况</strong>。</p><p>AOF 状态刚打开，尚未完成第一次 aofrewrite，也即，一边 Child 进程数据库中现有数据还未写进 AOF 文件，另一边 Parent 进程仍然持续处理 client 请求，于是，Parent 进程在指定的数据刷盘策略下，将 <strong>aof_buf</strong> 刷盘。如果这时宕机了，当 server 重启后，加载 AOF 文件，在内存中塞入数据，实际上对于用户来说，这部分数据算是脏数据了，因为 AOF 并没有成功打开，未开启 AOF 状态时，数据都在内存中，宕机后，数据会全部丢掉。增加这个中间状态就是为了应对这种情况。所以， <strong>AOF_WAIT_REWRITE</strong> 状态存在的时间范围起始于 <code>startAppendOnly</code> ，到完成第一次 aofrewrite 后切成 <strong>AOF_ON</strong> 。aofrewrite 后再发生宕机，丢失的数据就少多了。</p><p><strong>这只是我个人的理解，不一定正确，欢迎大家斧正。</strong></p><p>另外，如果开启了 AOF，在 redis 启动 加载 AOF 文件时，<strong>aof_state</strong> 也会暂时设置成 <strong>AOF_OFF</strong>，加载完毕之后设置为 <strong>AOF_ON</strong>。</p><h3 id="aof-pipe">aof_pipe_*</h3><p>为了提高 aofrewrite 效率，Redis 通过在父子进程间建立管道，把 aofrewrite 期间的写命令通过管道同步给子进程，追加写盘的操作也就转交给了子进程。aof_pipe_* 变量就是这部分会用到的管道。</p><h2 id="AOF- 持久化">AOF 持久化</h2><h3 id="命令追加">命令追加</h3><p>AOF 功能开启后，每次导致数据库状态发生变化的命令都会经过 <strong>函数</strong> <code>feedAppendOnlyFile</code> 累积到 <strong>aof_buf</strong> 变量中。如果后台有正在执行的 aofrewrite 任务，还会写一份数据到 <strong>aof_rewrite_buf_blocks</strong> 变量中。</p><h4 id="feedAppendOnlyFile- 函数">feedAppendOnlyFile 函数</h4><p>在该函数中，首先要将数据库切换到当前数据库（ <strong>aof_selected_db</strong> 更新），在 buf 中插入一条 <strong>SELECT</strong> 命令。</p><div class="hljs"><pre><code class="hljs c">sds buf = sdsempty();
<span class="hljs-keyword">if</span> (dictid != server.aof_selected_db) &#123;
    <span class="hljs-keyword">char</span> seldb[<span class="hljs-number">64</span>];
    <span class="hljs-built_in">snprintf</span>(seldb,<span class="hljs-keyword">sizeof</span>(seldb),<span class="hljs-string">&quot;%d&quot;</span>,dictid);
    buf = sdscatprintf(buf,<span class="hljs-string">&quot;*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n&quot;</span>, (<span class="hljs-keyword">unsigned</span>        <span class="hljs-keyword">long</span>)<span class="hljs-built_in">strlen</span>(seldb),seldb);
    server.aof_selected_db = dictid;
&#125;</code></pre></div><p>然后在对需要加入 buf 的命令进行分类处理。</p><p>【1】带有过期时间的命令，调用函数 <code>catAppendOnlyExpireAtCommand</code> 进行协议文本 buf 组装。<strong>EXPIRE</strong>/<strong>PEXPIRE</strong>/<strong>EXPIREAT</strong> 这三个命令直接调用该函数，而 <strong>SETEX</strong>/<strong>PSETEX</strong> 这两个命令需要在调用之前加入一个 <strong>SET</strong> 命令。即，</p><div class="hljs"><pre><code class="hljs c">tmpargv[<span class="hljs-number">0</span>] = createStringObject(<span class="hljs-string">&quot;SET&quot;</span>,<span class="hljs-number">3</span>);
tmpargv[<span class="hljs-number">1</span>] = argv[<span class="hljs-number">1</span>];
tmpargv[<span class="hljs-number">2</span>] = argv[<span class="hljs-number">3</span>];
buf = catAppendOnlyGenericCommand(buf,<span class="hljs-number">3</span>,tmpargv);

decrRefCount(tmpargv[<span class="hljs-number">0</span>]);
buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="hljs-number">1</span>],argv[<span class="hljs-number">2</span>]);</code></pre></div><p>【2】普通命令，直接调用函数 <code>catAppendOnlyGenericCommand</code> 进行协议文本 buf 组装。</p><h4 id="catAppendOnlyExpireAtCommand- 函数">catAppendOnlyExpireAtCommand 函数</h4><p>该函数其实就是将所有与过期时间相关的命令转成 <strong>PEXPIREAT</strong> 命令，细化到毫秒。最后调用普通命令组装 buf 函数 <code>catAppendOnlyGenericCommand</code>。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">// 构建 PEXPIREAT 命令</span>
argv[<span class="hljs-number">0</span>] = createStringObject(<span class="hljs-string">&quot;PEXPIREAT&quot;</span>,<span class="hljs-number">9</span>);
argv[<span class="hljs-number">1</span>] = key;
argv[<span class="hljs-number">2</span>] = createStringObjectFromLongLong(when);

<span class="hljs-comment">// 调用 aof 公共函数</span>
buf = catAppendOnlyGenericCommand(buf, <span class="hljs-number">3</span>, argv);</code></pre></div><h4 id="catAppendOnlyGenericCommand- 函数">catAppendOnlyGenericCommand 函数</h4><p>该函数用来把 redis 命令转换成 RESP 协议文本。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">sds <span class="hljs-title">catAppendOnlyGenericCommand</span><span class="hljs-params">(sds dst, <span class="hljs-keyword">int</span> argc, robj **argv)</span> </span>&#123;
    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">32</span>];
    <span class="hljs-keyword">int</span> len, j;
    robj *o;

    <span class="hljs-comment">// 比如 *3\r\n</span>
    buf[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;*&#x27;</span>;
    len = <span class="hljs-number">1</span>+ll2string(buf+<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(buf)<span class="hljs-number">-1</span>,argc);
    buf[len++] = <span class="hljs-string">&#x27;\r&#x27;</span>;
    buf[len++] = <span class="hljs-string">&#x27;\n&#x27;</span>;
    dst = sdscatlen(dst,buf,len);

    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; argc; j++) &#123;
        o = getDecodedObject(argv[j]);
        buf[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;$&#x27;</span>;
        len = <span class="hljs-number">1</span>+ll2string(buf+<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(buf)<span class="hljs-number">-1</span>,sdslen(o-&gt;ptr));
        buf[len++] = <span class="hljs-string">&#x27;\r&#x27;</span>;
        buf[len++] = <span class="hljs-string">&#x27;\n&#x27;</span>;
        dst = sdscatlen(dst,buf,len);
        dst = sdscatlen(dst,o-&gt;ptr,sdslen(o-&gt;ptr));
        dst = sdscatlen(dst,<span class="hljs-string">&quot;\r\n&quot;</span>,<span class="hljs-number">2</span>);
        decrRefCount(o);
    &#125;
    <span class="hljs-keyword">return</span> dst;
&#125;</code></pre></div><p>可以看到，定义了一个 buf 数组，反复使用，通过 len 精确控制 append 到 dst 后的长度。</p><h4 id="aofRewriteBufferAppend- 函数">aofRewriteBufferAppend 函数</h4><p><strong>aof_rewrite_buf_blocks</strong> 变量是一个 list 结构，其中每一个元素都是一个大小为 10M 的 block</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AOF_RW_BUF_BLOCK_SIZE (1024*1024*10)    <span class="hljs-comment">/* 10 MB per block */</span></span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">aofrwblock</span> &#123;</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> used, <span class="hljs-built_in">free</span>;
    <span class="hljs-keyword">char</span> buf[AOF_RW_BUF_BLOCK_SIZE];
&#125; aofrwblock;</code></pre></div><p>这个函数做了两件事情。</p><p>一是，将 <code>catAppendOnlyGenericCommand</code> 获得的协议文本 buf 存到 <strong>aof_rewrite_buf_blocks</strong> 变量，首先拿出来 list 最后一个 block，如果装不下，那先把最后一个 block 填满，剩下的再申请内存。</p><div class="hljs"><pre><code class="hljs c">listNode *ln = listLast(server.aof_rewrite_buf_blocks); <span class="hljs-comment">// 指向最后一个缓存块</span>
aofrwblock *block = ln ? ln-&gt;value : <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">while</span>(len) &#123;
    <span class="hljs-keyword">if</span> (block) &#123; <span class="hljs-comment">// 如果已经有至少一个缓存块，那么尝试将内容追加到这个缓存块里面</span>
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> thislen = (block-&gt;<span class="hljs-built_in">free</span> &lt; len) ? block-&gt;<span class="hljs-built_in">free</span> : len;
        <span class="hljs-keyword">if</span> (thislen) &#123;  <span class="hljs-comment">/* The current block is not already full. */</span>
            <span class="hljs-built_in">memcpy</span>(block-&gt;buf+block-&gt;used, s, thislen);
            block-&gt;used += thislen;
            block-&gt;<span class="hljs-built_in">free</span> -= thislen;
            s += thislen;
            len -= thislen;
        &#125;
    &#125;
    <span class="hljs-keyword">if</span> (len) &#123;  <span class="hljs-comment">// 最后一个缓存块没有放得下本次 data，那再申请一个 block</span>
        <span class="hljs-keyword">int</span> numblocks;
        block = zmalloc(<span class="hljs-keyword">sizeof</span>(*block));
        block-&gt;<span class="hljs-built_in">free</span> = AOF_RW_BUF_BLOCK_SIZE;
        block-&gt;used = <span class="hljs-number">0</span>;
        listAddNodeTail(server.aof_rewrite_buf_blocks,block);
        ... ...
    &#125;
&#125;</code></pre></div><p>二是，给 <strong>aof_pipe_write_data_to_child</strong> 这个 fd 注册写事件，回调函数为 <code>aofChildWriteDiffData</code>。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* Install a file event to send data to the rewrite child if there is</span>
<span class="hljs-comment">     * not one already. */</span>
<span class="hljs-keyword">if</span> (aeGetFileEvents(server.el,server.aof_pipe_write_data_to_child) == <span class="hljs-number">0</span>) &#123;
    aeCreateFileEvent(server.el, server.aof_pipe_write_data_to_child,
                      AE_WRITABLE, aofChildWriteDiffData, <span class="hljs-literal">NULL</span>);
&#125;</code></pre></div><p>这个属于 aof 重写的逻辑，后面章节会细说，这里先留个心。</p><h4 id="何时进行命令追加">何时进行命令追加</h4><p>也就是说，什么时候会调用<code>feedAppendOnlyFile</code> 呢？有以下两个时机。</p><h5 id="propagate- 函数">propagate 函数</h5><p>大家都知道，Redis 中命令执行的流程，即 <code>processCommand</code> -&gt; <code>call</code> 。在 <code>call</code> 函数中会把某些命令写入 AOF 文件。如何判断某个命令是否需要写入 AOF 呢？</p><p>在 server 结构体中维持了一个 <strong>dirty</strong> 计数器，<strong>dirty</strong> 记录的是服务器状态进行了多少次修改，每次做完 save/bgsave 执行完成后，会将 <strong>dirty</strong> 清 0，而使得服务器状态修改的命令一般都需要写入 AOF 文件和主从同步（排除某些特殊情况）。</p><div class="hljs"><pre><code class="hljs c">dirty = server.dirty;
c-&gt;cmd-&gt;proc(c);
dirty = server.dirty-dirty;
...
<span class="hljs-keyword">if</span> (propagate_flags != PROPAGATE_NONE)
    propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);</code></pre></div><p>在 <code>propagate</code> 函数中就会调用到 <code>feedAppendOnlyFile</code>。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">propagate</span><span class="hljs-params">(struct redisCommand *cmd, <span class="hljs-keyword">int</span> dbid, robj **argv, <span class="hljs-keyword">int</span> argc,</span></span>
<span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">int</span> flags)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span> (server.aof_state != AOF_OFF &amp;&amp; flags &amp; PROPAGATE_AOF)
        feedAppendOnlyFile(cmd,dbid,argv,argc);
    <span class="hljs-keyword">if</span> (flags &amp; PROPAGATE_REPL)
        replicationFeedSlaves(server.slaves,dbid,argv,argc);
&#125;</code></pre></div><h5 id="propagateExpire- 函数">propagateExpire 函数</h5><p>当内存中带有过期时间的 key 过期时，会向 AOF 写入 <strong>del</strong> 命令。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">propagateExpire</span><span class="hljs-params">(redisDb *db, robj *key)</span> </span>&#123;
    ...
    <span class="hljs-keyword">if</span> (server.aof_state != AOF_OFF)
        feedAppendOnlyFile(server.delCommand,db-&gt;id,argv,<span class="hljs-number">2</span>);
    replicationFeedSlaves(server.slaves,db-&gt;id,argv,<span class="hljs-number">2</span>);
    ...
&#125;</code></pre></div><p><code>propagateExpire</code> 函数在一些检查 key 是否过期时会调用。</p><h3 id="文件的写入与同步">文件的写入与同步</h3><p>上一步中，将需要写入 AOF 文件的数据先写到了 <strong>aof_buf</strong> 变量中，那么，接下来说一下如何将 <strong>aof_buf</strong> 的内容写进 AOF 文件。</p><h4 id="同步策略">同步策略</h4><blockquote><p>为了提高文件的写入效率，在现代操作系统中，当用户调用 <code>write</code> 函数试，将一些数据写入到文件的时候，操作系统通常会将写入的数据保存在一个内存缓冲区里，等到缓冲区的空间被填满，或者超过了指定的时限后，才真正地将缓冲区中的数据写入磁盘。</p><p>这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机宕机，那么保存在内存缓冲区里面的写入数据将会丢失。</p><p>为此，系统提供了 <code>fsync</code> 和 <code>fdatasync</code> 两个同步函数，它们可以强制让操作系统立即将缓存区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p></blockquote><p>要知道，这两个系统调用函数都是阻塞式的，针对如何协调文件写入与同步的关系，该版本 Redis 支持 3 种同步策略，可在配置文件中使用 <strong>appendfsync</strong> 项进行配置，有如下取值，</p><ul><li><p>always。每次有新命令追加到 AOF 文件 时就执行一次同步，, 安全性最高，但是性能影响最大。</p></li><li><p>everysec。每秒执行一次同步。宕机只会丢失一秒钟的命令。这算是一个折中方案。</p></li><li><p>no。将数据同步操作完全交由操作系统处理，性能最好，但是数据可靠性最差。宕机将丢失同步 AOF 文件后的所有写命令。</p></li></ul><p>在 Redis 源码中， 当程序运行在 Linux 系统上时，执行的是 <code>fdatasync</code> 函数，而在其他系统上，则会执行 <code>fsync</code> 函数，即，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __linux__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> aof_fsync fdatasync</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> aof_fsync fsync</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre></div><p><strong>注</strong>：以下叙述均以 <code>fsync</code> 代称。</p><h4 id="如何写入文件">如何写入文件</h4><p>写入文件的逻辑在 <code>flushAppendOnlyFile</code> 函数中实现。下面分两部分来看主要代码。</p><h5 id="文件写入 -，write- 系统调用">文件写入 **，<code>write</code> ** 系统调用</h5><div class="hljs"><pre><code class="hljs c">...

<span class="hljs-comment">// aof 缓存区内没有数据需要写入 disk，无需处理</span>
<span class="hljs-keyword">if</span> (sdslen(server.aof_buf) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;

<span class="hljs-comment">// 如果 sync policy 设置成 everysec，</span>
<span class="hljs-comment">// sync_in_progress 表示是否有 fsync 任务在后台</span>
<span class="hljs-keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)
    sync_in_progress = bioPendingJobsOfType(BIO_AOF_FSYNC) != <span class="hljs-number">0</span>;

<span class="hljs-comment">// force=0(非强制写入)时，如果后台有 fsync 任务，推迟此次写入，但推迟时间不超过 2s</span>
<span class="hljs-keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) &#123;
    <span class="hljs-keyword">if</span> (sync_in_progress) &#123;
        <span class="hljs-keyword">if</span> (server.aof_flush_postponed_start == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 首次推迟 write，一次推迟 2s</span>
            server.aof_flush_postponed_start = server.unixtime;
            <span class="hljs-keyword">return</span>;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (server.unixtime - server.aof_flush_postponed_start &lt; <span class="hljs-number">2</span>) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;

        <span class="hljs-comment">// 否则，通过，继续写，因为我们不能等待超过 2s</span>
        server.aof_delayed_fsync++;
        serverLog(LL_NOTICE,<span class="hljs-string">&quot;Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.&quot;</span>);
    &#125;
&#125;
...
<span class="hljs-comment">// 将 aof 缓冲区的内容写到系统缓存区</span>
nwritten = write(server.aof_fd, server.aof_buf, sdslen(server.aof_buf));
...
<span class="hljs-comment">// 执行了 write 操作，所以要清零延迟 flush 的时间</span>
server.aof_flush_postponed_start = <span class="hljs-number">0</span>;</code></pre></div><p>首先会判断 <strong>aof_buf</strong> 是否为空，如果是，那么不需要执行下面的逻辑，直接返回。</p><p>如果同步策略为 everysec，那么需要查看是否有 <strong>fsync</strong> 任务在后台，调用 <strong>fsync</strong> 使用的是 Redis 中 bio ，如果对这个还不了解，可以参考我之前的文章 《 <a target="_blank" rel="noopener" href="http://tech-happen.site/de55b491.html">Redis Bio 详解</a> 》。为什么要做这个判断呢？</p><blockquote><p>当 <code>fsync</code> 和 <code>write</code> 同一个 fd 时，<code>write</code> 必然阻塞。 当系统 IO 非常繁忙时， <code>fsync</code>() 可能会阻塞， 即使系统 IO 不繁忙， <code>fsync</code> 也会因为数据量大而慢。</p></blockquote><p>因此对于 everysec 策略，需要尽量保证 <code>fsync</code> 和 <code>write</code> 不同时操作同一个 fd。no 策略完全把 <code>fsync</code> 交给了操作系统，操作系统什么时候 <code>fsync</code> ，无从得知。always 策略则是每次都要主从调用 <code>fsync</code>，也没必要做判断。因此，这里的判断，只针对 everysec 策略有效。</p><p>对于 everysec 策略，如果有 <code>fsync</code> 在执行，那么本次 <code>write</code> <strong>推迟 2 秒钟</strong>，等到下次在进入本函数时，如果推迟时间超过 2 秒，那么更新 <strong>aof_delayed_fsync</strong> 值（info 里可以查到），打印日志 ” <strong>Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.</strong> “ ，之后进行 <code>write</code> 系统调用。当然了，系统也提供了 force 选项，去跳过这项是否要推迟 <code>write</code> 的检查。</p><p><code>write</code> 之后，将 <strong>aof_flush_postponed_start</strong> 推迟开始计时值清零，迎接下次检查。</p><p>所以说，AOF 执行 everysec 策略时，如果恰好有 <code>fsync</code> 在长时间的执行，Redis 意外关闭会丢失最多两秒的数据。如果 <code>fsync</code> 运行正常，只有当操作系统 crash 时才会造成最多 1 秒的数据丢失。</p><h5 id="收尾工作，-write- 结果处理">收尾工作， <code>write</code> 结果处理</h5><p><code>write</code> 调用结果可能是正常的，也可能是异常的，那么需要做不同的处理。首先主要看异常处理，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (nwritten != (<span class="hljs-keyword">signed</span>)sdslen(server.aof_buf)) &#123;
    ...
    <span class="hljs-comment">/* Log the AOF write error and record the error code. */</span>
    <span class="hljs-keyword">if</span> (nwritten == <span class="hljs-number">-1</span>) &#123;
        ...
    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果仅写了一部分，发生错误</span>
    <span class="hljs-comment">// 将追加的内容截断，删除了追加的内容，恢复成原来的文件</span>
        <span class="hljs-keyword">if</span> (ftruncate(server.aof_fd, server.aof_current_size) == <span class="hljs-number">-1</span>) &#123;
            ...
        &#125; <span class="hljs-keyword">else</span> &#123;
            nwritten = <span class="hljs-number">-1</span>;
        &#125;
        server.aof_last_write_errno = ENOSPC;
    &#125;

    <span class="hljs-comment">// 如果是写入的策略为每次写入就同步，无法恢复这种策略的写，因为我们已经告知使用者，已经将写的数据同步到磁盘了，因此直接退出程序</span>
    <span class="hljs-keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;
        ...
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// 设置执行 write 操作的状态</span>
        server.aof_last_write_status = C_ERR;
        <span class="hljs-keyword">if</span> (nwritten &gt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// 只能更新当前的 AOF 文件的大小</span>
            server.aof_current_size += nwritten;
            <span class="hljs-comment">// 删除 AOF 缓冲区写入的字节</span>
            sdsrange(server.aof_buf,nwritten,<span class="hljs-number">-1</span>);
        &#125;
        <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* We&#x27;ll try again on the next call... */</span>
    &#125;
&#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">/* Successful write(2). If AOF was in error state, restore the</span>
<span class="hljs-comment">     * OK state and log the event.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">if</span> (server.aof_last_write_status == C_ERR) &#123;
        serverLog(LL_WARNING, <span class="hljs-string">&quot;AOF write error looks solved, Redis can write again.&quot;</span>);
        server.aof_last_write_status = C_OK;
    &#125;
&#125;</code></pre></div><p>写入异常的判断，<code>nwritten != (signed)sdslen(server.aof_buf)</code>，<code>write</code> 的数据量与 <strong>aof_buf</strong> 的大小不同。当完全没写入时，打个日志就算了；当仅写入了一部分数据时，使用 <code>ftruncate</code> 函数把 AOF 文件的内容恢复成原来的大小，以备下次重新写入，<strong>nwritten</strong> 置为 -1。使用 <code>ftruncate</code> 的原因是怕操作系统执行了 <code>fsync</code>，因此需要把 AOF 文件的大小恢复。</p><p>如果执行的是 always 同步策略，那么需要返回会客户端错误。对于其他策略，更新 <code>aof_last_write_status</code> ，以便知道上一次做 <code>write</code> 的结果，对于未完全写入的情况，如果上面执行的 <code>ftruncate</code> 失败，此时 <code>nwritten &gt; 0</code>，需要更新 <strong>aof_current_size</strong>，从 <strong>aof_buf</strong> 中减去已经写入的，防止下次有重复数据写入，然后返回。</p><p>如果写入成功，那么视情况更新 <code>aof_last_write_status</code>，表示此次 <code>write</code> 成功。</p><p>下面主要是正常情况的处理。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* nwritten = -1 时走不到这个步骤 */</span>
server.aof_current_size += nwritten; <span class="hljs-comment">// 正常 write，更新 aof_current_size</span>

<span class="hljs-comment">/* Re-use AOF buffer when it is small enough. The maximum comes from the</span>
<span class="hljs-comment"> * arena size of 4k minus some overhead (but is otherwise arbitrary).</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">if</span> ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &lt; <span class="hljs-number">4000</span>) &#123;
    sdsclear(server.aof_buf);
&#125; <span class="hljs-keyword">else</span> &#123;
    sdsfree(server.aof_buf);
    server.aof_buf = sdsempty();
&#125;

<span class="hljs-comment">/* Don&#x27;t fsync if no-appendfsync-on-rewrite is set to yes and there are</span>
<span class="hljs-comment"> * children doing I/O in the background. */</span>
<span class="hljs-keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp; (server.aof_child_pid != <span class="hljs-number">-1</span> || server.rdb_child_pid != <span class="hljs-number">-1</span>)) <span class="hljs-keyword">return</span>;

<span class="hljs-comment">/* Perform the fsync if needed. */</span>
<span class="hljs-keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;
    <span class="hljs-comment">/* aof_fsync is defined as fdatasync() for Linux in order to avoid</span>
<span class="hljs-comment">         * flushing metadata. */</span>
    latencyStartMonitor(latency);
    aof_fsync(server.aof_fd); <span class="hljs-comment">/* Let&#x27;s try to get this data on the disk */</span>
    latencyEndMonitor(latency);
    latencyAddSampleIfNeeded(<span class="hljs-string">&quot;aof-fsync-always&quot;</span>,latency);
    server.aof_last_fsync = server.unixtime;
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;
            server.unixtime &gt; server.aof_last_fsync)) &#123;
    <span class="hljs-keyword">if</span> (!sync_in_progress) aof_background_fsync(server.aof_fd); <span class="hljs-comment">// 如果没有正在执行同步，那么创建一个后台任务</span>
    server.aof_last_fsync = server.unixtime;
&#125;</code></pre></div><p><strong>aof_buf</strong> 清空，然后根据不同策略进行同步。always 策略时，主动调用 <code>fsync</code>; everysec 策略，则创建 fsync bio 任务。</p><p>另外，有配置项 no-appendfsync-on-rewrite 去决定，当子进程在做 aofrewrite/bgsave 时是否要进行 <code>fsync</code>。</p><h4 id="何时进行文件写入">何时进行文件写入</h4><p>也就是，什么时候会调用 <code>flushAppendOnlyFile</code> 函数，有以下三个时机。</p><h5 id="beforeSleep- 函数">beforeSleep 函数</h5><blockquote><p>Redis 的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端请求，以及向客户端发送命令回复，而时间事件则负责像 <code>serverCron</code> 函数这样需要定时运行的函数。</p></blockquote><p>对于 Redis 的事件机制可以参考我之前的文章 《<a target="_blank" rel="noopener" href="http://tech-happen.site/85f7b0b4.html">Redis 中的事件</a>》。</p><p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到 <strong>aof_buf</strong> 缓冲区里面，所以在服务器每次结束一个事件循环之前，都会调用 <code>flushAppendOnlyFile</code> 函数，考虑是否需要将 <strong>aof_buf</strong> 缓冲区中的内容写入和同步到 AOF 文件里面。即，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">beforeSleep</span><span class="hljs-params">(struct aeEventLoop *eventLoop)</span> </span>&#123;
    ...
    <span class="hljs-comment">/* Write the AOF buffer on disk */</span>
    flushAppendOnlyFile(<span class="hljs-number">0</span>);
    ...
&#125;</code></pre></div><p>这里的调用是非强制写入（force = 0）。</p><h5 id="serverCron- 函数">serverCron 函数</h5><p>Redis 中的时间事件，定期执行 <code>serverCron</code> 函数（从 Redis 2.8 开始，用户可以通过修改 <strong>hz</strong> 选项来调整 <code>serverCron</code>的每秒执行次数），做一些杂事，比如更新服务器各项统计信息、关闭清理客户端、做 AOF 和 RDB 等。</p><div class="hljs"><pre><code class="hljs c">  <span class="hljs-comment">/* AOF postponed flush: Try at every cron cycle if the slow fsync completed. */</span>
<span class="hljs-keyword">if</span> (server.aof_flush_postponed_start) flushAppendOnlyFile(<span class="hljs-number">0</span>);</code></pre></div><p>如果上次 AOF 写入推迟了，那么再次尝试非强制写入。</p><div class="hljs"><pre><code class="hljs c">run_with_period(<span class="hljs-number">1000</span>) &#123;
    <span class="hljs-keyword">if</span> (server.aof_last_write_status == C_ERR)
        flushAppendOnlyFile(<span class="hljs-number">0</span>);
&#125;</code></pre></div><p>每秒钟检查，如果上次写入 AOF 文件失败了，再次尝试非强制写入。因为需要及时去处理 <code>aof_buf</code>，以及重置 AOF 写入状态的变量 <strong>aof_last_write_status</strong>，每秒做检查，这个频率是足够的。</p><h5 id="stopAppendOnly- 函数">stopAppendOnly 函数</h5><p>当 AOF 功能要关闭时，会调用 <code>stopAppendOnly</code> 函数，尝试一次强制写入，即尽最大努力去保存最多的数据。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stopAppendOnly</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    serverAssert(server.aof_state != AOF_OFF);
    flushAppendOnlyFile(<span class="hljs-number">1</span>);
    aof_fsync(server.aof_fd);
    close(server.aof_fd);
&#125;</code></pre></div><p>强制写入，并刷盘。</p><h2 id="AOF- 文件载入">AOF 文件载入</h2><p>当 Redis 服务器进程启动时，需要调用 <code>loadDataFromDisk</code> 函数去加载数据。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadDataFromDisk</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> start = ustime();
    <span class="hljs-keyword">if</span> (server.aof_state == AOF_ON) &#123; <span class="hljs-comment">// 开启了 aof</span>
        <span class="hljs-keyword">if</span> (loadAppendOnlyFile(server.aof_filename) == C_OK)
            serverLog(LL_NOTICE,<span class="hljs-string">&quot;DB loaded from append only file: %.3f seconds&quot;</span>,(<span class="hljs-keyword">float</span>)(ustime()-start)/<span class="hljs-number">1000000</span>);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">if</span> (rdbLoad(server.rdb_filename) == C_OK) &#123;
            serverLog(LL_NOTICE,<span class="hljs-string">&quot;DB loaded from disk: %.3f seconds&quot;</span>,
                (<span class="hljs-keyword">float</span>)(ustime()-start)/<span class="hljs-number">1000000</span>);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (errno != ENOENT) &#123;
            serverLog(LL_WARNING,<span class="hljs-string">&quot;Fatal error loading the DB: %s. Exiting.&quot;</span>,strerror(errno));
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
        &#125;
    &#125;
&#125;</code></pre></div><p>可以看到，如果开启了 AOF 功能，就会调用 <code>loadAppendOnlyFile</code> 函数，加载 AOF 文件中的数据到内存中。否则，会去调用 <code>rdbLoad</code> 函数，加载 RDB 文件。加载 AOF 文件的设计很有意思。</p><div class="hljs"><pre><code class="hljs c">FILE *fp = fopen(filename,<span class="hljs-string">&quot;r&quot;</span>);
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redis_stat</span> <span class="hljs-title">sb</span>;</span>
<span class="hljs-keyword">int</span> old_aof_state = server.aof_state;
<span class="hljs-keyword">long</span> loops = <span class="hljs-number">0</span>;
<span class="hljs-keyword">off_t</span> valid_up_to = <span class="hljs-number">0</span>; <span class="hljs-comment">/* Offset of the latest well-formed command loaded. */</span>

<span class="hljs-comment">// 检查文件的正确性, 存在，并且不为空</span>
<span class="hljs-keyword">if</span> (fp &amp;&amp; redis_fstat(fileno(fp),&amp;sb) != <span class="hljs-number">-1</span> &amp;&amp; sb.st_size == <span class="hljs-number">0</span>) &#123;
    server.aof_current_size = <span class="hljs-number">0</span>;
    fclose(fp);
    <span class="hljs-keyword">return</span> C_ERR;
&#125;
<span class="hljs-keyword">if</span> (fp == <span class="hljs-literal">NULL</span>) &#123;
    serverLog(LL_WARNING,<span class="hljs-string">&quot;Fatal error: can&#x27;t open the append log file for reading: %s&quot;</span>,strerror(errno));
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
&#125;
<span class="hljs-comment">// 暂时关掉 AOF, 防止向该 filename 中写入新的 AOF 数据</span>
server.aof_state = AOF_OFF;</code></pre></div><p>首先，空文件没有必要再去加载了，提前返回。</p><p>然后，暂时关闭 AOF 功能，这是为了防止在加载 AOF 文件的过程中，又有新的数据写进来</p><div class="hljs"><pre><code class="hljs c">fakeClient = createFakeClient(); <span class="hljs-comment">// 创建一个不带网络连接的伪客户端</span>
startLoading(fp);                <span class="hljs-comment">// 标记正在 load db，loading = 1</span>

<span class="hljs-comment">// 读 AOF 文件</span>
<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;
    <span class="hljs-keyword">int</span> argc, j;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len;
    robj **argv;
    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">128</span>];
    sds argsds;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisCommand</span> *<span class="hljs-title">cmd</span>;</span>
    ... ...
        <span class="hljs-comment">// 如执行命令 SET keytest val，那么写入 AOF 文件中的格式为</span>
        <span class="hljs-comment">// *3\r\n$3\r\nSET\r\n$7\r\nkeytest\r\n$3\r\nval\r\n</span>
        <span class="hljs-keyword">if</span> (fgets(buf,<span class="hljs-keyword">sizeof</span>(buf),fp) == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 按行读取 AOF 文件，*3</span>
            <span class="hljs-keyword">if</span> (feof(fp))
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">goto</span> readerr;
        &#125;

    <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">goto</span> fmterr; <span class="hljs-comment">// 判断协议是否正确</span>
    <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>) <span class="hljs-keyword">goto</span> readerr; <span class="hljs-comment">// 数据完整判断</span>
    argc = atoi(buf+<span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">goto</span> fmterr;

    argv = zmalloc(<span class="hljs-keyword">sizeof</span>(robj*)*argc);
    fakeClient-&gt;argc = argc;
    fakeClient-&gt;argv = argv;

    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; argc; j++) &#123;
        <span class="hljs-keyword">if</span> (fgets(buf,<span class="hljs-keyword">sizeof</span>(buf),fp) == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 依次读到 $3, $7, $3</span>
            fakeClient-&gt;argc = j; <span class="hljs-comment">/* Free up to j-1. */</span>
            freeFakeClientArgv(fakeClient);
            <span class="hljs-keyword">goto</span> readerr;
        &#125;
        <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;$&#x27;</span>) <span class="hljs-keyword">goto</span> fmterr;
        len = strtol(buf+<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">10</span>); <span class="hljs-comment">// 参数长度</span>
        argsds = sdsnewlen(<span class="hljs-literal">NULL</span>,len);
        <span class="hljs-keyword">if</span> (len &amp;&amp; fread(argsds,len,<span class="hljs-number">1</span>,fp) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 依次读到 SET/ keytest/ val</span>
            sdsfree(argsds);
            fakeClient-&gt;argc = j; <span class="hljs-comment">/* Free up to j-1. */</span>
            freeFakeClientArgv(fakeClient);
            <span class="hljs-keyword">goto</span> readerr;
        &#125;
        argv[j] = createObject(OBJ_STRING,argsds);
        <span class="hljs-keyword">if</span> (fread(buf,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,fp) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 读到 \r\n</span>
            fakeClient-&gt;argc = j+<span class="hljs-number">1</span>; <span class="hljs-comment">/* Free up to j. */</span>
            freeFakeClientArgv(fakeClient);
            <span class="hljs-keyword">goto</span> readerr; <span class="hljs-comment">/* discard CRLF */</span>
        &#125;
    &#125;

    <span class="hljs-comment">/* Command lookup */</span>
    cmd = lookupCommand(argv[<span class="hljs-number">0</span>]-&gt;ptr);
    <span class="hljs-keyword">if</span> (!cmd) &#123;
        serverLog(LL_WARNING,<span class="hljs-string">&quot;Unknown command &#x27;%s&#x27; reading the append only file&quot;</span>, (<span class="hljs-keyword">char</span>*)argv[<span class="hljs-number">0</span>]-&gt;ptr);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    &#125;

    <span class="hljs-comment">/* Run the command in the context of a fake client */</span>
    cmd-&gt;proc(fakeClient);

    <span class="hljs-comment">/* The fake client should not have a reply */</span>
    serverAssert(fakeClient-&gt;bufpos == <span class="hljs-number">0</span> &amp;&amp; listLength(fakeClient-&gt;reply) == <span class="hljs-number">0</span>);
    <span class="hljs-comment">/* The fake client should never get blocked */</span>
    serverAssert((fakeClient-&gt;flags &amp; CLIENT_BLOCKED) == <span class="hljs-number">0</span>);

    <span class="hljs-comment">/* Clean up. Command code may have changed argv/argc so we use the</span>
<span class="hljs-comment">         * argv/argc of the client instead of the local variables. */</span>
    freeFakeClientArgv(fakeClient);
    <span class="hljs-keyword">if</span> (server.aof_load_truncated) valid_up_to = ftello(fp);
&#125;</code></pre></div><p>上面这部分是加载 AOF 文件的关键，以 <code>SET keytest val</code> 命令对应的 AOF 文件内容 <code>*3\r\n$3\r\nSET\r\n$7\r\nkeytest\r\n$3\r\nval\r\n</code> 为例，可以更好地理解上面的逻辑。由于 AOF 文件中存储的数据与客户端发送的请求格式相同完全符合 Redis 的通信协议，因此 Redis Server 创建伪客户端 <strong>fakeClient</strong>，将解析后的 AOF 文件数据像客户端请求一样调用各种指令，<code>cmd-&gt;proc(fakeClient)</code>，将 AOF 文件中的数据重现到 Redis Server 数据库中。</p><p>完成以上逻辑后，进行一些收尾工作，如改回 AOF 状态为 ON，释放伪客户端等，并处理一些异常情况，这里就不展开细讲了。</p><h2 id="参考">参考</h2><ol><li><a target="_blank" rel="noopener" href="https://juejin.im/post/5bd96bcaf265da396b72f855">Copy On Write 机制了解一下</a></li><li><a target="_blank" rel="noopener" href="http://mysql.taobao.org/monthly/2018/12/06/">Redis · 原理介绍 · 利用管道优化 aofrewrite</a></li></ol></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/redis/">redis</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext row"><article class="post-prev col-6"><a href="/d15eb256.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Redis 持久化之 AOF 重写</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/3581d0f0.html"><span class="hidden-mobile">golang 中下划线的使用</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script type="text/javascript">function loadLivere(){addScript("https://cdn-city.livere.com/js/embed.dist.js")}waitElementVisible("lv-container",loadLivere)</script><noscript>为正常使用来必力评论功能请允许 JavaScript 运行</noscript></div></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:3,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","Redis 持久化之 AOF&nbsp;"],cursorChar:"|",typeSpeed:72,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "§"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>