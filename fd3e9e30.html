<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Redis 持久化之 AOF"><meta name="keywords" content="redis"><meta name="author" content="Happen"><meta name="copyright" content="Happen"><title>Redis 持久化之 AOF | Happen's Memo</title><link rel="shortcut icon" href="/images/dolphin.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?882b48640075e00a238ae94a7eec0d40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,c,g,o){e.GoogleAnalyticsObject=c,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,g=a.createElement(t),o=a.getElementsByTagName(t)[0],g.async=1,g.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(g,o)}(window,document,"script",0,"ga"),ga("create","RRBput3V2WYVZd2lq058Z4IwJEhViOwuMElqkWh6bcA","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#server-相关变量"><span class="toc-number">2.</span> <span class="toc-text">server 相关变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#aof-fsync"><span class="toc-number">2.1.</span> <span class="toc-text">aof_fsync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aof-child-pid"><span class="toc-number">2.2.</span> <span class="toc-text">aof_child_pid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aof-buf"><span class="toc-number">2.3.</span> <span class="toc-text">aof_buf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aof-rewrite-buf-blocks"><span class="toc-number">2.4.</span> <span class="toc-text">aof_rewrite_buf_blocks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aof-rewrite-scheduled"><span class="toc-number">2.5.</span> <span class="toc-text">aof_rewrite_scheduled</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aof-state"><span class="toc-number">2.6.</span> <span class="toc-text">aof_state</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aof-pipe"><span class="toc-number">2.7.</span> <span class="toc-text">aof_pipe_*</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF-持久化"><span class="toc-number">3.</span> <span class="toc-text">AOF 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#命令追加"><span class="toc-number">3.1.</span> <span class="toc-text">命令追加</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#feedAppendOnlyFile-函数"><span class="toc-number">3.1.1.</span> <span class="toc-text">feedAppendOnlyFile 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#catAppendOnlyExpireAtCommand-函数"><span class="toc-number">3.1.2.</span> <span class="toc-text">catAppendOnlyExpireAtCommand 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#catAppendOnlyGenericCommand-函数"><span class="toc-number">3.1.3.</span> <span class="toc-text">catAppendOnlyGenericCommand 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#aofRewriteBufferAppend-函数"><span class="toc-number">3.1.4.</span> <span class="toc-text">aofRewriteBufferAppend 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#何时进行命令追加"><span class="toc-number">3.1.5.</span> <span class="toc-text">何时进行命令追加</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#propagate-函数"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">propagate 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#propagateExpire-函数"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">propagateExpire 函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件的写入与同步"><span class="toc-number">3.2.</span> <span class="toc-text">文件的写入与同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#同步策略"><span class="toc-number">3.2.1.</span> <span class="toc-text">同步策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何写入文件"><span class="toc-number">3.2.2.</span> <span class="toc-text">如何写入文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#文件写入-，write-系统调用"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">文件写入*，write *系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#收尾工作，-write-结果处理"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">收尾工作， write 结果处理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#何时进行文件写入"><span class="toc-number">3.2.3.</span> <span class="toc-text">何时进行文件写入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#beforeSleep-函数"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">beforeSleep 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#serverCron-函数"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">serverCron 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stopAppendOnly-函数"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">stopAppendOnly 函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF-文件载入"><span class="toc-number">4.</span> <span class="toc-text">AOF 文件载入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.png"></div><div class="author-info__name text-center">Happen</div><div class="author-info__description text-center">浮生若梦，为欢几何</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">39</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://renrenlove.me/" target="_blank" rel="noopener">Galway</a><a class="author-info-links__name text-center" href="http://kvguru.com/" target="_blank" rel="noopener">Wangbin</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div id="page-header"> <span class="pull-left"><a id="site-name" href="/">Happen's Memo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Redis 持久化之 AOF</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-14</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a><div class="post-meta-wordcount"><span>字数总计:</span> <span class="word-count">6.2k</span><span class="post-meta__separator">|</span><span>阅读时长: 24 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>除了 RDB 持久化功能之外，Redis 还提供了 AOF（Append Only File）持久化功能。与 RDB 持久化通过保存数据库中的键值对来记录数据库状态不同，AOF 持久化是通过保存 Redis 服务器所执行的写命令来记录数据库状态的。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AOF 文件中记录了 Redis 服务器所执行的写命令，以此来保存数据库的状态。AOF 文件本质上是一个 redo log，通过它可以恢复数据库状态。</p><p>随着执行命令的增多，AOF 文件的大小会不断增大，这会导致几个问题，比如，磁盘占用增加，重启加载过慢等。因此， Redis 提供了 AOF 重写机制来控制 AOF 文件大小，下面会细说。</p><p>AOF 文件中写入的所有命令以 Redis 的命令请求协议格式去保存，即 <a href="http://redisdoc.com/topic/protocol.html" target="_blank" rel="noopener">RESP</a> 格式。</p><p>有两种方式可以实现 AOF 功能的开关，如下，</p><ul><li>在 redis 配置文件 <strong>redis.conf</strong> 中有配置项 appendonly， yes 打开 AOF 功能，no 关闭 AOF 功能。</li><li>使用客户端命令<code>config set appendonly yes/no</code> 。</li></ul><h2 id="server-相关变量"><a href="#server-相关变量" class="headerlink" title="server 相关变量"></a>server 相关变量</h2><p>与 AOF 相关的 server 成员变量很多，这里只选择几个进行简要说明。先看后面的章节，之后再回头看本章节，也是个不错的主意。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> aof_state;                  <span class="comment">/* AOF_(ON|OFF|WAIT_REWRITE) */</span></span><br><span class="line"><span class="keyword">int</span> aof_fsync;                  <span class="comment">/* Kind of fsync() policy */</span></span><br><span class="line"><span class="keyword">char</span> *aof_filename;             <span class="comment">/* Name of the AOF file */</span></span><br><span class="line"><span class="keyword">int</span> aof_no_fsync_on_rewrite;    <span class="comment">/* Don't fsync if a rewrite is in prog. */</span></span><br><span class="line"><span class="keyword">int</span> aof_rewrite_perc;           <span class="comment">/* Rewrite AOF if % growth is &gt; M and... */</span></span><br><span class="line"><span class="keyword">off_t</span> aof_rewrite_min_size;     <span class="comment">/* the AOF file is at least N bytes. */</span></span><br><span class="line"><span class="keyword">off_t</span> aof_rewrite_base_size;    <span class="comment">/* AOF size on latest startup or rewrite. */</span></span><br><span class="line"><span class="keyword">off_t</span> aof_current_size;         <span class="comment">/* AOF current size. */</span></span><br><span class="line"><span class="keyword">int</span> aof_rewrite_scheduled;      <span class="comment">/* Rewrite once BGSAVE terminates. */</span></span><br><span class="line"><span class="keyword">pid_t</span> aof_child_pid;            <span class="comment">/* PID if rewriting process */</span></span><br><span class="line"><span class="built_in">list</span> *aof_rewrite_buf_blocks;   <span class="comment">/* Hold changes during an AOF rewrite. */</span></span><br><span class="line">sds aof_buf;                   <span class="comment">/* AOF buffer, written before entering the event loop */</span></span><br><span class="line"><span class="keyword">int</span> aof_fd;                     <span class="comment">/* File descriptor of currently selected AOF file */</span></span><br><span class="line"><span class="keyword">int</span> aof_selected_db;            <span class="comment">/* Currently selected DB in AOF */</span></span><br><span class="line"><span class="keyword">time_t</span> aof_flush_postponed_start; <span class="comment">/* UNIX time of postponed AOF flush */</span></span><br><span class="line"><span class="keyword">time_t</span> aof_last_fsync;            <span class="comment">/* UNIX time of last fsync() */</span></span><br><span class="line"><span class="keyword">time_t</span> aof_rewrite_time_last;     <span class="comment">/* Time used by last AOF rewrite run. */</span></span><br><span class="line"><span class="keyword">time_t</span> aof_rewrite_time_start;    <span class="comment">/* Current AOF rewrite start time. */</span></span><br><span class="line"><span class="keyword">int</span> aof_lastbgrewrite_status;     <span class="comment">/* C_OK or C_ERR */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> aof_delayed_fsync;  <span class="comment">/* delayed AOF fsync() counter */</span></span><br><span class="line"><span class="keyword">int</span> aof_rewrite_incremental_fsync;<span class="comment">/* fsync incrementally while rewriting? */</span></span><br><span class="line"><span class="keyword">int</span> aof_last_write_status;        <span class="comment">/* C_OK or C_ERR */</span></span><br><span class="line"><span class="keyword">int</span> aof_last_write_errno;         <span class="comment">/* Valid if aof_last_write_status is ERR */</span></span><br><span class="line"><span class="keyword">int</span> aof_load_truncated;           <span class="comment">/* Don't stop on unexpected AOF EOF. */</span></span><br></pre></td></tr></table></figure><h3 id="aof-fsync"><a href="#aof-fsync" class="headerlink" title="aof_fsync"></a>aof_fsync</h3><p>表示 AOF 刷盘策略，后面会细说</p><h3 id="aof-child-pid"><a href="#aof-child-pid" class="headerlink" title="aof_child_pid"></a>aof_child_pid</h3><p>由于 aofrewrite 是个耗时操作，因此会 fork 一个子进程去做这件事， aof_child_pid 就标识了子进程的 pid。</p><h3 id="aof-buf"><a href="#aof-buf" class="headerlink" title="aof_buf"></a>aof_buf</h3><p>该变量保存着所有等待写入到 AOF 文件的协议文本。</p><h3 id="aof-rewrite-buf-blocks"><a href="#aof-rewrite-buf-blocks" class="headerlink" title="aof_rewrite_buf_blocks"></a>aof_rewrite_buf_blocks</h3><p>该变量用来保存 aofrewrite 期间，server 处理过的需要写入 AOF 文件的协议文本。这个变量采用 list 结构，是考虑到分配到一个非常大的空间并不总是可能的，也可能产生大量的复制工作。</p><h3 id="aof-rewrite-scheduled"><a href="#aof-rewrite-scheduled" class="headerlink" title="aof_rewrite_scheduled"></a>aof_rewrite_scheduled</h3><p>可取值有 0 和 1。</p><p>取 1 时，表示此时有子进程正在做 aofrewrite 操作，本次任务后延，等到 <code>serverCron</code> 执行时，合适的情况再执行。或者是执行了 <code>config set appendonly yes</code>, 想把 AOF 功能打开，此时执行的 aofrewrite 失败了，aof_state 仍然处于 <strong>AOF_WAIT_REWRITE</strong> 状态，此时 <strong>aof_rewrite_scheduled</strong> 也会置为 1，等下次再执行 aofrewrite。</p><h3 id="aof-state"><a href="#aof-state" class="headerlink" title="aof_state"></a>aof_state</h3><p>表示 AOF 功能现在的状态，可取值如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AOF_OFF 0             <span class="comment">/* AOF is off */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AOF_ON 1              <span class="comment">/* AOF is on */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AOF_WAIT_REWRITE 2    <span class="comment">/* AOF waits rewrite to start appending */</span></span></span><br></pre></td></tr></table></figure><p><strong>AOF_OFF</strong> 表示 AOF 功能处于关闭状态，开关在上一节已经说过，默认 AOF 功能是关闭的。AOF 功能从 off switch 到 on 后，<strong>aof_state</strong> 会从 <strong>AOF_OFF</strong> 变为 <strong>AOF_WAIT_REWRITE</strong>，<code>startAppendOnly</code> 函数完成该逻辑。在 aofrewrite 一次之后，该变量才会从 <strong>AOF_WAIT_REWRITE</strong> 变为 <strong>AOF_ON</strong>。</p><p>可以看到从 ON 切换到 OFF 时，要经历一个中间状态 <strong>AOF_WAIT_REWRITE</strong>，那为何要这么设计呢？再来分析一下 <code>startAppendOnly</code> 函数的逻辑（代码去掉了打印日志的部分）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server.aof_fd = <span class="built_in">open</span>(server.aof_filename,O_WRONLY|O_APPEND|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">serverAssert(server.aof_state == AOF_OFF);</span><br><span class="line"><span class="keyword">if</span> (server.aof_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span> *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">    server.aof_rewrite_scheduled = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rewriteAppendOnlyFileBackground() == C_ERR) &#123;</span><br><span class="line">    <span class="built_in">close</span>(server.aof_fd);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br><span class="line">server.aof_state = AOF_WAIT_REWRITE;</span><br></pre></td></tr></table></figure><p>【1】打开 aof 文件，默认名为 appendonly.aof，没有的话就新建空文件，失败则返回。</p><p>【2】切换后，需要做一次 aofrewrite，将 server 中现有的数据转换成协议文本，写到 AOF 文件。但是，这里要<strong>注意</strong>，如果此时有子进程在做 bgrdb，那么此次 aofrewrite 需要任务延缓，即 <strong>aof_rewrite_scheduled</strong> 置为 1。</p><p>【3】将 <strong>aof_state</strong> 置为 <strong>AOF_WAIT_REWRITE</strong> 状态。</p><p>而做完第一次 aofrewrite 后，<strong>AOF_WAIT_REWRITE</strong> 转换成 <strong>AOF_ON</strong>，如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backgroundRewriteDoneHandler</span><span class="params">(<span class="keyword">int</span> exitcode, <span class="keyword">int</span> bysignal)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == AOF_WAIT_REWRITE)</span><br><span class="line">        server.aof_state = AOF_ON;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细分析源码发现，在 AOF 持久化的命令追加阶段（后面章节细讲），有如下逻辑,</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == AOF_ON)</span><br><span class="line">        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>)</span><br><span class="line">        aofRewriteBufferAppend((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,sdslen(buf));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，刚开启 AOF 时， <strong>aof_state</strong> 为 <strong>AOF_WAIT_REWRITE</strong> ，处理好的协议文本 buf 无法写入 <strong>aof_buf</strong> 变量 ，但必须写入 <strong>aof_rewrite_buf_blocks</strong> 变量（数据在 aofrewrite 的最后阶段会被写进 AOF 文件）。</p><p>这里是否将命令 append 到 <strong>aof_state</strong> 的判断至关重要，如果修改条件为 <code>server.aof_state != AOF_OFF</code> ，<strong>考虑如下情况</strong>。</p><p>AOF 状态刚打开，尚未完成第一次 aofrewrite，也即，一边 Child 进程数据库中现有数据还未写进 AOF 文件，另一边 Parent 进程仍然持续处理 client 请求，于是，Parent 进程在指定的数据刷盘策略下，将 <strong>aof_buf</strong> 刷盘。如果这时宕机了，当 server 重启后，加载 AOF 文件，在内存中塞入数据，实际上对于用户来说，这部分数据算是脏数据了，因为 AOF 并没有成功打开，未开启 AOF 状态时，数据都在内存中，宕机后，数据会全部丢掉。增加这个中间状态就是为了应对这种情况。所以， <strong>AOF_WAIT_REWRITE</strong> 状态存在的时间范围起始于 <code>startAppendOnly</code> ，到完成第一次 aofrewrite 后切成 <strong>AOF_ON</strong> 。aofrewrite 后再发生宕机，丢失的数据就少多了。</p><p><strong>这只是我个人的理解，不一定正确，欢迎大家斧正。</strong></p><p>另外，如果开启了 AOF，在 redis 启动 加载 AOF 文件时，<strong>aof_state</strong> 也会暂时设置成 <strong>AOF_OFF</strong>，加载完毕之后设置为 <strong>AOF_ON</strong>。</p><h3 id="aof-pipe"><a href="#aof-pipe" class="headerlink" title="aof_pipe_*"></a>aof_pipe_*</h3><p>为了提高 aofrewrite 效率，Redis 通过在父子进程间建立管道，把 aofrewrite 期间的写命令通过管道同步给子进程，追加写盘的操作也就转交给了子进程。aof_pipe_* 变量就是这部分会用到的管道。</p><h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><h3 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h3><p>AOF 功能开启后，每次导致数据库状态发生变化的命令都会经过<strong>函数</strong> <code>feedAppendOnlyFile</code> 累积到 <strong>aof_buf</strong> 变量中。如果后台有正在执行的 aofrewrite 任务，还会写一份数据到 <strong>aof_rewrite_buf_blocks</strong> 变量中。</p><h4 id="feedAppendOnlyFile-函数"><a href="#feedAppendOnlyFile-函数" class="headerlink" title="feedAppendOnlyFile 函数"></a>feedAppendOnlyFile 函数</h4><p>在该函数中，首先要将数据库切换到当前数据库（ <strong>aof_selected_db</strong> 更新），在 buf 中插入一条 <strong>SELECT</strong> 命令。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds buf = sdsempty();</span><br><span class="line"><span class="keyword">if</span> (dictid != server.aof_selected_db) &#123;</span><br><span class="line">    <span class="keyword">char</span> seldb[<span class="number">64</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">"%d"</span>,dictid);</span><br><span class="line">    buf = sdscatprintf(buf,<span class="string">"*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n"</span>, (<span class="keyword">unsigned</span>        <span class="keyword">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</span><br><span class="line">    server.aof_selected_db = dictid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在对需要加入 buf 的命令进行分类处理。</p><p>【1】带有过期时间的命令，调用函数 <code>catAppendOnlyExpireAtCommand</code> 进行协议文本 buf 组装。<strong>EXPIRE</strong>/<strong>PEXPIRE</strong>/<strong>EXPIREAT</strong> 这三个命令直接调用该函数，而 <strong>SETEX</strong>/<strong>PSETEX</strong> 这两个命令需要在调用之前加入一个 <strong>SET</strong> 命令。即，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tmpargv[<span class="number">0</span>] = createStringObject(<span class="string">"SET"</span>,<span class="number">3</span>);</span><br><span class="line">tmpargv[<span class="number">1</span>] = argv[<span class="number">1</span>];</span><br><span class="line">tmpargv[<span class="number">2</span>] = argv[<span class="number">3</span>];</span><br><span class="line">buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,tmpargv);</span><br><span class="line"></span><br><span class="line">decrRefCount(tmpargv[<span class="number">0</span>]);</span><br><span class="line">buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>【2】普通命令，直接调用函数 <code>catAppendOnlyGenericCommand</code> 进行协议文本 buf 组装。</p><h4 id="catAppendOnlyExpireAtCommand-函数"><a href="#catAppendOnlyExpireAtCommand-函数" class="headerlink" title="catAppendOnlyExpireAtCommand 函数"></a>catAppendOnlyExpireAtCommand 函数</h4><p>该函数其实就是将所有与过期时间相关的命令转成 <strong>PEXPIREAT</strong> 命令，细化到毫秒。最后调用普通命令组装 buf 函数 <code>catAppendOnlyGenericCommand</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建 PEXPIREAT 命令</span></span><br><span class="line">argv[<span class="number">0</span>] = createStringObject(<span class="string">"PEXPIREAT"</span>,<span class="number">9</span>);</span><br><span class="line">argv[<span class="number">1</span>] = key;</span><br><span class="line">argv[<span class="number">2</span>] = createStringObjectFromLongLong(when);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 aof 公共函数</span></span><br><span class="line">buf = catAppendOnlyGenericCommand(buf, <span class="number">3</span>, argv);</span><br></pre></td></tr></table></figure><h4 id="catAppendOnlyGenericCommand-函数"><a href="#catAppendOnlyGenericCommand-函数" class="headerlink" title="catAppendOnlyGenericCommand 函数"></a>catAppendOnlyGenericCommand 函数</h4><p>该函数用来把 redis 命令转换成 RESP 协议文本。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">catAppendOnlyGenericCommand</span><span class="params">(sds dst, <span class="keyword">int</span> argc, robj **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> len, j;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比如 *3\r\n</span></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="string">'*'</span>;</span><br><span class="line">    len = <span class="number">1</span>+ll2string(buf+<span class="number">1</span>,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,argc);</span><br><span class="line">    buf[len++] = <span class="string">'\r'</span>;</span><br><span class="line">    buf[len++] = <span class="string">'\n'</span>;</span><br><span class="line">    dst = sdscatlen(dst,buf,len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        o = getDecodedObject(argv[j]);</span><br><span class="line">        buf[<span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">        len = <span class="number">1</span>+ll2string(buf+<span class="number">1</span>,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,sdslen(o-&gt;ptr));</span><br><span class="line">        buf[len++] = <span class="string">'\r'</span>;</span><br><span class="line">        buf[len++] = <span class="string">'\n'</span>;</span><br><span class="line">        dst = sdscatlen(dst,buf,len);</span><br><span class="line">        dst = sdscatlen(dst,o-&gt;ptr,sdslen(o-&gt;ptr));</span><br><span class="line">        dst = sdscatlen(dst,<span class="string">"\r\n"</span>,<span class="number">2</span>);</span><br><span class="line">        decrRefCount(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，定义了一个 buf 数组，反复使用，通过 len 精确控制 append 到 dst 后的长度。</p><h4 id="aofRewriteBufferAppend-函数"><a href="#aofRewriteBufferAppend-函数" class="headerlink" title="aofRewriteBufferAppend 函数"></a>aofRewriteBufferAppend 函数</h4><p><strong>aof_rewrite_buf_blocks</strong> 变量是一个 list 结构，其中每一个元素都是一个大小为 10M 的 block</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AOF_RW_BUF_BLOCK_SIZE (1024*1024*10)    <span class="comment">/* 10 MB per block */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aofrwblock</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used, <span class="built_in">free</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[AOF_RW_BUF_BLOCK_SIZE];</span><br><span class="line">&#125; aofrwblock;</span><br></pre></td></tr></table></figure><p>这个函数做了两件事情。</p><p>一是，将 <code>catAppendOnlyGenericCommand</code> 获得的协议文本 buf 存到 <strong>aof_rewrite_buf_blocks</strong> 变量，首先拿出来 list 最后一个 block，如果装不下，那先把最后一个 block 填满，剩下的再申请内存。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">listNode *ln = listLast(server.aof_rewrite_buf_blocks); <span class="comment">// 指向最后一个缓存块</span></span><br><span class="line">aofrwblock *block = ln ? ln-&gt;value : <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (block) &#123; <span class="comment">// 如果已经有至少一个缓存块，那么尝试将内容追加到这个缓存块里面</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> thislen = (block-&gt;<span class="built_in">free</span> &lt; len) ? block-&gt;<span class="built_in">free</span> : len;</span><br><span class="line">        <span class="keyword">if</span> (thislen) &#123;  <span class="comment">/* The current block is not already full. */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(block-&gt;buf+block-&gt;used, s, thislen);</span><br><span class="line">            block-&gt;used += thislen;</span><br><span class="line">            block-&gt;<span class="built_in">free</span> -= thislen;</span><br><span class="line">            s += thislen;</span><br><span class="line">            len -= thislen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len) &#123;  <span class="comment">// 最后一个缓存块没有放得下本次 data，那再申请一个 block</span></span><br><span class="line">        <span class="keyword">int</span> numblocks;</span><br><span class="line">        block = zmalloc(<span class="keyword">sizeof</span>(*block));</span><br><span class="line">        block-&gt;<span class="built_in">free</span> = AOF_RW_BUF_BLOCK_SIZE;</span><br><span class="line">        block-&gt;used = <span class="number">0</span>;</span><br><span class="line">        listAddNodeTail(server.aof_rewrite_buf_blocks,block);</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二是，给 <strong>aof_pipe_write_data_to_child</strong> 这个 fd 注册写事件，回调函数为 <code>aofChildWriteDiffData</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Install a file event to send data to the rewrite child if there is</span></span><br><span class="line"><span class="comment">     * not one already. */</span></span><br><span class="line"><span class="keyword">if</span> (aeGetFileEvents(server.el,server.aof_pipe_write_data_to_child) == <span class="number">0</span>) &#123;</span><br><span class="line">    aeCreateFileEvent(server.el, server.aof_pipe_write_data_to_child,</span><br><span class="line">                      AE_WRITABLE, aofChildWriteDiffData, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个属于 aof 重写的逻辑，后面章节会细说，这里先留个心。</p><h4 id="何时进行命令追加"><a href="#何时进行命令追加" class="headerlink" title="何时进行命令追加"></a>何时进行命令追加</h4><p>也就是说，什么时候会调用<code>feedAppendOnlyFile</code> 呢？有以下两个时机。</p><h5 id="propagate-函数"><a href="#propagate-函数" class="headerlink" title="propagate 函数"></a>propagate 函数</h5><p>大家都知道，Redis 中命令执行的流程，即 <code>processCommand</code> -&gt; <code>call</code> 。在 <code>call</code> 函数中会把某些命令写入 AOF 文件。如何判断某个命令是否需要写入 AOF 呢？</p><p>在 server 结构体中维持了一个 <strong>dirty</strong> 计数器，<strong>dirty</strong> 记录的是服务器状态进行了多少次修改，每次做完 save/bgsave 执行完成后，会将 <strong>dirty</strong> 清 0，而使得服务器状态修改的命令一般都需要写入 AOF 文件和主从同步（排除某些特殊情况）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dirty = server.dirty;</span><br><span class="line">c-&gt;cmd-&gt;proc(c);</span><br><span class="line">dirty = server.dirty-dirty;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (propagate_flags != PROPAGATE_NONE)</span><br><span class="line">    propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);</span><br></pre></td></tr></table></figure><p>在 <code>propagate</code> 函数中就会调用到 <code>feedAppendOnlyFile</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagate</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dbid, robj **argv, <span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.aof_state != AOF_OFF &amp;&amp; flags &amp; PROPAGATE_AOF)</span><br><span class="line">        feedAppendOnlyFile(cmd,dbid,argv,argc);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; PROPAGATE_REPL)</span><br><span class="line">        replicationFeedSlaves(server.slaves,dbid,argv,argc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="propagateExpire-函数"><a href="#propagateExpire-函数" class="headerlink" title="propagateExpire 函数"></a>propagateExpire 函数</h5><p>当内存中带有过期时间的 key 过期时，会向 AOF 写入 <strong>del</strong> 命令。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagateExpire</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (server.aof_state != AOF_OFF)</span><br><span class="line">        feedAppendOnlyFile(server.delCommand,db-&gt;id,argv,<span class="number">2</span>);</span><br><span class="line">    replicationFeedSlaves(server.slaves,db-&gt;id,argv,<span class="number">2</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>propagateExpire</code> 函数在一些检查 key 是否过期时会调用。</p><h3 id="文件的写入与同步"><a href="#文件的写入与同步" class="headerlink" title="文件的写入与同步"></a>文件的写入与同步</h3><p>上一步中，将需要写入 AOF 文件的数据先写到了 <strong>aof_buf</strong> 变量中，那么，接下来说一下如何将 <strong>aof_buf</strong> 的内容写进 AOF 文件。</p><h4 id="同步策略"><a href="#同步策略" class="headerlink" title="同步策略"></a>同步策略</h4><blockquote><p>为了提高文件的写入效率，在现代操作系统中，当用户调用 <code>write</code> 函数试，将一些数据写入到文件的时候，操作系统通常会将写入的数据保存在一个内存缓冲区里，等到缓冲区的空间被填满，或者超过了指定的时限后，才真正地将缓冲区中的数据写入磁盘。</p><p>这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机宕机，那么保存在内存缓冲区里面的写入数据将会丢失。</p><p>为此，系统提供了 <code>fsync</code> 和 <code>fdatasync</code> 两个同步函数，它们可以强制让操作系统立即将缓存区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p></blockquote><p>要知道，这两个系统调用函数都是阻塞式的，针对如何协调文件写入与同步的关系，该版本 Redis 支持 3 种同步策略，可在配置文件中使用 <strong>appendfsync</strong> 项进行配置，有如下取值，</p><ul><li><p>always。每次有新命令追加到 AOF文件 时就执行一次同步，,安全性最高，但是性能影响最大。</p></li><li><p>everysec。每秒执行一次同步。宕机只会丢失一秒钟的命令。这算是一个折中方案。</p></li><li><p>no。将数据同步操作完全交由操作系统处理，性能最好，但是数据可靠性最差。宕机将丢失同步 AOF 文件后的所有写命令。</p></li></ul><p>在 Redis 源码中， 当程序运行在 Linux 系统上时，执行的是 <code>fdatasync</code> 函数，而在其他系统上，则会执行 <code>fsync</code> 函数，即，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aof_fsync fdatasync</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aof_fsync fsync</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>注</strong>：以下叙述均以 <code>fsync</code> 代称。</p><h4 id="如何写入文件"><a href="#如何写入文件" class="headerlink" title="如何写入文件"></a>如何写入文件</h4><p>写入文件的逻辑在 <code>flushAppendOnlyFile</code> 函数中实现。下面分两部分来看主要代码。</p><h5 id="文件写入-，write-系统调用"><a href="#文件写入-，write-系统调用" class="headerlink" title="文件写入*，write *系统调用"></a>文件写入*<em>，<code>write</code> *</em>系统调用</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// aof 缓存区内没有数据需要写入 disk，无需处理</span></span><br><span class="line"><span class="keyword">if</span> (sdslen(server.aof_buf) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 sync policy 设置成 everysec，</span></span><br><span class="line"><span class="comment">// sync_in_progress 表示是否有 fsync 任务在后台</span></span><br><span class="line"><span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)</span><br><span class="line">    sync_in_progress = bioPendingJobsOfType(BIO_AOF_FSYNC) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// force=0(非强制写入)时，如果后台有 fsync 任务，推迟此次写入，但推迟时间不超过 2s</span></span><br><span class="line"><span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.aof_flush_postponed_start == <span class="number">0</span>) &#123; <span class="comment">// 首次推迟 write，一次推迟 2s</span></span><br><span class="line">            server.aof_flush_postponed_start = server.unixtime;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.unixtime - server.aof_flush_postponed_start &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则，通过，继续写，因为我们不能等待超过 2s</span></span><br><span class="line">        server.aof_delayed_fsync++;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 将 aof 缓冲区的内容写到系统缓存区</span></span><br><span class="line">nwritten = <span class="built_in">write</span>(server.aof_fd, server.aof_buf, sdslen(server.aof_buf));</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 执行了 write 操作，所以要清零延迟 flush 的时间</span></span><br><span class="line">server.aof_flush_postponed_start = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>首先会判断 <strong>aof_buf</strong> 是否为空，如果是，那么不需要执行下面的逻辑，直接返回。</p><p>如果同步策略为 everysec，那么需要查看是否有 <strong>fsync</strong> 任务在后台，调用 <strong>fsync</strong> 使用的是 Redis 中 bio ，如果对这个还不了解，可以参考我之前的文章 《 <a href="http://tech-happen.site/de55b491.html" target="_blank" rel="noopener">Redis Bio 详解</a> 》。为什么要做这个判断呢？</p><blockquote><p>当 <code>fsync</code> 和 <code>write</code> 同一个 fd 时，<code>write</code> 必然阻塞。 当系统 IO 非常繁忙时， <code>fsync</code>() 可能会阻塞， 即使系统 IO 不繁忙， <code>fsync</code> 也会因为数据量大而慢。</p></blockquote><p>因此对于 everysec 策略，需要尽量保证 <code>fsync</code> 和 <code>write</code> 不同时操作同一个 fd。no 策略完全把 <code>fsync</code> 交给了操作系统，操作系统什么时候 <code>fsync</code> ，无从得知。always 策略则是每次都要主从调用 <code>fsync</code>，也没必要做判断。因此，这里的判断，只针对 everysec 策略有效。</p><p>对于 everysec 策略，如果有 <code>fsync</code> 在执行，那么本次 <code>write</code> <strong>推迟 2 秒钟</strong>，等到下次在进入本函数时，如果推迟时间超过 2 秒，那么更新 <strong>aof_delayed_fsync</strong> 值（info 里可以查到），打印日志 ” <strong>Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.</strong> “ ，之后进行 <code>write</code> 系统调用。当然了，系统也提供了 force 选项，去跳过这项是否要推迟 <code>write</code> 的检查。</p><p><code>write</code> 之后，将 <strong>aof_flush_postponed_start</strong> 推迟开始计时值清零，迎接下次检查。</p><p>所以说，AOF 执行 everysec 策略时，如果恰好有 <code>fsync</code> 在长时间的执行，Redis 意外关闭会丢失最多两秒的数据。如果 <code>fsync</code> 运行正常，只有当操作系统 crash 时才会造成最多 1 秒的数据丢失。</p><h5 id="收尾工作，-write-结果处理"><a href="#收尾工作，-write-结果处理" class="headerlink" title="收尾工作， write 结果处理"></a>收尾工作， <code>write</code> 结果处理</h5><p><code>write</code> 调用结果可能是正常的，也可能是异常的，那么需要做不同的处理。首先主要看异常处理，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nwritten != (<span class="keyword">signed</span>)sdslen(server.aof_buf)) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Log the AOF write error and record the error code. */</span></span><br><span class="line">    <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果仅写了一部分，发生错误</span></span><br><span class="line">    <span class="comment">// 将追加的内容截断，删除了追加的内容，恢复成原来的文件</span></span><br><span class="line">        <span class="keyword">if</span> (ftruncate(server.aof_fd, server.aof_current_size) == <span class="number">-1</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nwritten = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        server.aof_last_write_errno = ENOSPC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是写入的策略为每次写入就同步，无法恢复这种策略的写，因为我们已经告知使用者，已经将写的数据同步到磁盘了，因此直接退出程序</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置执行write操作的状态</span></span><br><span class="line">        server.aof_last_write_status = C_ERR;</span><br><span class="line">        <span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 只能更新当前的 AOF 文件的大小</span></span><br><span class="line">            server.aof_current_size += nwritten;</span><br><span class="line">            <span class="comment">// 删除 AOF 缓冲区写入的字节</span></span><br><span class="line">            sdsrange(server.aof_buf,nwritten,<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* We'll try again on the next call... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Successful write(2). If AOF was in error state, restore the</span></span><br><span class="line"><span class="comment">     * OK state and log the event.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_last_write_status == C_ERR) &#123;</span><br><span class="line">        serverLog(LL_WARNING, <span class="string">"AOF write error looks solved, Redis can write again."</span>);</span><br><span class="line">        server.aof_last_write_status = C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入异常的判断，<code>nwritten != (signed)sdslen(server.aof_buf)</code>，<code>write</code> 的数据量与 <strong>aof_buf</strong> 的大小不同。当完全没写入时，打个日志就算了；当仅写入了一部分数据时，使用 <code>ftruncate</code> 函数把 AOF 文件的内容恢复成原来的大小，以备下次重新写入，<strong>nwritten</strong> 置为 -1。使用 <code>ftruncate</code> 的原因是怕操作系统执行了 <code>fsync</code>，因此需要把 AOF 文件的大小恢复。</p><p>如果执行的是 always 同步策略，那么需要返回会客户端错误。对于其他策略，更新 <code>aof_last_write_status</code> ，以便知道上一次做 <code>write</code> 的结果，对于未完全写入的情况，如果上面执行的 <code>ftruncate</code> 失败，此时 <code>nwritten &gt; 0</code>，需要更新 <strong>aof_current_size</strong>，从 <strong>aof_buf</strong> 中减去已经写入的，防止下次有重复数据写入，然后返回。</p><p>如果写入成功，那么视情况更新 <code>aof_last_write_status</code>，表示此次 <code>write</code> 成功。</p><p>下面主要是正常情况的处理。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* nwritten = -1 时走不到这个步骤 */</span></span><br><span class="line">server.aof_current_size += nwritten; <span class="comment">// 正常 write，更新 aof_current_size</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Re-use AOF buffer when it is small enough. The maximum comes from the</span></span><br><span class="line"><span class="comment"> * arena size of 4k minus some overhead (but is otherwise arbitrary).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &lt; <span class="number">4000</span>) &#123;</span><br><span class="line">    sdsclear(server.aof_buf);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sdsfree(server.aof_buf);</span><br><span class="line">    server.aof_buf = sdsempty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Don't fsync if no-appendfsync-on-rewrite is set to yes and there are</span></span><br><span class="line"><span class="comment"> * children doing I/O in the background. */</span></span><br><span class="line"><span class="keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp; (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Perform the fsync if needed. */</span></span><br><span class="line"><span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">    <span class="comment">/* aof_fsync is defined as fdatasync() for Linux in order to avoid</span></span><br><span class="line"><span class="comment">         * flushing metadata. */</span></span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">    aof_fsync(server.aof_fd); <span class="comment">/* Let's try to get this data on the disk */</span></span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"aof-fsync-always"</span>,latency);</span><br><span class="line">    server.aof_last_fsync = server.unixtime;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</span><br><span class="line">            server.unixtime &gt; server.aof_last_fsync)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sync_in_progress) aof_background_fsync(server.aof_fd); <span class="comment">// 如果没有正在执行同步，那么创建一个后台任务</span></span><br><span class="line">    server.aof_last_fsync = server.unixtime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>aof_buf</strong> 清空，然后根据不同策略进行同步。always 策略时，主动调用 <code>fsync</code>; everysec 策略，则创建 fsync bio 任务。</p><p>另外，有配置项 no-appendfsync-on-rewrite 去决定，当子进程在做 aofrewrite/bgsave 时是否要进行 <code>fsync</code>。</p><h4 id="何时进行文件写入"><a href="#何时进行文件写入" class="headerlink" title="何时进行文件写入"></a>何时进行文件写入</h4><p>也就是，什么时候会调用 <code>flushAppendOnlyFile</code> 函数，有以下三个时机。</p><h5 id="beforeSleep-函数"><a href="#beforeSleep-函数" class="headerlink" title="beforeSleep 函数"></a>beforeSleep 函数</h5><blockquote><p>Redis 的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端请求，以及向客户端发送命令回复，而时间事件则负责像 <code>serverCron</code> 函数这样需要定时运行的函数。</p></blockquote><p>对于 Redis 的事件机制可以参考我之前的文章 《<a href="http://tech-happen.site/85f7b0b4.html" target="_blank" rel="noopener">Redis 中的事件</a>》。</p><p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到 <strong>aof_buf</strong> 缓冲区里面，所以在服务器每次结束一个事件循环之前，都会调用 <code>flushAppendOnlyFile</code> 函数，考虑是否需要将 <strong>aof_buf</strong> 缓冲区中的内容写入和同步到 AOF 文件里面。即，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beforeSleep</span><span class="params">(struct aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Write the AOF buffer on disk */</span></span><br><span class="line">    flushAppendOnlyFile(<span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的调用是非强制写入（force = 0）。</p><h5 id="serverCron-函数"><a href="#serverCron-函数" class="headerlink" title="serverCron 函数"></a>serverCron 函数</h5><p>Redis 中的时间事件，定期执行 <code>serverCron</code> 函数（从 Redis 2.8 开始，用户可以通过修改 <strong>hz</strong> 选项来调整 <code>serverCron</code>的每秒执行次数），做一些杂事，比如更新服务器各项统计信息、关闭清理客户端、做 AOF 和 RDB 等。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* AOF postponed flush: Try at every cron cycle if the slow fsync completed. */</span></span><br><span class="line"><span class="keyword">if</span> (server.aof_flush_postponed_start) flushAppendOnlyFile(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果上次 AOF 写入推迟了，那么再次尝试非强制写入。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">run_with_period(<span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (server.aof_last_write_status == C_ERR)</span><br><span class="line">        flushAppendOnlyFile(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每秒钟检查，如果上次写入 AOF 文件失败了，再次尝试非强制写入。因为需要及时去处理 <code>aof_buf</code>，以及重置 AOF 写入状态的变量 <strong>aof_last_write_status</strong>，每秒做检查，这个频率是足够的。</p><h5 id="stopAppendOnly-函数"><a href="#stopAppendOnly-函数" class="headerlink" title="stopAppendOnly 函数"></a>stopAppendOnly 函数</h5><p>当 AOF 功能要关闭时，会调用 <code>stopAppendOnly</code> 函数，尝试一次强制写入，即尽最大努力去保存最多的数据。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stopAppendOnly</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    serverAssert(server.aof_state != AOF_OFF);</span><br><span class="line">    flushAppendOnlyFile(<span class="number">1</span>);</span><br><span class="line">    aof_fsync(server.aof_fd);</span><br><span class="line">    <span class="built_in">close</span>(server.aof_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强制写入，并刷盘。</p><h2 id="AOF-文件载入"><a href="#AOF-文件载入" class="headerlink" title="AOF 文件载入"></a>AOF 文件载入</h2><p>当 Redis 服务器进程启动时，需要调用 <code>loadDataFromDisk</code> 函数去加载数据。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadDataFromDisk</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = ustime();</span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == AOF_ON) &#123; <span class="comment">// 开启了 aof</span></span><br><span class="line">        <span class="keyword">if</span> (loadAppendOnlyFile(server.aof_filename) == C_OK)</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"DB loaded from append only file: %.3f seconds"</span>,(<span class="keyword">float</span>)(ustime()-start)/<span class="number">1000000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rdbLoad(server.rdb_filename) == C_OK) &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"DB loaded from disk: %.3f seconds"</span>,</span><br><span class="line">                (<span class="keyword">float</span>)(ustime()-start)/<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno != ENOENT) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"Fatal error loading the DB: %s. Exiting."</span>,strerror(errno));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果开启了 AOF 功能，就会调用 <code>loadAppendOnlyFile</code> 函数，加载 AOF 文件中的数据到内存中。否则，会去调用 <code>rdbLoad</code> 函数，加载 RDB 文件。加载 AOF 文件的设计很有意思。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *fp = fopen(filename,<span class="string">"r"</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redis_stat</span> <span class="title">sb</span>;</span></span><br><span class="line"><span class="keyword">int</span> old_aof_state = server.aof_state;</span><br><span class="line"><span class="keyword">long</span> loops = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">off_t</span> valid_up_to = <span class="number">0</span>; <span class="comment">/* Offset of the latest well-formed command loaded. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查文件的正确性, 存在，并且不为空</span></span><br><span class="line"><span class="keyword">if</span> (fp &amp;&amp; redis_fstat(fileno(fp),&amp;sb) != <span class="number">-1</span> &amp;&amp; sb.st_size == <span class="number">0</span>) &#123;</span><br><span class="line">    server.aof_current_size = <span class="number">0</span>;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Fatal error: can't open the append log file for reading: %s"</span>,strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 暂时关掉 AOF, 防止向该 filename 中写入新的 AOF 数据</span></span><br><span class="line">server.aof_state = AOF_OFF;</span><br></pre></td></tr></table></figure><p>首先，空文件没有必要再去加载了，提前返回。</p><p>然后，暂时关闭 AOF 功能，这是为了防止在加载 AOF 文件的过程中，又有新的数据写进来</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fakeClient = createFakeClient(); <span class="comment">// 创建一个不带网络连接的伪客户端</span></span><br><span class="line">startLoading(fp);                <span class="comment">// 标记正在 load db，loading = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读 AOF 文件</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> argc, j;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    sds argsds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">    ... ...</span><br><span class="line">        <span class="comment">// 如执行命令 SET keytest val，那么写入 AOF 文件中的格式为</span></span><br><span class="line">        <span class="comment">// *3\r\n$3\r\nSET\r\n$7\r\nkeytest\r\n$3\r\nval\r\n</span></span><br><span class="line">        <span class="keyword">if</span> (fgets(buf,<span class="keyword">sizeof</span>(buf),fp) == <span class="literal">NULL</span>) &#123; <span class="comment">// 按行读取 AOF 文件，*3</span></span><br><span class="line">            <span class="keyword">if</span> (feof(fp))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">'*'</span>) <span class="keyword">goto</span> fmterr; <span class="comment">// 判断协议是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (buf[<span class="number">1</span>] == <span class="string">'\0'</span>) <span class="keyword">goto</span> readerr; <span class="comment">// 数据完整判断</span></span><br><span class="line">    argc = atoi(buf+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">1</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line"></span><br><span class="line">    argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*argc);</span><br><span class="line">    fakeClient-&gt;argc = argc;</span><br><span class="line">    fakeClient-&gt;argv = argv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fgets(buf,<span class="keyword">sizeof</span>(buf),fp) == <span class="literal">NULL</span>) &#123; <span class="comment">// 依次读到 $3, $7, $3</span></span><br><span class="line">            fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">            freeFakeClientArgv(fakeClient);</span><br><span class="line">            <span class="keyword">goto</span> readerr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">'$'</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line">        len = strtol(buf+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>); <span class="comment">// 参数长度</span></span><br><span class="line">        argsds = sdsnewlen(<span class="literal">NULL</span>,len);</span><br><span class="line">        <span class="keyword">if</span> (len &amp;&amp; fread(argsds,len,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123; <span class="comment">// 依次读到 SET/ keytest/ val</span></span><br><span class="line">            sdsfree(argsds);</span><br><span class="line">            fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">            freeFakeClientArgv(fakeClient);</span><br><span class="line">            <span class="keyword">goto</span> readerr;</span><br><span class="line">        &#125;</span><br><span class="line">        argv[j] = createObject(OBJ_STRING,argsds);</span><br><span class="line">        <span class="keyword">if</span> (fread(buf,<span class="number">2</span>,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123; <span class="comment">// 读到 \r\n</span></span><br><span class="line">            fakeClient-&gt;argc = j+<span class="number">1</span>; <span class="comment">/* Free up to j. */</span></span><br><span class="line">            freeFakeClientArgv(fakeClient);</span><br><span class="line">            <span class="keyword">goto</span> readerr; <span class="comment">/* discard CRLF */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Command lookup */</span></span><br><span class="line">    cmd = lookupCommand(argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (!cmd) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Unknown command '%s' reading the append only file"</span>, (<span class="keyword">char</span>*)argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Run the command in the context of a fake client */</span></span><br><span class="line">    cmd-&gt;proc(fakeClient);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The fake client should not have a reply */</span></span><br><span class="line">    serverAssert(fakeClient-&gt;bufpos == <span class="number">0</span> &amp;&amp; listLength(fakeClient-&gt;reply) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* The fake client should never get blocked */</span></span><br><span class="line">    serverAssert((fakeClient-&gt;flags &amp; CLIENT_BLOCKED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up. Command code may have changed argv/argc so we use the</span></span><br><span class="line"><span class="comment">         * argv/argc of the client instead of the local variables. */</span></span><br><span class="line">    freeFakeClientArgv(fakeClient);</span><br><span class="line">    <span class="keyword">if</span> (server.aof_load_truncated) valid_up_to = ftello(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这部分是加载 AOF 文件的关键，以 <code>SET keytest val</code> 命令对应的 AOF 文件内容 <code>*3\r\n$3\r\nSET\r\n$7\r\nkeytest\r\n$3\r\nval\r\n</code> 为例，可以更好地理解上面的逻辑。由于 AOF 文件中存储的数据与客户端发送的请求格式相同完全符合 Redis 的通信协议，因此 Redis Server 创建伪客户端 <strong>fakeClient</strong>，将解析后的 AOF 文件数据像客户端请求一样调用各种指令，<code>cmd-&gt;proc(fakeClient)</code>，将 AOF 文件中的数据重现到 Redis Server 数据库中。</p><p>完成以上逻辑后，进行一些收尾工作，如改回 AOF 状态为 ON，释放伪客户端等，并处理一些异常情况，这里就不展开细讲了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://juejin.im/post/5bd96bcaf265da396b72f855" target="_blank" rel="noopener">Copy On Write 机制了解一下</a></li><li><a href="http://mysql.taobao.org/monthly/2018/12/06/" target="_blank" rel="noopener">Redis · 原理介绍 · 利用管道优化aofrewrite</a></li></ol></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="social-share" data-disabled="google,facebook,qzone,twitter,diandian,linkedin,qzone,tencent"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/d15eb256.html"><i class="fa fa-chevron-left"></i><span>Redis 持久化之 AOF 重写</span></a></div><div class="next-post pull-right"><a href="/3581d0f0.html"><span>golang 中下划线的使用</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script>!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script></div></div></div><footer class="footer-bg" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;&nbsp;2016 - 2020 By Happen</div><div class="framework-info"><span>Powered by</span> <a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>