<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Redis 源码之故障转移"><meta name="keywords" content="redis"><meta name="author" content="Happen"><meta name="copyright" content="Happen"><title>Redis 源码之故障转移 | Happen's Memo</title><link rel="shortcut icon" href="/images/dolphin.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?882b48640075e00a238ae94a7eec0d40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,c,g,o){e.GoogleAnalyticsObject=c,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,g=a.createElement(t),o=a.getElementsByTagName(t)[0],g.async=1,g.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(g,o)}(window,document,"script",0,"ga"),ga("create","RRBput3V2WYVZd2lq058Z4IwJEhViOwuMElqkWh6bcA","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-故障检测"><span class="toc-number">1.</span> <span class="toc-text">1. 故障检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-PFAIL-标记"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 PFAIL 标记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-FAIL-标记"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 FAIL 标记</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-主动标记-FAIL"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 主动标记 FAIL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-Gossip-被动感知-FAIL"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 Gossip 被动感知 FAIL</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-故障转移"><span class="toc-number">2.</span> <span class="toc-text">2. 故障转移</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-被动-failover"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 被动 failover</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-先验条件及初始化"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 先验条件及初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-制定-failover-时间"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2 制定 failover 时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-slave-拉选票"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3 slave 拉选票</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-其他-master-投票"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.1.4 其他 master 投票</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-4-1-筛掉没资格投票的节点"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">2.1.4.1 筛掉没资格投票的节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-4-2-筛掉不需要投票的-sender"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">2.1.4.2 筛掉不需要投票的 sender</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-4-3-在本轮选举投票"><span class="toc-number">2.1.4.3.</span> <span class="toc-text">2.1.4.3 在本轮选举投票</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5-slave-统计选票"><span class="toc-number">2.1.5.</span> <span class="toc-text">2.1.5 slave 统计选票</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-6-slave-做主从切换"><span class="toc-number">2.1.6.</span> <span class="toc-text">2.1.6 slave 做主从切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-7-集群其他节点感知主从变化"><span class="toc-number">2.1.7.</span> <span class="toc-text">2.1.7 集群其他节点感知主从变化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-主动-failover"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 主动 failover</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-slave-节点接受-cluster-failover-命令"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 slave 节点接受 cluster failover 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-master-节点做-mf-准备"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 master 节点做 mf 准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-slave-处理"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3 slave 处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3-1-获得-master-的-repl-offset"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">2.2.3.1 获得 master 的 repl offset</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3-2-向-maser-追平-repl-offset"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">2.2.3.2 向 maser 追平 repl offset</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-过期清理-mf"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.2.4 过期清理 mf</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-附录"><span class="toc-number">3.</span> <span class="toc-text">3. 附录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-epoch-概念"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 epoch 概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-currentEpoch"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1 currentEpoch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-configEpoch"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2 configEpoch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-clusterUpdateState-函数逻辑"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 clusterUpdateState 函数逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-参考"><span class="toc-number">4.</span> <span class="toc-text">4. 参考</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.png"></div><div class="author-info__name text-center">Happen</div><div class="author-info__description text-center">浮生若梦，为欢几何</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">39</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://renrenlove.me/" target="_blank" rel="noopener">Galway</a><a class="author-info-links__name text-center" href="http://kvguru.com/" target="_blank" rel="noopener">Wangbin</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div id="page-header"> <span class="pull-left"><a id="site-name" href="/">Happen's Memo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Redis 源码之故障转移</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-31</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a><div class="post-meta-wordcount"><span>字数总计:</span> <span class="word-count">7.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 31 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>在 Redis cluster 中故障转移是个很重要的功能，下面就从故障发现到故障转移整个流程做一下详细分析。</p><a id="more"></a><h2 id="1-故障检测"><a href="#1-故障检测" class="headerlink" title="1. 故障检测"></a>1. 故障检测</h2><h3 id="1-1-PFAIL-标记"><a href="#1-1-PFAIL-标记" class="headerlink" title="1.1 PFAIL 标记"></a>1.1 PFAIL 标记</h3><p>集群中每个节点都会定期向其他节点发送 <strong>PING</strong> 消息，以此来检测对方是否在线，如果接收 <strong>PING</strong> 消息的节点 B 没有在规定时间（<strong>cluster_node_timeout</strong>）内回应节点 A <strong>PONG</strong> 消息，那么节点 A 就会将节点 B 标记为疑似下线（probable fail, <strong>PFAIL</strong>）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    di = dictGetSafeIterator(server.cluster-&gt;nodes);</span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        clusterNode *node = dictGetVal(de);</span><br><span class="line">        now = mstime(); <span class="comment">/* Use an updated time at every iteration. */</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="built_in">delay</span> = now - node-&gt;ping_sent;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">delay</span> &gt; server.cluster_node_timeout) &#123;</span><br><span class="line">            <span class="comment">/* Timeout reached. Set the node as possibly failing if it is</span></span><br><span class="line"><span class="comment">             * not already in this state. */</span></span><br><span class="line">            <span class="keyword">if</span> (!(node-&gt;flags &amp; (CLUSTER_NODE_PFAIL|CLUSTER_NODE_FAIL))) &#123;</span><br><span class="line">                node-&gt;flags |= CLUSTER_NODE_PFAIL;</span><br><span class="line">                update_state = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 <code>clusterCron</code> 函数中如果对节点 B 发出 PING 消息，在 <strong>server.cluster_node_timeout</strong> 时间内没有收到其返回的 PONG 消息，如果节点 B 现在没有被标记成 <strong>CLUSTER_NODE_PFAIL</strong> 状态，那么现在就做下这个标记。<br>可以根据 <strong>ping_sent</strong> 参数进行判断的依据如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clusterProcessPacket</span><span class="params">(clusterLink *link)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (link-&gt;node &amp;&amp; type == CLUSTERMSG_TYPE_PONG) &#123;</span><br><span class="line">        link-&gt;node-&gt;pong_received = mstime();</span><br><span class="line">        link-&gt;node-&gt;ping_sent = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当节点 A 接收到节点 B 的 PONG 消息时，会把 <strong>ping_sent</strong> 更新成 0，同时记下收到本次 PONG 消息的时间。<br>上面提到的 clusterNode 与 clusterLink 有如下关联关系：<br><img src="http://ww1.sinaimg.cn/large/71ca8e3cly1fzpznib0gij20ff07qjrt.jpg" alt=""></p><p>可以看出， clusterLink 就是为了接收对端 gossip 消息而设置的。<br>另外，我们发现， 在上面的 <code>clusterCron</code> 函数中将节点标记成 PFAIL 时，会将 update_state 变量置为 1，这会引发后面更改集群状态的逻辑。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (update_state || server.cluster-&gt;state == CLUSTER_FAIL)</span><br><span class="line">    clusterUpdateState();</span><br></pre></td></tr></table></figure><p>集群有两个状态，<strong>CLUSTER_OK</strong> 和 <strong>CLUSTER_FAIL</strong>，如果集群目前状态是 CLUSTER_FAIL，且设置了参数 <code>cluster-require-full-coverage yes</code>，那么此时访问集群会返回错误，意思是可能有某些 slot 没有被 server 接管。<br><code>clusterUpdateState</code> 函数负责更新集群状态，该部分逻辑与本篇博文要讲的主逻辑关系不大，所以放到了后面的<strong>补充章节</strong>中了。</p><h3 id="1-2-FAIL-标记"><a href="#1-2-FAIL-标记" class="headerlink" title="1.2 FAIL 标记"></a>1.2 FAIL 标记</h3><h4 id="1-2-1-主动标记-FAIL"><a href="#1-2-1-主动标记-FAIL" class="headerlink" title="1.2.1 主动标记 FAIL"></a>1.2.1 主动标记 FAIL</h4><p>被节点 A 标记成 FAIL/ PFAIL 的节点如何让节点 C 知道呢？这主要是通过平常发送的 PING/PONG 消息实现的，在 3.x 的版本时，会尽最大努力把这样的节点放到 gossip 消息的流言部分，到后面的 4.x 版本的代码中每次的 PING/PONG 消息都会把 PFAIL 节点都带上。<br><code>clusterProcessGossipSection</code> 函数用来处理 gossip 消息的流言部分。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterProcessGossipSection</span><span class="params">(clusterMsg *hdr, clusterLink *link)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> count = ntohs(hdr-&gt;count);</span><br><span class="line">    clusterMsgDataGossip *g = (clusterMsgDataGossip*) hdr-&gt;data.ping.gossip;</span><br><span class="line">    clusterNode *sender = link-&gt;node ? link-&gt;node : clusterLookupNode(hdr-&gt;sender);</span><br><span class="line">    <span class="keyword">while</span>(count--) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        node = clusterLookupNode(g-&gt;nodename);</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sender &amp;&amp; nodeIsMaster(sender) &amp;&amp; node != myself) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flags &amp; (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (clusterNodeAddFailureReport(node,sender)) &#123;</span><br><span class="line">                        serverLog(LL_VERBOSE,</span><br><span class="line">                           <span class="string">"Node %.40s reported node %.40s as not reachable."</span>,</span><br><span class="line">                            sender-&gt;name, node-&gt;name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    markNodeAsFailingIfNeeded(node);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数依次处理 gossip 消息流言部分携带的各节点信息（总节点数的1/10）。当发现带有 CLUSTER_NODE_FAIL 或者 CLUSTER_NODE_PFAIL 时会调用 <code>clusterNodeAddFailureReport</code> 函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clusterNodeAddFailureReport</span><span class="params">(clusterNode *failing, clusterNode *sender)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *l = failing-&gt;fail_reports;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line">    clusterNodeFailReport *fr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If a failure report from the same sender already exists, just update</span></span><br><span class="line"><span class="comment">     * the timestamp. */</span></span><br><span class="line">    listRewind(l,&amp;li);</span><br><span class="line">    <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fr = ln-&gt;value;</span><br><span class="line">        <span class="keyword">if</span> (fr-&gt;node == sender) &#123;</span><br><span class="line">            fr-&gt;time = mstime();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Otherwise create a new report. */</span></span><br><span class="line">    fr = zmalloc(<span class="keyword">sizeof</span>(*fr));</span><br><span class="line">    fr-&gt;node = sender;</span><br><span class="line">    fr-&gt;time = mstime();</span><br><span class="line">    listAddNodeTail(l,fr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个节点都有一个名为 fail_reports 的 list 结构的变量，用来搜集该异常节点获得了集群中哪些节点的 PFAIL 状态投票。fail_reports 每个成员都是一个 clusterNodeFailReport 结构。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterNodeFailReport</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span>  <span class="comment">/* Node reporting the failure condition. */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> time;             <span class="comment">/* Time of the last report from this node. */</span></span><br><span class="line">&#125; clusterNodeFailReport;</span><br></pre></td></tr></table></figure><p>clusterNodeFailReport 中带有时间戳，标记这个节点上一次被报上来处于异常状态的时间。<br>每次调用 <code>clusterNodeAddFailureReport</code> 函数时，先会检查sender 是否已经为该异常节点投票过了，如果有，更新时间戳，如果没有，把 sender 加入到投票节点中。<br>简单点说就是，在 A 节点看来 B 节点是 PFAIL 状态，在 gossip 通信中把它告诉了 C 节点，C 节点发现这个异常状态的节点，检查一下为 B 节点投过票的节点中有没有 A 节点，如果没有就加进去。</p><p>然后下面就是判断 PFAIL 状态是不是要转变成 FAIL 状态的关键。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markNodeAsFailingIfNeeded</span><span class="params">(clusterNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> failures;</span><br><span class="line">    <span class="keyword">int</span> needed_quorum = (server.cluster-&gt;<span class="built_in">size</span> / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nodeTimedOut(node)) <span class="keyword">return</span>; <span class="comment">/* We can reach it. */</span></span><br><span class="line">    <span class="keyword">if</span> (nodeFailed(node)) <span class="keyword">return</span>; <span class="comment">/* Already FAILing. */</span></span><br><span class="line"></span><br><span class="line">    failures = clusterNodeFailureReportsCount(node);</span><br><span class="line">    <span class="comment">/* Also count myself as a voter if I'm a master. */</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIsMaster(myself)) failures++;</span><br><span class="line">    <span class="keyword">if</span> (failures &lt; needed_quorum) <span class="keyword">return</span>; <span class="comment">/* No weak agreement from masters. */</span></span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">"Marking node %.40s as failing (quorum reached)."</span>, node-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark the node as failing. */</span></span><br><span class="line">    node-&gt;flags &amp;= ~CLUSTER_NODE_PFAIL;</span><br><span class="line">    node-&gt;flags |= CLUSTER_NODE_FAIL;</span><br><span class="line">    node-&gt;fail_time = mstime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Broadcast the failing node name to everybody, forcing all the other</span></span><br><span class="line"><span class="comment">     * reachable nodes to flag the node as FAIL. */</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIsMaster(myself)) clusterSendFail(node-&gt;name); <span class="comment">/* 广播这个节点的 fail 消息 */</span></span><br><span class="line">    clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C 节点收到消息，检查下 A 报过来的异常节点 B，在自己看来是否也是 PFAIL 状态的，如果不是，那么不理会 A 节点本次 report。如果在节点 C 看来，节点 B 已经被标记成 FAIL 了，那么就不需要进行下面的判定了。</p><p>在函数 <code>clusterNodeFailureReportsCount</code> 中会判断计算出把 B 节点标记成 PFAIL 状态的节点的数量 sum，如果 <strong>sum 值小于集群 size 的一半</strong>，为防止误判，忽略掉这条信息。在函数 <code>clusterNodeFailureReportsCount</code> 中会检查关于 B 节点的 <strong>clusterNodeFailReport</strong>，清理掉那些<strong>过期的</strong>投票，过期时间为 2 倍的 <strong>server.cluster_node_timeout</strong>。</p><p>如果满足条件，节点 C 将节点 B 的 PFAIL 状态消除，标记成 FAIL，同时记下 fail_time，如果 C 节点是个 master，那么将 B 节点 FAIL 的消息广播出去，以便让集群中其他节点尽快知道。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterSendFail</span><span class="params">(<span class="keyword">char</span> *nodename)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(clusterMsg)];</span><br><span class="line">    clusterMsg *hdr = (clusterMsg*) buf;</span><br><span class="line">    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAIL);</span><br><span class="line">    <span class="built_in">memcpy</span>(hdr-&gt;data.fail.about.nodename,nodename,CLUSTER_NAMELEN);</span><br><span class="line">    clusterBroadcastMessage(buf,ntohl(hdr-&gt;totlen));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送的 gossip 消息类型为 CLUSTERMSG_TYPE_FAIL，广播的节点排除自身和处于 HANDSHAKE 状态节点。</p><h4 id="1-2-2-Gossip-被动感知-FAIL"><a href="#1-2-2-Gossip-被动感知-FAIL" class="headerlink" title="1.2.2 Gossip 被动感知 FAIL"></a>1.2.2 Gossip 被动感知 FAIL</h4><p>前面说过，gossip 消息的处理函数为 <code>clusterProcessPacket</code>，下面看 CLUSTERMSG_TYPE_FAIL 类型的消息如何处理。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clusterProcessPacket</span><span class="params">(clusterLink *link)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type = ntohs(hdr-&gt;type);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_FAIL) &#123; <span class="comment">// fail</span></span><br><span class="line">        clusterNode *failing;</span><br><span class="line">        <span class="keyword">if</span> (sender) &#123;</span><br><span class="line">            failing = clusterLookupNode(hdr-&gt;data.fail.about.nodename);</span><br><span class="line">            <span class="keyword">if</span> (failing &amp;&amp; !(failing-&gt;flags &amp; (CLUSTER_NODE_FAIL|CLUSTER_NODE_MYSELF)))</span><br><span class="line">            &#123;</span><br><span class="line">                serverLog(LL_NOTICE,</span><br><span class="line">                    <span class="string">"FAIL message received from %.40s about %.40s"</span>,</span><br><span class="line">                    hdr-&gt;sender, hdr-&gt;data.fail.about.nodename);</span><br><span class="line">                failing-&gt;flags |= CLUSTER_NODE_FAIL;</span><br><span class="line">                failing-&gt;fail_time = mstime();</span><br><span class="line">                failing-&gt;flags &amp;= ~CLUSTER_NODE_PFAIL;</span><br><span class="line">                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|</span><br><span class="line">                                     CLUSTER_TODO_UPDATE_STATE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"Ignoring FAIL message from unknown node %.40s about %.40s"</span>,</span><br><span class="line">                hdr-&gt;sender, hdr-&gt;data.fail.about.nodename);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集群中另一个节点 D 收到节点 B 广播过来的消息：B 节点 FAIL 了。如果 D 还没有把 B 标记成 FAIL，那么标记成 CLUSTER_NODE_FAIL，并取消 CLUSTER_NODE_PFAIL 标记；否则，忽略，因为D已经知道 B 是 FAIL 节点了。</p><h2 id="2-故障转移"><a href="#2-故障转移" class="headerlink" title="2. 故障转移"></a>2. 故障转移</h2><p>failover 分为两类，主动 failover（主动切主从）以及被动 failover（被动切主从），下面挨个进行分析。</p><h3 id="2-1-被动-failover"><a href="#2-1-被动-failover" class="headerlink" title="2.1 被动 failover"></a>2.1 被动 failover</h3><h4 id="2-1-1-先验条件及初始化"><a href="#2-1-1-先验条件及初始化" class="headerlink" title="2.1.1 先验条件及初始化"></a>2.1.1 先验条件及初始化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIsSlave(myself)) &#123;</span><br><span class="line">        clusterHandleSlaveFailover();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是否要做被动主从切换，在 <code>clusterHandleSlaveFailover</code> 函数中有如下的判断逻辑，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nodeIsMaster(myself) ||</span><br><span class="line">    myself-&gt;slaveof == <span class="literal">NULL</span> ||</span><br><span class="line">    (!nodeFailed(myself-&gt;slaveof) &amp;&amp; !manual_failover) ||</span><br><span class="line">    myself-&gt;slaveof-&gt;numslots == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* There are no reasons to failover, so we set the reason why we</span></span><br><span class="line"><span class="comment">     * are returning without failing over to NONE. */</span></span><br><span class="line">    server.cluster-&gt;cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有满足如下条件的节点才有资格做 failover：</p><ul><li>slave 节点</li><li>master 不为空</li><li>master 负责的 slot 数量不为空</li><li>master 被标记成了 FAIL，或者这是一个主动 failover（manual_failover 为真）</li></ul><p>假设，现在 B 节点的 slave Bx 节点检测到 B 节点挂掉了，通过了以上的条件测试，接下来就会进行 failover。<br>那么下面 Bx 节点就开始在集群中进行拉票，该逻辑也在 <code>clusterHandleSlaveFailover</code> 函数中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mstime_t</span> auth_age = mstime() - server.cluster-&gt;failover_auth_time;</span><br><span class="line"><span class="keyword">int</span> needed_quorum = (server.cluster-&gt;<span class="built_in">size</span> / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">mstime_t</span> auth_timeout, auth_retry_time;</span><br><span class="line"></span><br><span class="line">auth_timeout = server.cluster_node_timeout*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (auth_timeout &lt; <span class="number">2000</span>) auth_timeout =<span class="number">2000</span> ;</span><br><span class="line">auth_retry_time = auth_timeout*<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>cluster 的 <strong>failover_auth_time</strong> 属性，表示 slave 节点开始进行故障转移的时刻。集群初始化时该属性置为 0，一旦满足 failover 的条件后，该属性就置为<strong>未来的某个时间点</strong>（不是立马执行），在该时间点，slave 节点才开始进行拉票。<strong>auth_age</strong> 变量表示从发起 failover 流程开始到现在，已经过去了多长时间。<br><strong>needed_quorum</strong> 变量表示当前 slave 节点必须至少获得多少选票，才能成为新的 master。<br><strong>auth_timeout</strong> 变量表示当前 slave 发起投票后，等待回应的超时时间，至少为 2s。如果超过该时间还没有获得足够的选票，那么表示本次 failover 失败。<br><strong>auth_retry_time</strong> 变量用来判断是否可以开始发起下一次 failover 的时间间隔。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECTED) &#123;</span><br><span class="line">    data_age = (<span class="keyword">mstime_t</span>)(server.unixtime - server.master-&gt;lastinteraction) * <span class="number">1000</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    data_age = (<span class="keyword">mstime_t</span>)(server.unixtime - server.repl_down_since) * <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (data_age &gt; server.cluster_node_timeout)</span><br><span class="line">    data_age -= server.cluster_node_timeout;</span><br></pre></td></tr></table></figure><p><strong>data_age</strong> 变量表示距离上一次与我的 master 节点交互过去了多长时间。经过 cluster_node_timeout 时间还没有收到 PONG 消息才会将节点标记为 PFAIL 状态。实际上 data_age 表示在 master 节点下线之前，当前 slave 节点有多长时间没有与其交互过了。</p><blockquote><p>data_age 主要用于判断当前 slave 节点的数据新鲜度；如果 data_age 超过了一定时间，表示当前 slave 节点的数据已经太老了，不能替换掉下线 master 节点，因此在不是手动强制故障转移的情况下，直接返回。</p></blockquote><h4 id="2-1-2-制定-failover-时间"><a href="#2-1-2-制定-failover-时间" class="headerlink" title="2.1.2 制定 failover 时间"></a>2.1.2 制定 failover 时间</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterHandleSlaveFailover</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (auth_age &gt; auth_retry_time) &#123;</span><br><span class="line">        server.cluster-&gt;failover_auth_time = mstime() +</span><br><span class="line">            <span class="number">500</span> + <span class="comment">/* Fixed delay of 500 milliseconds, let FAIL msg propagate. */</span></span><br><span class="line">            <span class="built_in">random</span>() % <span class="number">500</span>; <span class="comment">/* Random delay between 0 and 500 milliseconds. */</span></span><br><span class="line">        server.cluster-&gt;failover_auth_count = <span class="number">0</span>;</span><br><span class="line">        server.cluster-&gt;failover_auth_sent = <span class="number">0</span>;</span><br><span class="line">        server.cluster-&gt;failover_auth_rank = clusterGetSlaveRank();</span><br><span class="line">        <span class="comment">/* We add another delay that is proportional to the slave rank.</span></span><br><span class="line"><span class="comment">         * Specifically 1 second * rank. This way slaves that have a probably</span></span><br><span class="line"><span class="comment">         * less updated replication offset, are penalized.</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        server.cluster-&gt;failover_auth_time +=</span><br><span class="line">            server.cluster-&gt;failover_auth_rank * <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span> (server.cluster-&gt;mf_end) &#123;</span><br><span class="line">            server.cluster-&gt;failover_auth_time = mstime();</span><br><span class="line">            server.cluster-&gt;failover_auth_rank = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        clusterBroadcastPong(CLUSTER_BROADCAST_LOCAL_SLAVES);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>满足条件（<strong>auth_age &gt; auth_retry_time</strong>）后，发起故障转移流程。<br>首先设置故障转移发起时刻，即设置 failover_auth_time 时间。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mstime() + <span class="number">500</span> + <span class="built_in">random</span>()%<span class="number">500</span> + rank*<span class="number">1000</span></span><br></pre></td></tr></table></figure><p>固定延时 500ms 是为了让 master fail 的消息能够广泛传播到集群，这样集群中的其他节点才可能投票。<br>随机延时是为了避免多个你 slave 节点同时发起 failover 流程。<br>rank 表示 slave 节点的排名，计算方式如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clusterGetSlaveRank</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> myoffset;</span><br><span class="line">    <span class="keyword">int</span> j, rank = <span class="number">0</span>;</span><br><span class="line">    clusterNode *master;</span><br><span class="line"></span><br><span class="line">    serverAssert(nodeIsSlave(myself));</span><br><span class="line">    master = myself-&gt;slaveof;</span><br><span class="line">    <span class="keyword">if</span> (master == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Never called by slaves without master. */</span></span><br><span class="line"></span><br><span class="line">    myoffset = replicationGetSlaveOffset();</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; master-&gt;numslaves; j++)</span><br><span class="line">        <span class="keyword">if</span> (master-&gt;slaves[j] != myself &amp;&amp;</span><br><span class="line">            master-&gt;slaves[j]-&gt;repl_offset &gt; myoffset) rank++;</span><br><span class="line">    <span class="keyword">return</span> rank;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，排名主要是根据复制数据量来定，复制数据量越多，排名越靠前（rank 值越小）。这样做是为了做 failover 时尽量选择一个复制数据量较多的 slave，以尽最大努力保留数据。在没有开始拉选票之前，<strong>每隔一段时间</strong>（每次调用<code>clusterHandleSlaveFailover</code>函数，也就是每次 cron 的时间）就会调用一次 <code>clusterGetSlaveRank</code> 函数，以更新当前 slave 节点的排名。</p><p><strong>注意</strong>，如果是 mf，那么 failover_auth_time 和 failover_auth_rank 都置为 0，表示该 slave 节点现在就可以执行故障转移。</p><p>最后向该 master 的所有 slave 广播 PONG 消息，主要是为了更新复制偏移量，以便其他 slave 计算出 failover 时间点。<br>这时，函数返回，就此开始了一轮新的故障转移，当已经处在某一轮故障转移时，执行接下来的逻辑。</p><h4 id="2-1-3-slave-拉选票"><a href="#2-1-3-slave-拉选票" class="headerlink" title="2.1.3 slave 拉选票"></a>2.1.3 slave 拉选票</h4><p>首先对于一些不合理的 failover 要过滤掉。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return ASAP if we can't still start the election.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (mstime() &lt; server.cluster-&gt;failover_auth_time) &#123;</span><br><span class="line">    clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_DELAY);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return ASAP if the election is too old to be valid.</span></span><br><span class="line"><span class="comment"> * failover 超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (auth_age &gt; auth_timeout) &#123;</span><br><span class="line">    clusterLogCantFailover(CLUSTER_CANT_FAILOVER_EXPIRED);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后开始拉选票。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.cluster-&gt;failover_auth_sent == <span class="number">0</span>) &#123;</span><br><span class="line">    server.cluster-&gt;currentEpoch++; <span class="comment">// 增加当前节点的currentEpoch的值，表示要开始新一轮选举了</span></span><br><span class="line">    server.cluster-&gt;failover_auth_epoch = server.cluster-&gt;currentEpoch;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Starting a failover election for epoch %llu."</span>,</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) server.cluster-&gt;currentEpoch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向所有节点发送 CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST 消息，开始拉票*/</span></span><br><span class="line">    clusterRequestFailoverAuth();</span><br><span class="line">    server.cluster-&gt;failover_auth_sent = <span class="number">1</span>; <span class="comment">// 表示已经发起了故障转移流程</span></span><br><span class="line">    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|</span><br><span class="line">                         CLUSTER_TODO_UPDATE_STATE|</span><br><span class="line">                         CLUSTER_TODO_FSYNC_CONFIG);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* Wait for replies. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <strong>failover_auth_sent</strong> 为 0，表示没有发起过投票，那么将 currentEpoch 加 1，记录 failover_auth_epoch 为 currentEpoch，函数 <code>clusterRequestFailoverAuth</code> 用来发起投票，failover_auth_sent 置 1，表示该 slave 已经发起过投票了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterRequestFailoverAuth</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(clusterMsg)];</span><br><span class="line">    clusterMsg *hdr = (clusterMsg*) buf;</span><br><span class="line">    <span class="keyword">uint32_t</span> totlen;</span><br><span class="line"></span><br><span class="line">    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST);</span><br><span class="line">    <span class="comment">/* If this is a manual failover, set the CLUSTERMSG_FLAG0_FORCEACK bit</span></span><br><span class="line"><span class="comment">     * in the header to communicate the nodes receiving the message that</span></span><br><span class="line"><span class="comment">     * they should authorized the failover even if the master is working. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;mf_end) hdr-&gt;mflags[<span class="number">0</span>] |= CLUSTERMSG_FLAG0_FORCEACK;</span><br><span class="line">    totlen = <span class="keyword">sizeof</span>(clusterMsg)-<span class="keyword">sizeof</span>(<span class="keyword">union</span> clusterMsgData);</span><br><span class="line">    hdr-&gt;totlen = htonl(totlen);</span><br><span class="line">    clusterBroadcastMessage(buf,totlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>clusterRequestFailoverAuth</code> 函数向集群广播 <strong>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</strong> 类型的 gossip 信息，这类型的信息就是向集群中的 master 节点索要本轮选举中的选票。另外，如果是 mf，那么会在 gossip hdr 中带上 <strong>CLUSTERMSG_FLAG0_FORCEACK</strong> 信息。</p><h4 id="2-1-4-其他-master-投票"><a href="#2-1-4-其他-master-投票" class="headerlink" title="2.1.4 其他 master 投票"></a>2.1.4 其他 master 投票</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sender) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">/* We don't know that node. */</span></span><br><span class="line">    clusterSendFailoverAuthIfNeeded(sender,hdr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>clusterProcessPacket</code> 函数中处理 gossip 消息，当接收到 <strong>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</strong> 类型的消息时，调用 <code>clusterSendFailoverAuthIfNeeded</code> 函数处理，在满足条件的基础上，给 sender 投票。</p><p>注：以下若不进行特殊说明，都是 <code>clusterSendFailoverAuthIfNeeded</code> 函数处理逻辑。</p><h5 id="2-1-4-1-筛掉没资格投票的节点"><a href="#2-1-4-1-筛掉没资格投票的节点" class="headerlink" title="2.1.4.1 筛掉没资格投票的节点"></a>2.1.4.1 筛掉没资格投票的节点</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nodeIsSlave(myself) || myself-&gt;numslots == <span class="number">0</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p><i class="fa fa-times" aria-hidden="true"></i> slave 节点或者不负责 slot 的 master 节点</p><h5 id="2-1-4-2-筛掉不需要投票的-sender"><a href="#2-1-4-2-筛掉不需要投票的-sender" class="headerlink" title="2.1.4.2 筛掉不需要投票的 sender"></a>2.1.4.2 筛掉不需要投票的 sender</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> requestCurrentEpoch = ntohu64(request-&gt;currentEpoch);</span><br><span class="line"><span class="keyword">if</span> (requestCurrentEpoch &lt; server.cluster-&gt;currentEpoch) &#123;</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">              <span class="string">"Failover auth denied to %.40s: reqEpoch (%llu) &lt; curEpoch(%llu)"</span>,</span><br><span class="line">              node-&gt;name,</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) requestCurrentEpoch,</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) server.cluster-&gt;currentEpoch);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><i class="fa fa-times" aria-hidden="true"></i> sender 节点集群信息过旧。<br>正常来说，如果 receiver 在接收到 sender 的 CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST 消息之前接收了 PING/PONG 消息，会更新自己的 currentEpoch，这时 currentEpoch 会增加，因为 sender 发起选举之前，会先增加自身的currentEpoch；否则的话，receiver 的 currentEpoch 应该小于 sender。因此 sender 的 currentEpoch 应该 <strong>&gt;=</strong> receiver 的。有可能 sender 是个长时间下线的节点刚刚上线，这样的节点不能给他投票，因为它的集群信息过旧。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.cluster-&gt;lastVoteEpoch == server.cluster-&gt;currentEpoch) &#123;</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">              <span class="string">"Failover auth denied to %.40s: already voted for epoch %llu"</span>,</span><br><span class="line">              node-&gt;name,</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) server.cluster-&gt;currentEpoch);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><i class="fa fa-times" aria-hidden="true"></i> receiver 节点在本轮选举中已经投过票了，避免两个 slave 节点同时赢得本界选举。<br>lastVoteEpoch 记录了在本轮投票中 receiver 投过票的 sender 的 currentEpoch。各 slave 节点独立发起选举，currentEpoch 是相同的，都在原来的基础上加 1。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clusterNode *master = node-&gt;slaveof;</span><br><span class="line"><span class="keyword">if</span> (nodeIsMaster(node) || master == <span class="literal">NULL</span> || (!nodeFailed(master) &amp;&amp; !force_ack))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeIsMaster(node)) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">"Failover auth denied to %.40s: it is a master node"</span>,</span><br><span class="line">                  node-&gt;name);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (master == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">"Failover auth denied to %.40s: I don't know its master"</span>,</span><br><span class="line">                  node-&gt;name);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!nodeFailed(master)) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">"Failover auth denied to %.40s: its master is up"</span>,</span><br><span class="line">                  node-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><i class="fa fa-times" aria-hidden="true"></i> sender 是个 master。<br><i class="fa fa-times" aria-hidden="true"></i> sender 是个没有 master 的 slave。<br><i class="fa fa-times" aria-hidden="true"></i> sender 的 master 没有 fail，且不是个 mf。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mstime() - node-&gt;slaveof-&gt;voted_time &lt; server.cluster_node_timeout * <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">              <span class="string">"Failover auth denied to %.40s: "</span></span><br><span class="line">              <span class="string">"can't vote about this master before %lld milliseconds"</span>,</span><br><span class="line">              node-&gt;name,</span><br><span class="line">              (<span class="keyword">long</span> <span class="keyword">long</span>) ((server.cluster_node_timeout*<span class="number">2</span>) - (mstime() - node-&gt;slaveof-&gt;voted_time)));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><i class="fa fa-times" aria-hidden="true"></i> 两次投票时间间隔<strong>不能少于 2 倍 的 cluster_node_timeout</strong>。<br>这个裕量时间，使得获得赢得选举的 slave 将新的主从关系周知集群其他节点，避免其他 slave 发起新一轮的投票。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> requestConfigEpoch = ntohu64(request-&gt;configEpoch);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *claimed_slots = request-&gt;myslots;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; CLUSTER_SLOTS; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bitmapTestBit(claimed_slots, j) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;slots[j] == <span class="literal">NULL</span> ||</span><br><span class="line">        server.cluster-&gt;slots[j]-&gt;configEpoch &lt;= requestConfigEpoch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If we reached this point we found a slot that in our current slots</span></span><br><span class="line"><span class="comment">         * is served by a master with a greater configEpoch than the one claimed</span></span><br><span class="line"><span class="comment">         * by the slave requesting our vote. Refuse to vote for this slave. */</span></span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">              <span class="string">"Failover auth denied to %.40s: "</span></span><br><span class="line">              <span class="string">"slot %d epoch (%llu) &gt; reqEpoch (%llu)"</span>,</span><br><span class="line">              node-&gt;name, j,</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) server.cluster-&gt;slots[j]-&gt;configEpoch,</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) requestConfigEpoch);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><i class="fa fa-times" aria-hidden="true"></i> sender 节点声称要接管的 slots，在 receiver 节点看来其中有个别 slot 原来负责节点的 configEpoch 要比 sender 的大，这说明 sender 看到的集群消息太旧了，这可能是一个长时间下线又重新上线的节点。</p><h5 id="2-1-4-3-在本轮选举投票"><a href="#2-1-4-3-在本轮选举投票" class="headerlink" title="2.1.4.3 在本轮选举投票"></a>2.1.4.3 在本轮选举投票</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clusterSendFailoverAuth(node);</span><br><span class="line">server.cluster-&gt;lastVoteEpoch = server.cluster-&gt;currentEpoch;</span><br><span class="line">node-&gt;slaveof-&gt;voted_time = mstime(); <span class="comment">// 更新投票时间</span></span><br></pre></td></tr></table></figure><p><code>clusterSendFailoverAuth</code> 函数中发送 <strong>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</strong> 类型的 gossip 消息，这就算在本轮选举中投票了，并记录本轮投票的 epoch以及投票时间。</p><h4 id="2-1-5-slave-统计选票"><a href="#2-1-5-slave-统计选票" class="headerlink" title="2.1.5 slave 统计选票"></a>2.1.5 slave 统计选票</h4><p>slave 接收到 <strong>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</strong> 类型的 gossip 消息，就算统计到一票。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK) &#123; <span class="comment">// slave 统计票数</span></span><br><span class="line">    <span class="keyword">if</span> (!sender) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">/* We don't know that node. */</span></span><br><span class="line">    <span class="comment">/* We consider this vote only if the sender is a master serving</span></span><br><span class="line"><span class="comment">         * a non zero number of slots, and its currentEpoch is greater or</span></span><br><span class="line"><span class="comment">         * equal to epoch where this node started the election. */</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIsMaster(sender) &amp;&amp; sender-&gt;numslots &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        senderCurrentEpoch &gt;= server.cluster-&gt;failover_auth_epoch)</span><br><span class="line">    &#123;</span><br><span class="line">        server.cluster-&gt;failover_auth_count++;</span><br><span class="line">        <span class="comment">/* Maybe we reached a quorum here, set a flag to make sure</span></span><br><span class="line"><span class="comment">             * we check ASAP. */</span></span><br><span class="line">        clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_FAILOVER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sender 是个负责 slot 的 master 并且满足 currentEpoch 的要求，那么这张选票有效。出现 <code>senderCurrentEpoch &lt; server.cluster-&gt;failover_auth_epoch</code> 的情况时有可能的，如果这张选票是上一轮选举的获得选票，就不能作数。<br>failover_auth_count 变量中记录了 slave 在本轮选举中获得选票数目。</p><h4 id="2-1-6-slave-做主从切换"><a href="#2-1-6-slave-做主从切换" class="headerlink" title="2.1.6 slave 做主从切换"></a>2.1.6 slave 做主从切换</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterHandleSlaveFailover</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int</span> needed_quorum = (server.cluster-&gt;<span class="built_in">size</span> / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;failover_auth_count &gt;= needed_quorum) &#123;</span><br><span class="line">        <span class="comment">/* We have the quorum, we can finally failover the master. */</span></span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">"Failover election won: I'm the new master."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update my configEpoch to the epoch of the election. */</span></span><br><span class="line">        <span class="keyword">if</span> (myself-&gt;configEpoch &lt; server.cluster-&gt;failover_auth_epoch) &#123;</span><br><span class="line">            myself-&gt;configEpoch = server.cluster-&gt;failover_auth_epoch;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                      <span class="string">"configEpoch set to %llu after successful failover"</span>,</span><br><span class="line">                      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) myself-&gt;configEpoch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Take responsability for the cluster slots. */</span></span><br><span class="line">        clusterFailoverReplaceYourMaster();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_VOTES);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slave 节点获得足够多选票后， 成为新的 master 节点。<br>更新自己的 configEpoch 为<strong>选举协商</strong>的 failover_auth_epoch，这是本节点就获得了最新当前集群最大的 configEpoch，表明它看到的集群信息现在是最新的。<br>最后调用 <code>clusterFailoverReplaceYourMaster</code> 函数取代下线主节点，成为新的主节点，并向其他节点广播这种变化。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterFailoverReplaceYourMaster</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    clusterNode *oldmaster = myself-&gt;slaveof;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nodeIsMaster(myself) || oldmaster == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1) Turn this node into a master. */</span></span><br><span class="line">    <span class="comment">/* 把 myself 标记为 master，并从原 master 里删掉，更新原 master 的涉及 slave 的参数，</span></span><br><span class="line"><span class="comment">     * 如果 slave 数量为0,去掉它的 CLUSTER_NODE_MIGRATE_TO 标记</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    clusterSetNodeAsMaster(myself);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 取消主从复制过程，将当前节点升级为主节点 *、</span></span><br><span class="line"><span class="comment">    replicationUnsetMaster();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    /* 2) Claim all the slots assigned to our master.</span></span><br><span class="line"><span class="comment">     * 接手老的 master 节点负责的槽位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; CLUSTER_SLOTS; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (clusterNodeGetSlotBit(oldmaster,j)) &#123;</span><br><span class="line">            clusterDelSlot(j);</span><br><span class="line">            clusterAddSlot(myself,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3) Update state and save config. */</span></span><br><span class="line">    clusterUpdateState();</span><br><span class="line">    clusterSaveConfigOrDie(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4) Pong all the other nodes so that they can update the state</span></span><br><span class="line"><span class="comment">     *    accordingly and detect that we switched to master role. */</span></span><br><span class="line">    clusterBroadcastPong(CLUSTER_BROADCAST_ALL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5) If there was a manual failover in progress, clear the state. */</span></span><br><span class="line">    resetManualFailover();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行必要的 flag 设置和 slots 交接，向集群广播 PONG 消息，并进行善后处理。</p><h4 id="2-1-7-集群其他节点感知主从变化"><a href="#2-1-7-集群其他节点感知主从变化" class="headerlink" title="2.1.7 集群其他节点感知主从变化"></a>2.1.7 集群其他节点感知主从变化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_PONG || type == CLUSTERMSG_TYPE_MEET) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Check for role switch: slave -&gt; master or master -&gt; slave. */</span></span><br><span class="line">    <span class="keyword">if</span> (sender) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">memcmp</span>(hdr-&gt;slaveof, CLUSTER_NODE_NULL_NAME, <span class="keyword">sizeof</span>(hdr-&gt;slaveof)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Node is a master. set master flag for sender */</span></span><br><span class="line">            clusterSetNodeAsMaster(sender);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    clusterNode *sender_master = <span class="literal">NULL</span>; <span class="comment">/* Sender or its master if slave. */</span></span><br><span class="line">    <span class="keyword">int</span> dirty_slots = <span class="number">0</span>; <span class="comment">/* Sender claimed slots don't match my view? */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sender) &#123;</span><br><span class="line">        sender_master = nodeIsMaster(sender) ? sender : sender-&gt;slaveof;</span><br><span class="line">        <span class="keyword">if</span> (sender_master) &#123;</span><br><span class="line">            dirty_slots = <span class="built_in">memcmp</span>(sender_master-&gt;slots, hdr-&gt;myslots, <span class="keyword">sizeof</span>(hdr-&gt;myslots)) != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sender &amp;&amp; nodeIsMaster(sender) &amp;&amp; dirty_slots)</span><br><span class="line">        clusterUpdateSlotsConfigWith(sender,senderConfigEpoch,hdr-&gt;myslots);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集群中其他节点接收到 PONG 消息后，对 sender 进行正确的 role 标记，以某节点 D 为例。<br>对于刚刚做完故障转移的 slave，也即现在 master，在节点 D 看来它负责的 slot 是空的，所以 dirty_slots 为 1。<br>之后调用 <code>clusterUpdateSlotsConfigWith</code> 函数处理 slots 的 dirty diff 信息。</p><p>至此 failover 的逻辑就已经基本完成。</p><h3 id="2-2-主动-failover"><a href="#2-2-主动-failover" class="headerlink" title="2.2 主动 failover"></a>2.2 主动 failover</h3><p>除了上面的发现故障后集群自动 failover，也可以进行主动的主从切换。</p><h4 id="2-2-1-slave-节点接受-cluster-failover-命令"><a href="#2-2-1-slave-节点接受-cluster-failover-命令" class="headerlink" title="2.2.1 slave 节点接受 cluster failover 命令"></a>2.2.1 slave 节点接受 cluster failover 命令</h4><p>主动 failover 是通过 redis 命令实现的，命令格式为 <code>CLUSTER FAILOVER [FORCE|TAKEOVER]</code>，该命令使用详情可以参考这篇<a href="http://www.redis.cn/commands/cluster-failover.html" target="_blank" rel="noopener">文档</a>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLUSTER_MF_TIMEOUT 5000</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"failover"</span>) &amp;&amp; (c-&gt;argc == <span class="number">2</span> || c-&gt;argc == <span class="number">3</span>))&#123;</span><br><span class="line">    <span class="comment">/* CLUSTER FAILOVER [FORCE|TAKEOVER] */</span></span><br><span class="line">    <span class="keyword">int</span> force = <span class="number">0</span>, takeover = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">/* 不与 master 沟通，主节点也不会阻塞其客户端，需要经过选举 */</span></span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">"force"</span>)) &#123;</span><br><span class="line">            force = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 不与 master 沟通，不经过选举 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">"takeover"</span>)) &#123;</span><br><span class="line">            takeover = <span class="number">1</span>;</span><br><span class="line">            force = <span class="number">1</span>; <span class="comment">/* Takeover also implies force. */</span></span><br><span class="line">        <span class="comment">/* 与 master 沟通，需要经过选举 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.syntaxerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    server.cluster-&gt;mf_end = mstime() + CLUSTER_MF_TIMEOUT; <span class="comment">// mf 的超时时间为 5s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cluster failover 命令有三种不同的选项，各有不同的含义，如上面注释所说。takeover 变量标记是否要经过选举， force 变量标记是否需要与 master 沟通。<br>另外，mf 过程有一个过期时间，目前定义为 5s，同时， mf_end 也表示现在正在做 mf。<br>不同的选项有不同的处理方式，如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (takeover) &#123;</span><br><span class="line">    <span class="comment">// takeover 不会做任何初始化校验。</span></span><br><span class="line">    <span class="comment">// 不经过其他节点选举协商，直接将该节点的 current epoch 加 1，然后广播这个新的配置</span></span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Taking over the master (user request)."</span>);</span><br><span class="line">    clusterBumpConfigEpochWithoutConsensus();</span><br><span class="line">    clusterFailoverReplaceYourMaster();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (force) &#123;</span><br><span class="line">    <span class="comment">/* If this is a forced failover, we don't need to talk with our</span></span><br><span class="line"><span class="comment">     * master to agree about the offset. We just failover taking over</span></span><br><span class="line"><span class="comment">     * it without coordination. */</span></span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Forced failover user request accepted."</span>);</span><br><span class="line">    server.cluster-&gt;mf_can_start = <span class="number">1</span>;<span class="comment">// 可以直接开始选举过程</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Manual failover user request accepted."</span>);</span><br><span class="line">    clusterSendMFStart(myself-&gt;slaveof); <span class="comment">// 发送带有 CLUSTERMSG_TYPE_MFSTART 标记的 gossip 包(只有消息头)给我的 master</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>takeover 方式最为粗暴，slave 节点不发起选举，而是直接将自己升级为master，接手原主节点的槽位，增加自己的 configEpoch 后更新配置。<code>clusterFailoverReplaceYourMaster</code> 的逻辑在前面讲过，只有在本轮选举中获得足够多的选票才会调用该函数。<br>force 方式表示可以直接开始选举过程，选举过程也在前面说过了。<br>现在来看看默认方式，处理逻辑为 <code>clusterSendMFStart</code> 函数。该函数主要逻辑就是发送向要做 failover 的 slave 的 master 发送 <code>CLUSTERMSG_TYPE_MFSTART</code> 类型的 gossip 消息。</p><h4 id="2-2-2-master-节点做-mf-准备"><a href="#2-2-2-master-节点做-mf-准备" class="headerlink" title="2.2.2 master 节点做 mf 准备"></a>2.2.2 master 节点做 mf 准备</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_MFSTART) &#123;</span><br><span class="line">    <span class="comment">/* This message is acceptable only if I'm a master and the sender</span></span><br><span class="line"><span class="comment">     * is one of my slaves. */</span></span><br><span class="line">    <span class="keyword">if</span> (!sender || sender-&gt;slaveof != myself) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Manual failover requested from slaves.</span></span><br><span class="line"><span class="comment">     * Initialize the state accordingly.</span></span><br><span class="line"><span class="comment">     * master 收到消息，重置 mf 状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    resetManualFailover();</span><br><span class="line">    server.cluster-&gt;mf_end = mstime() + CLUSTER_MF_TIMEOUT;</span><br><span class="line">    server.cluster-&gt;mf_slave = sender;</span><br><span class="line">    pauseClients(mstime()+(CLUSTER_MF_TIMEOUT*<span class="number">2</span>)); <span class="comment">// 阻塞客户端 10s</span></span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Manual failover requested by slave %.40s."</span>,</span><br><span class="line">              sender-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resetManualFailover</code> 函数中重置与 mf 相关的参数，表示这是一次新的 mf。<br>设置 mf_end，将它的 master 指向 sender（就是那个搞事情的 slave），同时阻塞 client 10s 钟。<br>随后，标记在做 mf 的 master 发送 PING 信息时 hdr 会带上 <strong>CLUSTERMSG_FLAG0_PAUSED</strong> 标记。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterBuildMessageHdr</span><span class="params">(clusterMsg *hdr, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">/* Set the message flags. */</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIsMaster(myself) &amp;&amp; server.cluster-&gt;mf_end)</span><br><span class="line">        hdr-&gt;mflags[<span class="number">0</span>] |= CLUSTERMSG_FLAG0_PAUSED;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mflags 记录与 mf 相关的 flag。</p><h4 id="2-2-3-slave-处理"><a href="#2-2-3-slave-处理" class="headerlink" title="2.2.3 slave 处理"></a>2.2.3 slave 处理</h4><h5 id="2-2-3-1-获得-master-的-repl-offset"><a href="#2-2-3-1-获得-master-的-repl-offset" class="headerlink" title="2.2.3.1 获得 master 的 repl offset"></a>2.2.3.1 获得 master 的 repl offset</h5><p>slave 节点处理带有 <strong>CLUSTERMSG_FLAG0_PAUSED</strong> 标记的 gossip 消息。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clusterProcessPacket</span><span class="params">(clusterLink *link)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sender = clusterLookupNode(hdr-&gt;sender);</span><br><span class="line">    <span class="keyword">if</span> (sender &amp;&amp; !nodeInHandshake(sender)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster-&gt;mf_end &amp;&amp; <span class="comment">// 处于 mf 状态</span></span><br><span class="line">            nodeIsSlave(myself) &amp;&amp;   <span class="comment">// 我是 slave</span></span><br><span class="line">            myself-&gt;slaveof == sender &amp;&amp; <span class="comment">// 我的 master 是 sender</span></span><br><span class="line">            hdr-&gt;mflags[<span class="number">0</span>] &amp; CLUSTERMSG_FLAG0_PAUSED &amp;&amp;</span><br><span class="line">            server.cluster-&gt;mf_master_offset == <span class="number">0</span>) <span class="comment">// 还没有正式开始时，mf_master_offset 设置为 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            server.cluster-&gt;mf_master_offset = sender-&gt;repl_offset; <span class="comment">// 从 sender 获得 repl_offset</span></span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                      <span class="string">"Received replication offset for paused "</span></span><br><span class="line">                      <span class="string">"master manual failover: %lld"</span>,</span><br><span class="line">                      server.cluster-&gt;mf_master_offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于那个发起 failover 的 slave，记下其 master 的 repl_offset，如果之前还没有记录下的话。</p><h5 id="2-2-3-2-向-maser-追平-repl-offset"><a href="#2-2-3-2-向-maser-追平-repl-offset" class="headerlink" title="2.2.3.2 向 maser 追平 repl offset"></a>2.2.3.2 向 maser 追平 repl offset</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIsSlave(myself)) &#123;</span><br><span class="line">        clusterHandleManualFailover();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterHandleManualFailover</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Return ASAP if no manual failover is in progress. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;mf_end == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If mf_can_start is non-zero, the failover was already triggered so the</span></span><br><span class="line"><span class="comment">     * next steps are performed by clusterHandleSlaveFailover(). */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;mf_can_start) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;mf_master_offset == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">/* Wait for offset... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;mf_master_offset == replicationGetSlaveOffset()) &#123;</span><br><span class="line">        <span class="comment">/* Our replication offset matches the master replication offset</span></span><br><span class="line"><span class="comment">         * announced after clients were paused. We can start the failover. */</span></span><br><span class="line">        server.cluster-&gt;mf_can_start = <span class="number">1</span>;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">"All master replication stream processed, "</span></span><br><span class="line">                  <span class="string">"manual failover can start."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>clusterCron</code> 函数里有 <code>clusterHandleManualFailover</code> 的逻辑。<br>mf_end 为 0，说明此时没有 mf 发生。<br>mf_can_start 非 0 值，表示现在可以此 slave 可以发起选举了。<br>mf_master_offset 为 0，说明现在还没有获得 master 的复制偏移量，需要等一会儿。当 mf_master_offset 值等于 <code>replicationGetSlaveOffset</code> 函数的返回值时，把 mf_can_start 置为 1。另外，应该记得，使用带有 force 选项的 <code>CLUSTER FAILOVER</code> 命令，直接就会把 mf_can_start 置为 1，而 <code>replicationGetSlaveOffset</code> 函数的作用就是检查当前的主从复制偏移量，也就是说主从复制偏移量一定要达到 mf_master_offset 时，slave 才会发起选举，即默认选项有一个追平 repl offset 的过程。</p><p>其他一些选举什么的流程跟被动 failover 没有区别。</p><h4 id="2-2-4-过期清理-mf"><a href="#2-2-4-过期清理-mf" class="headerlink" title="2.2.4 过期清理 mf"></a>2.2.4 过期清理 mf</h4><p>主从节点在周期性的<code>clusterCron</code> 中都有一个检查本次 mf 是否过期的函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manualFailoverCheckTimeout</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;mf_end &amp;&amp; server.cluster-&gt;mf_end &lt; mstime()) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Manual failover timed out."</span>);</span><br><span class="line">        resetManualFailover();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetManualFailover</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;mf_end &amp;&amp; clientsArePaused()) &#123;</span><br><span class="line">        server.clients_pause_end_time = <span class="number">0</span>;</span><br><span class="line">        clientsArePaused(); <span class="comment">/* Just use the side effect of the function. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    server.cluster-&gt;mf_end = <span class="number">0</span>; <span class="comment">/* No manual failover in progress. */</span></span><br><span class="line">    server.cluster-&gt;mf_can_start = <span class="number">0</span>;</span><br><span class="line">    server.cluster-&gt;mf_slave = <span class="literal">NULL</span>;</span><br><span class="line">    server.cluster-&gt;mf_master_offset = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果过期没有做 mf ，那么就会重置它的相关参数。</p><h2 id="3-附录"><a href="#3-附录" class="headerlink" title="3. 附录"></a>3. 附录</h2><h3 id="3-1-epoch-概念"><a href="#3-1-epoch-概念" class="headerlink" title="3.1 epoch 概念"></a>3.1 epoch 概念</h3><p>在 Redis cluster 里 epoch 是个非常重要的概念，类似于 raft 算法中的 term 概念。Redis cluster 里主要是两种：currentEpoch 和 configEpoch。</p><h4 id="3-1-1-currentEpoch"><a href="#3-1-1-currentEpoch" class="headerlink" title="3.1.1 currentEpoch"></a>3.1.1 currentEpoch</h4><blockquote><p> 这是一个集群状态相关的概念，可以当做记录集群状态变更的递增版本号。每个集群节点，都会通过server.cluster-&gt;currentEpoch 记录当前的 currentEpoch。</p><p>集群节点创建时，不管是主节点还是从节点，都置currentEpoch 为 0。当前节点接收到来自其他节点的包时，如果发送者的currentEpoch（消息头部会包含发送者的currentEpoch）大于当前节点的currentEpoch，那么当前节点会更新 currentEpoch 为发送者的 currentEpoch。因此，集群中所有节点的currentEpoch最终会达成一致，相当于对集群状态的认知达成了一致。</p></blockquote><p>currentEpoch 作用在于，集群状态发生改变时，某节点会先增加自身 currentEpoch 的值，然后向集群中其他节点征求同意，以便执行某些动作。目前，仅用于 slave 节点的故障转移流程，在上面分析中也看到了，在发起选举之前，slave 会增加自己的 currentEpoch，并且得到的 currentEpoch 表示这一轮选举的 voteEpoch，当获得了足够多的选票后才会执行故障转移。</p><h4 id="3-1-2-configEpoch"><a href="#3-1-2-configEpoch" class="headerlink" title="3.1.2 configEpoch"></a>3.1.2 configEpoch</h4><blockquote><p>这是一个集群节点配置相关的概念，每个集群节点都有自己独一无二的 configepoch。所谓的节点配置，实际上是指节点所负责的 slot 信息。</p></blockquote><p>configEpoch 主要用于解决不同的节点就 slot 归属认知发生冲突的情况。公说公有理婆说婆有理，到底听谁的，configEpoch 越大，看到的集群节点配置信息越新，就越有话语权。对于冲突的情况，后面会有博客进行详细分析。</p><p>以下几种情况 configEpoch 会更新：</p><ol><li>新节点加入；</li><li>槽节点映射冲突检测；（slot 归属变更）</li><li>从节点投票选举冲突检测。(主从切换)</li></ol><p>递增 node epoch 称为 bump epoch。关于 configEpoch 有三个原则：</p><ol><li>如果 epoch 不变, 集群就不应该有变更(包括选举和迁移槽位)。</li><li>每个节点的 node epoch 都是独一无二的。</li><li>拥有越高 epoch 的节点, 集群信息越新。</li></ol><h3 id="3-2-clusterUpdateState-函数逻辑"><a href="#3-2-clusterUpdateState-函数逻辑" class="headerlink" title="3.2 clusterUpdateState 函数逻辑"></a>3.2 clusterUpdateState 函数逻辑</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLUSTER_MAX_REJOIN_DELAY 5000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLUSTER_MIN_REJOIN_DELAY 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLUSTER_WRITABLE_DELAY 2000</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterUpdateState</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">mstime_t</span> among_minority_time;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">mstime_t</span> first_call_time = <span class="number">0</span>;</span><br><span class="line">    server.cluster-&gt;todo_before_sleep &amp;= ~CLUSTER_TODO_UPDATE_STATE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 时间从第一次调用该函数算起，是为了跳过 DB load 时间。</span></span><br><span class="line"><span class="comment">     * cluster 启动时，状态为 CLUSTER_FAIL，</span></span><br><span class="line"><span class="comment">     * 这里要等待一定的时间(2s)让 cluster 变为 CLUSTER_OK 状态。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (first_call_time == <span class="number">0</span>) first_call_time = mstime();</span><br><span class="line">    <span class="keyword">if</span> (nodeIsMaster(myself) &amp;&amp;</span><br><span class="line">        server.cluster-&gt;state == CLUSTER_FAIL &amp;&amp;</span><br><span class="line">        mstime() - first_call_time &lt; CLUSTER_WRITABLE_DELAY) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 先假设集群状态为 CLUSTER_OK，</span></span><br><span class="line"><span class="comment">     * 然后遍历 16384 个 slot，如果发现有 slot 被有被接管，</span></span><br><span class="line"><span class="comment">     * 或者接管某 slot 的 node 是 fail 状态，那么把集群设置为 CLUSTER_FAIL，退出循环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    new_state = CLUSTER_OK;</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_require_full_coverage) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; CLUSTER_SLOTS; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (server.cluster-&gt;slots[j] == <span class="literal">NULL</span> ||</span><br><span class="line">                server.cluster-&gt;slots[j]-&gt;flags &amp; (CLUSTER_NODE_FAIL))</span><br><span class="line">            &#123;</span><br><span class="line">                new_state = CLUSTER_FAIL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">/* 计算 cluster size，计数的是那些至少负责一个 slot 的 node</span></span><br><span class="line"><span class="comment">        * 计算 reachable_masters，计数基于 cluster size，</span></span><br><span class="line"><span class="comment">        * 加入筛选条件(不带有 CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL) 标记</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        dictIterator *di;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">        server.cluster-&gt;<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">        di = dictGetSafeIterator(server.cluster-&gt;nodes);</span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            clusterNode *node = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nodeIsMaster(node) &amp;&amp; node-&gt;numslots) &#123;</span><br><span class="line">                server.cluster-&gt;<span class="built_in">size</span>++;</span><br><span class="line">                <span class="keyword">if</span> ((node-&gt;flags &amp; (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) == <span class="number">0</span>)</span><br><span class="line">                    reachable_masters++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果 reachable_masters 不到 cluster size 一半(a minority partition)，</span></span><br><span class="line"><span class="comment">         * 就将集群标记为 CLUSTER_FAIL</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> needed_quorum = (server.cluster-&gt;<span class="built_in">size</span> / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (reachable_masters &lt; needed_quorum) &#123;</span><br><span class="line">            new_state = CLUSTER_FAIL;</span><br><span class="line">            among_minority_time = mstime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (new_state != server.cluster-&gt;state) &#123;</span><br><span class="line">        <span class="keyword">mstime_t</span> rejoin_delay = server.cluster_node_timeout;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rejoin_delay &gt; CLUSTER_MAX_REJOIN_DELAY)</span><br><span class="line">            rejoin_delay = CLUSTER_MAX_REJOIN_DELAY;</span><br><span class="line">        <span class="keyword">if</span> (rejoin_delay &lt; CLUSTER_MIN_REJOIN_DELAY)</span><br><span class="line">            rejoin_delay = CLUSTER_MIN_REJOIN_DELAY;</span><br><span class="line">        <span class="comment">/* 处于 minority partition 的时间没有超过 cluster_node_timeout，</span></span><br><span class="line"><span class="comment">         * 那么此次不更新集群状态。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (new_state == CLUSTER_OK &amp;&amp;</span><br><span class="line">            nodeIsMaster(myself) &amp;&amp;</span><br><span class="line">            mstime() - among_minority_time &lt; rejoin_delay)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Change the state and log the event. */</span></span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Cluster state changed: %s"</span>,</span><br><span class="line">            new_state == CLUSTER_OK ? <span class="string">"ok"</span> : <span class="string">"fail"</span>);</span><br><span class="line">        server.cluster-&gt;state = new_state;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p><i class="fa fa-link" aria-hidden="true"></i> <a href="https://blog.csdn.net/gqtcgq/article/details/51830428" target="_blank" rel="noopener">Redis源码解析：27集群(三)主从复制、故障转移</a></p></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="social-share" data-disabled="google,facebook,qzone,twitter,diandian,linkedin,qzone,tencent"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/1bcb9a09.html"><i class="fa fa-chevron-left"></i><span>Redigo 源码分析</span></a></div><div class="next-post pull-right"><a href="/d15eb256.html"><span>Redis 持久化之 AOF 重写</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script>!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script></div></div></div><footer class="footer-bg" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;&nbsp;2016 - 2020 By Happen</div><div class="framework-info"><span>Powered by</span> <a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>