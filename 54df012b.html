<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/dolphin.png"><link rel="icon" type="image/png" href="/images/dolphin.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#433d3c"><meta name="description" content=""><meta name="author" content="Happen"><meta name="keywords" content=""><title>Redis 源码之故障转移 - HappenのMemo</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/monokai.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body><header style="height:60vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>HappenのMemo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(/images/about-banner.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"><span class="h2" id="subtitle"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Happen </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2019-01-31 16:13" pubdate>2019-01-31 16:13</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 7.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 107 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">Redis 源码之故障转移</h1><p class="note note-info">本文最后更新于：2019-01-31 16:13</p><div class="markdown-body" id="post-body"><p>在 Redis cluster 中故障转移是个很重要的功能，下面就从故障发现到故障转移整个流程做一下详细分析。</p><!--more----><h2 id="1- 故障检测">1. 故障检测</h2><h3 id="1-1-PFAIL- 标记">1.1 PFAIL 标记</h3><p>集群中每个节点都会定期向其他节点发送 <strong>PING</strong> 消息，以此来检测对方是否在线，如果接收 <strong>PING</strong> 消息的节点 B 没有在规定时间（<strong>cluster_node_timeout</strong>）内回应节点 A <strong>PONG</strong> 消息，那么节点 A 就会将节点 B 标记为疑似下线（probable fail, <strong>PFAIL</strong>）。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clusterCron</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-comment">// ...</span>
    di = dictGetSafeIterator(server.cluster-&gt;nodes);
    <span class="hljs-keyword">while</span>((de = dictNext(di)) != <span class="hljs-literal">NULL</span>) &#123;
        clusterNode *node = dictGetVal(de);
        now = mstime(); <span class="hljs-comment">/* Use an updated time at every iteration. */</span>
        <span class="hljs-comment">// ...</span>
        delay = now - node-&gt;ping_sent;
        <span class="hljs-keyword">if</span> (delay &gt; server.cluster_node_timeout) &#123;
            <span class="hljs-comment">/* Timeout reached. Set the node as possibly failing if it is</span>
<span class="hljs-comment">             * not already in this state. */</span>
            <span class="hljs-keyword">if</span> (!(node-&gt;flags &amp; (CLUSTER_NODE_PFAIL|CLUSTER_NODE_FAIL))) &#123;
                node-&gt;flags |= CLUSTER_NODE_PFAIL;
                update_state = <span class="hljs-number">1</span>;
            &#125;
        &#125;
    &#125;
    dictReleaseIterator(di);
    <span class="hljs-comment">// ...</span>
&#125;</code></pre></div><p>可以看到，在 <code>clusterCron</code> 函数中如果对节点 B 发出 PING 消息，在 <strong>server.cluster_node_timeout</strong> 时间内没有收到其返回的 PONG 消息，如果节点 B 现在没有被标记成 <strong>CLUSTER_NODE_PFAIL</strong> 状态，那么现在就做下这个标记。<br>可以根据 <strong>ping_sent</strong> 参数进行判断的依据如下，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">clusterProcessPacket</span><span class="hljs-params">(clusterLink *link)</span> </span>&#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">if</span> (link-&gt;node &amp;&amp; type == CLUSTERMSG_TYPE_PONG) &#123;
        link-&gt;node-&gt;pong_received = mstime();
        link-&gt;node-&gt;ping_sent = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// ...</span>
    &#125;
    <span class="hljs-comment">// ...</span>
&#125;</code></pre></div><p>当节点 A 接收到节点 B 的 PONG 消息时，会把 <strong>ping_sent</strong> 更新成 0，同时记下收到本次 PONG 消息的时间。<br>上面提到的 clusterNode 与 clusterLink 有如下关联关系：<br><img src="http://ww1.sinaimg.cn/large/71ca8e3cly1fzpznib0gij20ff07qjrt.jpg" srcset="/img/loading.gif" alt=""></p><p>可以看出， clusterLink 就是为了接收对端 gossip 消息而设置的。<br>另外，我们发现， 在上面的 <code>clusterCron</code> 函数中将节点标记成 PFAIL 时，会将 update_state 变量置为 1，这会引发后面更改集群状态的逻辑。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (update_state || server.cluster-&gt;state == CLUSTER_FAIL)
    clusterUpdateState();</code></pre></div><p>集群有两个状态，<strong>CLUSTER_OK</strong> 和 <strong>CLUSTER_FAIL</strong>，如果集群目前状态是 CLUSTER_FAIL，且设置了参数 <code>cluster-require-full-coverage yes</code>，那么此时访问集群会返回错误，意思是可能有某些 slot 没有被 server 接管。<br><code>clusterUpdateState</code> 函数负责更新集群状态，该部分逻辑与本篇博文要讲的主逻辑关系不大，所以放到了后面的 <strong>补充章节 </strong>中了。</p><h3 id="1-2-FAIL- 标记">1.2 FAIL 标记</h3><h4 id="1-2-1- 主动标记 -FAIL">1.2.1 主动标记 FAIL</h4><p>被节点 A 标记成 FAIL/ PFAIL 的节点如何让节点 C 知道呢？这主要是通过平常发送的 PING/PONG 消息实现的，在 3.x 的版本时，会尽最大努力把这样的节点放到 gossip 消息的流言部分，到后面的 4.x 版本的代码中每次的 PING/PONG 消息都会把 PFAIL 节点都带上。<br><code>clusterProcessGossipSection</code> 函数用来处理 gossip 消息的流言部分。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clusterProcessGossipSection</span><span class="hljs-params">(clusterMsg *hdr, clusterLink *link)</span> </span>&#123;
    <span class="hljs-keyword">uint16_t</span> count = ntohs(hdr-&gt;count);
    clusterMsgDataGossip *g = (clusterMsgDataGossip*) hdr-&gt;data.ping.gossip;
    clusterNode *sender = link-&gt;node ? link-&gt;node : clusterLookupNode(hdr-&gt;sender);
    <span class="hljs-keyword">while</span>(count--) &#123;
        <span class="hljs-comment">// ...</span>
        node = clusterLookupNode(g-&gt;nodename);
        <span class="hljs-keyword">if</span> (node) &#123;
            <span class="hljs-keyword">if</span> (sender &amp;&amp; nodeIsMaster(sender) &amp;&amp; node != myself) &#123;
                <span class="hljs-keyword">if</span> (flags &amp; (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) &#123;
                    <span class="hljs-keyword">if</span> (clusterNodeAddFailureReport(node,sender)) &#123;
                        serverLog(LL_VERBOSE,
                           <span class="hljs-string">&quot;Node %.40s reported node %.40s as not reachable.&quot;</span>,
                            sender-&gt;name, node-&gt;name);
                    &#125;
                    markNodeAsFailingIfNeeded(node);
                &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">// ...</span>
                &#125;
            &#125;
        <span class="hljs-comment">// ...</span>
        &#125;
    <span class="hljs-comment">// ...</span>
    &#125;
    <span class="hljs-comment">// ...</span>
&#125;</code></pre></div><p>该函数依次处理 gossip 消息流言部分携带的各节点信息（总节点数的 1/10）。当发现带有 CLUSTER_NODE_FAIL 或者 CLUSTER_NODE_PFAIL 时会调用 <code>clusterNodeAddFailureReport</code> 函数。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">clusterNodeAddFailureReport</span><span class="hljs-params">(clusterNode *failing, clusterNode *sender)</span> </span>&#123;
    <span class="hljs-built_in">list</span> *l = failing-&gt;fail_reports;
    listNode *ln;
    listIter li;
    clusterNodeFailReport *fr;

    <span class="hljs-comment">/* If a failure report from the same sender already exists, just update</span>
<span class="hljs-comment">     * the timestamp. */</span>
    listRewind(l,&amp;li);
    <span class="hljs-keyword">while</span> ((ln = listNext(&amp;li)) != <span class="hljs-literal">NULL</span>) &#123;
        fr = ln-&gt;value;
        <span class="hljs-keyword">if</span> (fr-&gt;node == sender) &#123;
            fr-&gt;time = mstime();
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
    &#125;

    <span class="hljs-comment">/* Otherwise create a new report. */</span>
    fr = zmalloc(<span class="hljs-keyword">sizeof</span>(*fr));
    fr-&gt;node = sender;
    fr-&gt;time = mstime();
    listAddNodeTail(l,fr);
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
&#125;</code></pre></div><p>每一个节点都有一个名为 fail_reports 的 list 结构的变量，用来搜集该异常节点获得了集群中哪些节点的 PFAIL 状态投票。fail_reports 每个成员都是一个 clusterNodeFailReport 结构。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clusterNodeFailReport</span> &#123;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clusterNode</span> *<span class="hljs-title">node</span>;</span>  <span class="hljs-comment">/* Node reporting the failure condition. */</span>
    <span class="hljs-keyword">mstime_t</span> time;             <span class="hljs-comment">/* Time of the last report from this node. */</span>
&#125; clusterNodeFailReport;</code></pre></div><p>clusterNodeFailReport 中带有时间戳，标记这个节点上一次被报上来处于异常状态的时间。<br>每次调用 <code>clusterNodeAddFailureReport</code> 函数时，先会检查 sender 是否已经为该异常节点投票过了，如果有，更新时间戳，如果没有，把 sender 加入到投票节点中。<br>简单点说就是，在 A 节点看来 B 节点是 PFAIL 状态，在 gossip 通信中把它告诉了 C 节点，C 节点发现这个异常状态的节点，检查一下为 B 节点投过票的节点中有没有 A 节点，如果没有就加进去。</p><p>然后下面就是判断 PFAIL 状态是不是要转变成 FAIL 状态的关键。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">markNodeAsFailingIfNeeded</span><span class="hljs-params">(clusterNode *node)</span> </span>&#123;
    <span class="hljs-keyword">int</span> failures;
    <span class="hljs-keyword">int</span> needed_quorum = (server.cluster-&gt;size / <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;

    <span class="hljs-keyword">if</span> (!nodeTimedOut(node)) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* We can reach it. */</span>
    <span class="hljs-keyword">if</span> (nodeFailed(node)) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* Already FAILing. */</span>

    failures = clusterNodeFailureReportsCount(node);
    <span class="hljs-comment">/* Also count myself as a voter if I&#x27;m a master. */</span>
    <span class="hljs-keyword">if</span> (nodeIsMaster(myself)) failures++;
    <span class="hljs-keyword">if</span> (failures &lt; needed_quorum) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* No weak agreement from masters. */</span>

    serverLog(LL_NOTICE, <span class="hljs-string">&quot;Marking node %.40s as failing (quorum reached).&quot;</span>, node-&gt;name);

    <span class="hljs-comment">/* Mark the node as failing. */</span>
    node-&gt;flags &amp;= ~CLUSTER_NODE_PFAIL;
    node-&gt;flags |= CLUSTER_NODE_FAIL;
    node-&gt;fail_time = mstime();

    <span class="hljs-comment">/* Broadcast the failing node name to everybody, forcing all the other</span>
<span class="hljs-comment">     * reachable nodes to flag the node as FAIL. */</span>
    <span class="hljs-keyword">if</span> (nodeIsMaster(myself)) clusterSendFail(node-&gt;name); <span class="hljs-comment">/* 广播这个节点的 fail 消息 */</span>
    clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
&#125;</code></pre></div><p>C 节点收到消息，检查下 A 报过来的异常节点 B，在自己看来是否也是 PFAIL 状态的，如果不是，那么不理会 A 节点本次 report。如果在节点 C 看来，节点 B 已经被标记成 FAIL 了，那么就不需要进行下面的判定了。</p><p>在函数 <code>clusterNodeFailureReportsCount</code> 中会判断计算出把 B 节点标记成 PFAIL 状态的节点的数量 sum，如果 <strong>sum 值小于集群 size 的一半 </strong>，为防止误判，忽略掉这条信息。在函数 <code>clusterNodeFailureReportsCount</code> 中会检查关于 B 节点的 <strong>clusterNodeFailReport</strong>，清理掉那些<strong> 过期的 </strong>投票，过期时间为 2 倍的 <strong>server.cluster_node_timeout</strong>。</p><p>如果满足条件，节点 C 将节点 B 的 PFAIL 状态消除，标记成 FAIL，同时记下 fail_time，如果 C 节点是个 master，那么将 B 节点 FAIL 的消息广播出去，以便让集群中其他节点尽快知道。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clusterSendFail</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *nodename)</span> </span>&#123;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-keyword">sizeof</span>(clusterMsg)];
    clusterMsg *hdr = (clusterMsg*) buf;
    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAIL);
    <span class="hljs-built_in">memcpy</span>(hdr-&gt;data.fail.about.nodename,nodename,CLUSTER_NAMELEN);
    clusterBroadcastMessage(buf,ntohl(hdr-&gt;totlen));
&#125;</code></pre></div><p>发送的 gossip 消息类型为 CLUSTERMSG_TYPE_FAIL，广播的节点排除自身和处于 HANDSHAKE 状态节点。</p><h4 id="1-2-2-Gossip- 被动感知 -FAIL">1.2.2 Gossip 被动感知 FAIL</h4><p>前面说过，gossip 消息的处理函数为 <code>clusterProcessPacket</code>，下面看 CLUSTERMSG_TYPE_FAIL 类型的消息如何处理。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">clusterProcessPacket</span><span class="hljs-params">(clusterLink *link)</span> </span>&#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">uint16_t</span> type = ntohs(hdr-&gt;type);
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">if</span> (type == CLUSTERMSG_TYPE_FAIL) &#123; <span class="hljs-comment">// fail</span>
        clusterNode *failing;
        <span class="hljs-keyword">if</span> (sender) &#123;
            failing = clusterLookupNode(hdr-&gt;data.fail.about.nodename);
            <span class="hljs-keyword">if</span> (failing &amp;&amp; !(failing-&gt;flags &amp; (CLUSTER_NODE_FAIL|CLUSTER_NODE_MYSELF)))
            &#123;
                serverLog(LL_NOTICE,
                    <span class="hljs-string">&quot;FAIL message received from %.40s about %.40s&quot;</span>,
                    hdr-&gt;sender, hdr-&gt;data.fail.about.nodename);
                failing-&gt;flags |= CLUSTER_NODE_FAIL;
                failing-&gt;fail_time = mstime();
                failing-&gt;flags &amp;= ~CLUSTER_NODE_PFAIL;
                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                                     CLUSTER_TODO_UPDATE_STATE);
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            serverLog(LL_NOTICE,
                <span class="hljs-string">&quot;Ignoring FAIL message from unknown node %.40s about %.40s&quot;</span>,
                hdr-&gt;sender, hdr-&gt;data.fail.about.nodename);
        &#125;
    &#125;
    <span class="hljs-comment">// ...</span>
&#125;</code></pre></div><p>集群中另一个节点 D 收到节点 B 广播过来的消息：B 节点 FAIL 了。如果 D 还没有把 B 标记成 FAIL，那么标记成 CLUSTER_NODE_FAIL，并取消 CLUSTER_NODE_PFAIL 标记；否则，忽略，因为 D 已经知道 B 是 FAIL 节点了。</p><h2 id="2- 故障转移">2. 故障转移</h2><p>failover 分为两类，主动 failover（主动切主从）以及被动 failover（被动切主从），下面挨个进行分析。</p><h3 id="2-1- 被动 -failover">2.1 被动 failover</h3><h4 id="2-1-1- 先验条件及初始化">2.1.1 先验条件及初始化</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clusterCron</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">if</span> (nodeIsSlave(myself)) &#123;
        clusterHandleSlaveFailover();
        <span class="hljs-comment">// ...</span>
    &#125;
    <span class="hljs-comment">// ...</span>
&#125;</code></pre></div><p>是否要做被动主从切换，在 <code>clusterHandleSlaveFailover</code> 函数中有如下的判断逻辑，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (nodeIsMaster(myself) ||
    myself-&gt;slaveof == <span class="hljs-literal">NULL</span> ||
    (!nodeFailed(myself-&gt;slaveof) &amp;&amp; !manual_failover) ||
    myself-&gt;slaveof-&gt;numslots == <span class="hljs-number">0</span>)
&#123;
    <span class="hljs-comment">/* There are no reasons to failover, so we set the reason why we</span>
<span class="hljs-comment">     * are returning without failing over to NONE. */</span>
    server.cluster-&gt;cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;
    <span class="hljs-keyword">return</span>;
&#125;</code></pre></div><p>只有满足如下条件的节点才有资格做 failover：</p><ul><li>slave 节点</li><li>master 不为空</li><li>master 负责的 slot 数量不为空</li><li>master 被标记成了 FAIL，或者这是一个主动 failover（manual_failover 为真）</li></ul><p>假设，现在 B 节点的 slave Bx 节点检测到 B 节点挂掉了，通过了以上的条件测试，接下来就会进行 failover。<br>那么下面 Bx 节点就开始在集群中进行拉票，该逻辑也在 <code>clusterHandleSlaveFailover</code> 函数中。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">mstime_t</span> auth_age = mstime() - server.cluster-&gt;failover_auth_time;
<span class="hljs-keyword">int</span> needed_quorum = (server.cluster-&gt;size / <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;
<span class="hljs-keyword">mstime_t</span> auth_timeout, auth_retry_time;

auth_timeout = server.cluster_node_timeout*<span class="hljs-number">2</span>;
<span class="hljs-keyword">if</span> (auth_timeout &lt; <span class="hljs-number">2000</span>) auth_timeout =<span class="hljs-number">2000</span> ;
auth_retry_time = auth_timeout*<span class="hljs-number">2</span>;</code></pre></div><p>cluster 的 <strong>failover_auth_time</strong> 属性，表示 slave 节点开始进行故障转移的时刻。集群初始化时该属性置为 0，一旦满足 failover 的条件后，该属性就置为 <strong>未来的某个时间点</strong>（不是立马执行），在该时间点，slave 节点才开始进行拉票。<strong>auth_age</strong> 变量表示从发起 failover 流程开始到现在，已经过去了多长时间。<br><strong>needed_quorum</strong> 变量表示当前 slave 节点必须至少获得多少选票，才能成为新的 master。<br><strong>auth_timeout</strong> 变量表示当前 slave 发起投票后，等待回应的超时时间，至少为 2s。如果超过该时间还没有获得足够的选票，那么表示本次 failover 失败。<br><strong>auth_retry_time</strong> 变量用来判断是否可以开始发起下一次 failover 的时间间隔。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (server.repl_state == REPL_STATE_CONNECTED) &#123;
    data_age = (<span class="hljs-keyword">mstime_t</span>)(server.unixtime - server.master-&gt;lastinteraction) * <span class="hljs-number">1000</span>;
&#125; <span class="hljs-keyword">else</span> &#123;
    data_age = (<span class="hljs-keyword">mstime_t</span>)(server.unixtime - server.repl_down_since) * <span class="hljs-number">1000</span>;
&#125;
<span class="hljs-keyword">if</span> (data_age &gt; server.cluster_node_timeout)
    data_age -= server.cluster_node_timeout;</code></pre></div><p><strong>data_age</strong> 变量表示距离上一次与我的 master 节点交互过去了多长时间。经过 cluster_node_timeout 时间还没有收到 PONG 消息才会将节点标记为 PFAIL 状态。实际上 data_age 表示在 master 节点下线之前，当前 slave 节点有多长时间没有与其交互过了。</p><blockquote><p>data_age 主要用于判断当前 slave 节点的数据新鲜度；如果 data_age 超过了一定时间，表示当前 slave 节点的数据已经太老了，不能替换掉下线 master 节点，因此在不是手动强制故障转移的情况下，直接返回。</p></blockquote><h4 id="2-1-2- 制定 -failover- 时间">2.1.2 制定 failover 时间</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clusterHandleSlaveFailover</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">if</span> (auth_age &gt; auth_retry_time) &#123;
        server.cluster-&gt;failover_auth_time = mstime() +
            <span class="hljs-number">500</span> + <span class="hljs-comment">/* Fixed delay of 500 milliseconds, let FAIL msg propagate. */</span>
            random() % <span class="hljs-number">500</span>; <span class="hljs-comment">/* Random delay between 0 and 500 milliseconds. */</span>
        server.cluster-&gt;failover_auth_count = <span class="hljs-number">0</span>;
        server.cluster-&gt;failover_auth_sent = <span class="hljs-number">0</span>;
        server.cluster-&gt;failover_auth_rank = clusterGetSlaveRank();
        <span class="hljs-comment">/* We add another delay that is proportional to the slave rank.</span>
<span class="hljs-comment">         * Specifically 1 second * rank. This way slaves that have a probably</span>
<span class="hljs-comment">         * less updated replication offset, are penalized.</span>
<span class="hljs-comment">         * */</span>
        server.cluster-&gt;failover_auth_time +=
            server.cluster-&gt;failover_auth_rank * <span class="hljs-number">1000</span>;
        <span class="hljs-keyword">if</span> (server.cluster-&gt;mf_end) &#123;
            server.cluster-&gt;failover_auth_time = mstime();
            server.cluster-&gt;failover_auth_rank = <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-comment">// ...</span>
        clusterBroadcastPong(CLUSTER_BROADCAST_LOCAL_SLAVES);
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-comment">// ...</span>
&#125;</code></pre></div><p>满足条件（<strong>auth_age &gt; auth_retry_time</strong>）后，发起故障转移流程。<br>首先设置故障转移发起时刻，即设置 failover_auth_time 时间。</p><div class="hljs"><pre><code class="hljs c">mstime() + <span class="hljs-number">500</span> + random()%<span class="hljs-number">500</span> + rank*<span class="hljs-number">1000</span></code></pre></div><p>固定延时 500ms 是为了让 master fail 的消息能够广泛传播到集群，这样集群中的其他节点才可能投票。<br>随机延时是为了避免多个你 slave 节点同时发起 failover 流程。<br>rank 表示 slave 节点的排名，计算方式如下，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">clusterGetSlaveRank</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> myoffset;
    <span class="hljs-keyword">int</span> j, rank = <span class="hljs-number">0</span>;
    clusterNode *master;

    serverAssert(nodeIsSlave(myself));
    master = myself-&gt;slaveof;
    <span class="hljs-keyword">if</span> (master == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* Never called by slaves without master. */</span>

    myoffset = replicationGetSlaveOffset();
    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; master-&gt;numslaves; j++)
        <span class="hljs-keyword">if</span> (master-&gt;slaves[j] != myself &amp;&amp;
            master-&gt;slaves[j]-&gt;repl_offset &gt; myoffset) rank++;
    <span class="hljs-keyword">return</span> rank;
&#125;</code></pre></div><p>可以看出，排名主要是根据复制数据量来定，复制数据量越多，排名越靠前（rank 值越小）。这样做是为了做 failover 时尽量选择一个复制数据量较多的 slave，以尽最大努力保留数据。在没有开始拉选票之前，<strong>每隔一段时间 </strong>（每次调用<code>clusterHandleSlaveFailover</code> 函数，也就是每次 cron 的时间）就会调用一次 <code>clusterGetSlaveRank</code> 函数，以更新当前 slave 节点的排名。</p><p><strong>注意</strong>，如果是 mf，那么 failover_auth_time 和 failover_auth_rank 都置为 0，表示该 slave 节点现在就可以执行故障转移。</p><p>最后向该 master 的所有 slave 广播 PONG 消息，主要是为了更新复制偏移量，以便其他 slave 计算出 failover 时间点。<br>这时，函数返回，就此开始了一轮新的故障转移，当已经处在某一轮故障转移时，执行接下来的逻辑。</p><h4 id="2-1-3-slave- 拉选票">2.1.3 slave 拉选票</h4><p>首先对于一些不合理的 failover 要过滤掉。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* Return ASAP if we can&#x27;t still start the election.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">if</span> (mstime() &lt; server.cluster-&gt;failover_auth_time) &#123;
    clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_DELAY);
    <span class="hljs-keyword">return</span>;
&#125;

<span class="hljs-comment">/* Return ASAP if the election is too old to be valid.</span>
<span class="hljs-comment"> * failover 超时</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">if</span> (auth_age &gt; auth_timeout) &#123;
    clusterLogCantFailover(CLUSTER_CANT_FAILOVER_EXPIRED);
    <span class="hljs-keyword">return</span>;
&#125;</code></pre></div><p>然后开始拉选票。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (server.cluster-&gt;failover_auth_sent == <span class="hljs-number">0</span>) &#123;
    server.cluster-&gt;currentEpoch++; <span class="hljs-comment">// 增加当前节点的 currentEpoch 的值，表示要开始新一轮选举了</span>
    server.cluster-&gt;failover_auth_epoch = server.cluster-&gt;currentEpoch;
    serverLog(LL_WARNING,<span class="hljs-string">&quot;Starting a failover election for epoch %llu.&quot;</span>,
              (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) server.cluster-&gt;currentEpoch);

    <span class="hljs-comment">/* 向所有节点发送 CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST 消息，开始拉票 */</span>
    clusterRequestFailoverAuth();
    server.cluster-&gt;failover_auth_sent = <span class="hljs-number">1</span>; <span class="hljs-comment">// 表示已经发起了故障转移流程</span>
    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                         CLUSTER_TODO_UPDATE_STATE|
                         CLUSTER_TODO_FSYNC_CONFIG);
    <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* Wait for replies. */</span>
&#125;</code></pre></div><p>如果 <strong>failover_auth_sent</strong> 为 0，表示没有发起过投票，那么将 currentEpoch 加 1，记录 failover_auth_epoch 为 currentEpoch，函数 <code>clusterRequestFailoverAuth</code> 用来发起投票，failover_auth_sent 置 1，表示该 slave 已经发起过投票了。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clusterRequestFailoverAuth</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-keyword">sizeof</span>(clusterMsg)];
    clusterMsg *hdr = (clusterMsg*) buf;
    <span class="hljs-keyword">uint32_t</span> totlen;

    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST);
    <span class="hljs-comment">/* If this is a manual failover, set the CLUSTERMSG_FLAG0_FORCEACK bit</span>
<span class="hljs-comment">     * in the header to communicate the nodes receiving the message that</span>
<span class="hljs-comment">     * they should authorized the failover even if the master is working. */</span>
    <span class="hljs-keyword">if</span> (server.cluster-&gt;mf_end) hdr-&gt;mflags[<span class="hljs-number">0</span>] |= CLUSTERMSG_FLAG0_FORCEACK;
    totlen = <span class="hljs-keyword">sizeof</span>(clusterMsg)-<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">union</span> clusterMsgData);
    hdr-&gt;totlen = htonl(totlen);
    clusterBroadcastMessage(buf,totlen);
&#125;</code></pre></div><p><code>clusterRequestFailoverAuth</code> 函数向集群广播 <strong>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</strong> 类型的 gossip 信息，这类型的信息就是向集群中的 master 节点索要本轮选举中的选票。另外，如果是 mf，那么会在 gossip hdr 中带上 <strong>CLUSTERMSG_FLAG0_FORCEACK</strong> 信息。</p><h4 id="2-1-4- 其他 -master- 投票">2.1.4 其他 master 投票</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST) &#123;
    <span class="hljs-keyword">if</span> (!sender) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">/* We don&#x27;t know that node. */</span>
    clusterSendFailoverAuthIfNeeded(sender,hdr);
&#125;</code></pre></div><p>在 <code>clusterProcessPacket</code> 函数中处理 gossip 消息，当接收到 <strong>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</strong> 类型的消息时，调用 <code>clusterSendFailoverAuthIfNeeded</code> 函数处理，在满足条件的基础上，给 sender 投票。</p><p>注：以下若不进行特殊说明，都是 <code>clusterSendFailoverAuthIfNeeded</code> 函数处理逻辑。</p><h5 id="2-1-4-1- 筛掉没资格投票的节点">2.1.4.1 筛掉没资格投票的节点</h5><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (nodeIsSlave(myself) || myself-&gt;numslots == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;</code></pre></div><p><i class="fa fa-times" aria-hidden="true"></i> slave 节点或者不负责 slot 的 master 节点</p><h5 id="2-1-4-2- 筛掉不需要投票的 -sender">2.1.4.2 筛掉不需要投票的 sender</h5><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">uint64_t</span> requestCurrentEpoch = ntohu64(request-&gt;currentEpoch);
<span class="hljs-keyword">if</span> (requestCurrentEpoch &lt; server.cluster-&gt;currentEpoch) &#123;
    serverLog(LL_WARNING,
              <span class="hljs-string">&quot;Failover auth denied to %.40s: reqEpoch (%llu) &lt; curEpoch(%llu)&quot;</span>,
              node-&gt;name,
              (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) requestCurrentEpoch,
              (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) server.cluster-&gt;currentEpoch);
    <span class="hljs-keyword">return</span>;
&#125;</code></pre></div><p><i class="fa fa-times" aria-hidden="true"></i> sender 节点集群信息过旧。<br>正常来说，如果 receiver 在接收到 sender 的 CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST 消息之前接收了 PING/PONG 消息，会更新自己的 currentEpoch，这时 currentEpoch 会增加，因为 sender 发起选举之前，会先增加自身的 currentEpoch；否则的话，receiver 的 currentEpoch 应该小于 sender。因此 sender 的 currentEpoch 应该 <strong>&gt;=</strong> receiver 的。有可能 sender 是个长时间下线的节点刚刚上线，这样的节点不能给他投票，因为它的集群信息过旧。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (server.cluster-&gt;lastVoteEpoch == server.cluster-&gt;currentEpoch) &#123;
    serverLog(LL_WARNING,
              <span class="hljs-string">&quot;Failover auth denied to %.40s: already voted for epoch %llu&quot;</span>,
              node-&gt;name,
              (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) server.cluster-&gt;currentEpoch);
    <span class="hljs-keyword">return</span>;
&#125;</code></pre></div><p><i class="fa fa-times" aria-hidden="true"></i> receiver 节点在本轮选举中已经投过票了，避免两个 slave 节点同时赢得本界选举。<br>lastVoteEpoch 记录了在本轮投票中 receiver 投过票的 sender 的 currentEpoch。各 slave 节点独立发起选举，currentEpoch 是相同的，都在原来的基础上加 1。</p><div class="hljs"><pre><code class="hljs c">clusterNode *master = node-&gt;slaveof;
<span class="hljs-keyword">if</span> (nodeIsMaster(node) || master == <span class="hljs-literal">NULL</span> || (!nodeFailed(master) &amp;&amp; !force_ack))
&#123;
    <span class="hljs-keyword">if</span> (nodeIsMaster(node)) &#123;
        serverLog(LL_WARNING,
                  <span class="hljs-string">&quot;Failover auth denied to %.40s: it is a master node&quot;</span>,
                  node-&gt;name);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (master == <span class="hljs-literal">NULL</span>) &#123;
        serverLog(LL_WARNING,
                  <span class="hljs-string">&quot;Failover auth denied to %.40s: I don&#x27;t know its master&quot;</span>,
                  node-&gt;name);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!nodeFailed(master)) &#123;
        serverLog(LL_WARNING,
                  <span class="hljs-string">&quot;Failover auth denied to %.40s: its master is up&quot;</span>,
                  node-&gt;name);
    &#125;
    <span class="hljs-keyword">return</span>;
&#125;</code></pre></div><p><i class="fa fa-times" aria-hidden="true"></i> sender 是个 master。<br><i class="fa fa-times" aria-hidden="true"></i> sender 是个没有 master 的 slave。<br><i class="fa fa-times" aria-hidden="true"></i> sender 的 master 没有 fail，且不是个 mf。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (mstime() - node-&gt;slaveof-&gt;voted_time &lt; server.cluster_node_timeout * <span class="hljs-number">2</span>)
&#123;
    serverLog(LL_WARNING,
              <span class="hljs-string">&quot;Failover auth denied to %.40s: &quot;</span>
              <span class="hljs-string">&quot;can&#x27;t vote about this master before %lld milliseconds&quot;</span>,
              node-&gt;name,
              (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) ((server.cluster_node_timeout*<span class="hljs-number">2</span>) - (mstime() - node-&gt;slaveof-&gt;voted_time)));
    <span class="hljs-keyword">return</span>;
&#125;</code></pre></div><p><i class="fa fa-times" aria-hidden="true"></i> 两次投票时间间隔 <strong>不能少于 2 倍 的 cluster_node_timeout</strong>。<br>这个裕量时间，使得获得赢得选举的 slave 将新的主从关系周知集群其他节点，避免其他 slave 发起新一轮的投票。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">uint64_t</span> requestConfigEpoch = ntohu64(request-&gt;configEpoch);
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *claimed_slots = request-&gt;myslots;
<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; CLUSTER_SLOTS; j++) &#123;
    <span class="hljs-keyword">if</span> (bitmapTestBit(claimed_slots, j) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
    <span class="hljs-keyword">if</span> (server.cluster-&gt;slots[j] == <span class="hljs-literal">NULL</span> ||
        server.cluster-&gt;slots[j]-&gt;configEpoch &lt;= requestConfigEpoch)
    &#123;
        <span class="hljs-keyword">continue</span>;
    &#125;
    <span class="hljs-comment">/* If we reached this point we found a slot that in our current slots</span>
<span class="hljs-comment">         * is served by a master with a greater configEpoch than the one claimed</span>
<span class="hljs-comment">         * by the slave requesting our vote. Refuse to vote for this slave. */</span>
    serverLog(LL_WARNING,
              <span class="hljs-string">&quot;Failover auth denied to %.40s: &quot;</span>
              <span class="hljs-string">&quot;slot %d epoch (%llu) &gt; reqEpoch (%llu)&quot;</span>,
              node-&gt;name, j,
              (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) server.cluster-&gt;slots[j]-&gt;configEpoch,
              (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) requestConfigEpoch);
    <span class="hljs-keyword">return</span>;
&#125;</code></pre></div><p><i class="fa fa-times" aria-hidden="true"></i> sender 节点声称要接管的 slots，在 receiver 节点看来其中有个别 slot 原来负责节点的 configEpoch 要比 sender 的大，这说明 sender 看到的集群消息太旧了，这可能是一个长时间下线又重新上线的节点。</p><h5 id="2-1-4-3- 在本轮选举投票">2.1.4.3 在本轮选举投票</h5><div class="hljs"><pre><code class="hljs c">clusterSendFailoverAuth(node);
server.cluster-&gt;lastVoteEpoch = server.cluster-&gt;currentEpoch;
node-&gt;slaveof-&gt;voted_time = mstime(); <span class="hljs-comment">// 更新投票时间</span></code></pre></div><p><code>clusterSendFailoverAuth</code> 函数中发送 <strong>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</strong> 类型的 gossip 消息，这就算在本轮选举中投票了，并记录本轮投票的 epoch 以及投票时间。</p><h4 id="2-1-5-slave- 统计选票">2.1.5 slave 统计选票</h4><p>slave 接收到 <strong>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</strong> 类型的 gossip 消息，就算统计到一票。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK) &#123; <span class="hljs-comment">// slave 统计票数</span>
    <span class="hljs-keyword">if</span> (!sender) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">/* We don&#x27;t know that node. */</span>
    <span class="hljs-comment">/* We consider this vote only if the sender is a master serving</span>
<span class="hljs-comment">         * a non zero number of slots, and its currentEpoch is greater or</span>
<span class="hljs-comment">         * equal to epoch where this node started the election. */</span>
    <span class="hljs-keyword">if</span> (nodeIsMaster(sender) &amp;&amp; sender-&gt;numslots &gt; <span class="hljs-number">0</span> &amp;&amp;
        senderCurrentEpoch &gt;= server.cluster-&gt;failover_auth_epoch)
    &#123;
        server.cluster-&gt;failover_auth_count++;
        <span class="hljs-comment">/* Maybe we reached a quorum here, set a flag to make sure</span>
<span class="hljs-comment">             * we check ASAP. */</span>
        clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_FAILOVER);
    &#125;
&#125;</code></pre></div><p>sender 是个负责 slot 的 master 并且满足 currentEpoch 的要求，那么这张选票有效。出现 <code>senderCurrentEpoch &lt; server.cluster-&gt;failover_auth_epoch</code> 的情况时有可能的，如果这张选票是上一轮选举的获得选票，就不能作数。<br>failover_auth_count 变量中记录了 slave 在本轮选举中获得选票数目。</p><h4 id="2-1-6-slave- 做主从切换">2.1.6 slave 做主从切换</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clusterHandleSlaveFailover</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">int</span> needed_quorum = (server.cluster-&gt;size / <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (server.cluster-&gt;failover_auth_count &gt;= needed_quorum) &#123;
        <span class="hljs-comment">/* We have the quorum, we can finally failover the master. */</span>
        serverLog(LL_WARNING,
                  <span class="hljs-string">&quot;Failover election won: I&#x27;m the new master.&quot;</span>);

        <span class="hljs-comment">/* Update my configEpoch to the epoch of the election. */</span>
        <span class="hljs-keyword">if</span> (myself-&gt;configEpoch &lt; server.cluster-&gt;failover_auth_epoch) &#123;
            myself-&gt;configEpoch = server.cluster-&gt;failover_auth_epoch;
            serverLog(LL_WARNING,
                      <span class="hljs-string">&quot;configEpoch set to %llu after successful failover&quot;</span>,
                      (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) myself-&gt;configEpoch);
        &#125;

        <span class="hljs-comment">/* Take responsability for the cluster slots. */</span>
        clusterFailoverReplaceYourMaster();
    &#125; <span class="hljs-keyword">else</span> &#123;
        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_VOTES);
    &#125;
&#125;</code></pre></div><p>slave 节点获得足够多选票后， 成为新的 master 节点。<br>更新自己的 configEpoch 为 <strong>选举协商 </strong>的 failover_auth_epoch，这是本节点就获得了最新当前集群最大的 configEpoch，表明它看到的集群信息现在是最新的。<br>最后调用 <code>clusterFailoverReplaceYourMaster</code> 函数取代下线主节点，成为新的主节点，并向其他节点广播这种变化。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clusterFailoverReplaceYourMaster</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-keyword">int</span> j;
    clusterNode *oldmaster = myself-&gt;slaveof;

    <span class="hljs-keyword">if</span> (nodeIsMaster(myself) || oldmaster == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">/* 1) Turn this node into a master. */</span>
    <span class="hljs-comment">/* 把 myself 标记为 master，并从原 master 里删掉，更新原 master 的涉及 slave 的参数，</span>
<span class="hljs-comment">     * 如果 slave 数量为 0, 去掉它的 CLUSTER_NODE_MIGRATE_TO 标记</span>
<span class="hljs-comment">     */</span>
    clusterSetNodeAsMaster(myself);

    <span class="hljs-comment">/* 取消主从复制过程，将当前节点升级为主节点 *、</span>
<span class="hljs-comment">    replicationUnsetMaster();</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">    /* 2) Claim all the slots assigned to our master.</span>
<span class="hljs-comment">     * 接手老的 master 节点负责的槽位</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; CLUSTER_SLOTS; j++) &#123;
        <span class="hljs-keyword">if</span> (clusterNodeGetSlotBit(oldmaster,j)) &#123;
            clusterDelSlot(j);
            clusterAddSlot(myself,j);
        &#125;
    &#125;

    <span class="hljs-comment">/* 3) Update state and save config. */</span>
    clusterUpdateState();
    clusterSaveConfigOrDie(<span class="hljs-number">1</span>);

    <span class="hljs-comment">/* 4) Pong all the other nodes so that they can update the state</span>
<span class="hljs-comment">     *    accordingly and detect that we switched to master role. */</span>
    clusterBroadcastPong(CLUSTER_BROADCAST_ALL);

    <span class="hljs-comment">/* 5) If there was a manual failover in progress, clear the state. */</span>
    resetManualFailover();
&#125;</code></pre></div><p>进行必要的 flag 设置和 slots 交接，向集群广播 PONG 消息，并进行善后处理。</p><h4 id="2-1-7- 集群其他节点感知主从变化">2.1.7 集群其他节点感知主从变化</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_PONG || type == CLUSTERMSG_TYPE_MEET) &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">/* Check for role switch: slave -&gt; master or master -&gt; slave. */</span>
    <span class="hljs-keyword">if</span> (sender) &#123;
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">memcmp</span>(hdr-&gt;slaveof, CLUSTER_NODE_NULL_NAME, <span class="hljs-keyword">sizeof</span>(hdr-&gt;slaveof)))
        &#123;
            <span class="hljs-comment">/* Node is a master. set master flag for sender */</span>
            clusterSetNodeAsMaster(sender);
        &#125;
        <span class="hljs-comment">// ...</span>
    &#125;
    clusterNode *sender_master = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* Sender or its master if slave. */</span>
    <span class="hljs-keyword">int</span> dirty_slots = <span class="hljs-number">0</span>; <span class="hljs-comment">/* Sender claimed slots don&#x27;t match my view? */</span>

    <span class="hljs-keyword">if</span> (sender) &#123;
        sender_master = nodeIsMaster(sender) ? sender : sender-&gt;slaveof;
        <span class="hljs-keyword">if</span> (sender_master) &#123;
            dirty_slots = <span class="hljs-built_in">memcmp</span>(sender_master-&gt;slots, hdr-&gt;myslots, <span class="hljs-keyword">sizeof</span>(hdr-&gt;myslots)) != <span class="hljs-number">0</span>;
        &#125;
    &#125;

    <span class="hljs-keyword">if</span> (sender &amp;&amp; nodeIsMaster(sender) &amp;&amp; dirty_slots)
        clusterUpdateSlotsConfigWith(sender,senderConfigEpoch,hdr-&gt;myslots);
    <span class="hljs-comment">// ...</span>
&#125;</code></pre></div><p>集群中其他节点接收到 PONG 消息后，对 sender 进行正确的 role 标记，以某节点 D 为例。<br>对于刚刚做完故障转移的 slave，也即现在 master，在节点 D 看来它负责的 slot 是空的，所以 dirty_slots 为 1。<br>之后调用 <code>clusterUpdateSlotsConfigWith</code> 函数处理 slots 的 dirty diff 信息。</p><p>至此 failover 的逻辑就已经基本完成。</p><h3 id="2-2- 主动 -failover">2.2 主动 failover</h3><p>除了上面的发现故障后集群自动 failover，也可以进行主动的主从切换。</p><h4 id="2-2-1-slave- 节点接受 -cluster-failover- 命令">2.2.1 slave 节点接受 cluster failover 命令</h4><p>主动 failover 是通过 redis 命令实现的，命令格式为 <code>CLUSTER FAILOVER [FORCE|TAKEOVER]</code>，该命令使用详情可以参考这篇 <a target="_blank" rel="noopener" href="http://www.redis.cn/commands/cluster-failover.html">文档</a>。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLUSTER_MF_TIMEOUT 5000</span>
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="hljs-number">1</span>]-&gt;ptr,<span class="hljs-string">&quot;failover&quot;</span>) &amp;&amp; (c-&gt;argc == <span class="hljs-number">2</span> || c-&gt;argc == <span class="hljs-number">3</span>))&#123;
    <span class="hljs-comment">/* CLUSTER FAILOVER [FORCE|TAKEOVER] */</span>
    <span class="hljs-keyword">int</span> force = <span class="hljs-number">0</span>, takeover = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> (c-&gt;argc == <span class="hljs-number">3</span>) &#123;
        <span class="hljs-comment">/* 不与 master 沟通，主节点也不会阻塞其客户端，需要经过选举 */</span>
        <span class="hljs-keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="hljs-number">2</span>]-&gt;ptr,<span class="hljs-string">&quot;force&quot;</span>)) &#123;
            force = <span class="hljs-number">1</span>;
        <span class="hljs-comment">/* 不与 master 沟通，不经过选举 */</span>
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="hljs-number">2</span>]-&gt;ptr,<span class="hljs-string">&quot;takeover&quot;</span>)) &#123;
            takeover = <span class="hljs-number">1</span>;
            force = <span class="hljs-number">1</span>; <span class="hljs-comment">/* Takeover also implies force. */</span>
        <span class="hljs-comment">/* 与 master 沟通，需要经过选举 */</span>
        &#125; <span class="hljs-keyword">else</span> &#123;
            addReply(c,shared.syntaxerr);
            <span class="hljs-keyword">return</span>;
        &#125;
    &#125;
    <span class="hljs-comment">// ...</span>
    server.cluster-&gt;mf_end = mstime() + CLUSTER_MF_TIMEOUT; <span class="hljs-comment">// mf 的超时时间为 5s</span>
&#125;</code></pre></div><p>cluster failover 命令有三种不同的选项，各有不同的含义，如上面注释所说。takeover 变量标记是否要经过选举， force 变量标记是否需要与 master 沟通。<br>另外，mf 过程有一个过期时间，目前定义为 5s，同时， mf_end 也表示现在正在做 mf。<br>不同的选项有不同的处理方式，如下，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (takeover) &#123;
    <span class="hljs-comment">// takeover 不会做任何初始化校验。</span>
    <span class="hljs-comment">// 不经过其他节点选举协商，直接将该节点的 current epoch 加 1，然后广播这个新的配置</span>
    serverLog(LL_WARNING,<span class="hljs-string">&quot;Taking over the master (user request).&quot;</span>);
    clusterBumpConfigEpochWithoutConsensus();
    clusterFailoverReplaceYourMaster();
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (force) &#123;
    <span class="hljs-comment">/* If this is a forced failover, we don&#x27;t need to talk with our</span>
<span class="hljs-comment">     * master to agree about the offset. We just failover taking over</span>
<span class="hljs-comment">     * it without coordination. */</span>
    serverLog(LL_WARNING,<span class="hljs-string">&quot;Forced failover user request accepted.&quot;</span>);
    server.cluster-&gt;mf_can_start = <span class="hljs-number">1</span>;<span class="hljs-comment">// 可以直接开始选举过程</span>
&#125; <span class="hljs-keyword">else</span> &#123;
    serverLog(LL_WARNING,<span class="hljs-string">&quot;Manual failover user request accepted.&quot;</span>);
    clusterSendMFStart(myself-&gt;slaveof); <span class="hljs-comment">// 发送带有 CLUSTERMSG_TYPE_MFSTART 标记的 gossip 包 (只有消息头) 给我的 master</span>
&#125;</code></pre></div><p>takeover 方式最为粗暴，slave 节点不发起选举，而是直接将自己升级为 master，接手原主节点的槽位，增加自己的 configEpoch 后更新配置。<code>clusterFailoverReplaceYourMaster</code> 的逻辑在前面讲过，只有在本轮选举中获得足够多的选票才会调用该函数。<br>force 方式表示可以直接开始选举过程，选举过程也在前面说过了。<br>现在来看看默认方式，处理逻辑为 <code>clusterSendMFStart</code> 函数。该函数主要逻辑就是发送向要做 failover 的 slave 的 master 发送 <code>CLUSTERMSG_TYPE_MFSTART</code> 类型的 gossip 消息。</p><h4 id="2-2-2-master- 节点做 -mf- 准备">2.2.2 master 节点做 mf 准备</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == CLUSTERMSG_TYPE_MFSTART) &#123;
    <span class="hljs-comment">/* This message is acceptable only if I&#x27;m a master and the sender</span>
<span class="hljs-comment">     * is one of my slaves. */</span>
    <span class="hljs-keyword">if</span> (!sender || sender-&gt;slaveof != myself) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-comment">/* Manual failover requested from slaves.</span>
<span class="hljs-comment">     * Initialize the state accordingly.</span>
<span class="hljs-comment">     * master 收到消息，重置 mf 状态</span>
<span class="hljs-comment">     */</span>
    resetManualFailover();
    server.cluster-&gt;mf_end = mstime() + CLUSTER_MF_TIMEOUT;
    server.cluster-&gt;mf_slave = sender;
    pauseClients(mstime()+(CLUSTER_MF_TIMEOUT*<span class="hljs-number">2</span>)); <span class="hljs-comment">// 阻塞客户端 10s</span>
    serverLog(LL_WARNING,<span class="hljs-string">&quot;Manual failover requested by slave %.40s.&quot;</span>,
              sender-&gt;name);
&#125;</code></pre></div><p><code>resetManualFailover</code> 函数中重置与 mf 相关的参数，表示这是一次新的 mf。<br>设置 mf_end，将它的 master 指向 sender（就是那个搞事情的 slave），同时阻塞 client 10s 钟。<br>随后，标记在做 mf 的 master 发送 PING 信息时 hdr 会带上 <strong>CLUSTERMSG_FLAG0_PAUSED</strong> 标记。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clusterBuildMessageHdr</span><span class="hljs-params">(clusterMsg *hdr, <span class="hljs-keyword">int</span> type)</span> </span>&#123;
    <span class="hljs-comment">// ...</span>
      <span class="hljs-comment">/* Set the message flags. */</span>
    <span class="hljs-keyword">if</span> (nodeIsMaster(myself) &amp;&amp; server.cluster-&gt;mf_end)
        hdr-&gt;mflags[<span class="hljs-number">0</span>] |= CLUSTERMSG_FLAG0_PAUSED;
    <span class="hljs-comment">// ...</span>
&#125;</code></pre></div><p>mflags 记录与 mf 相关的 flag。</p><h4 id="2-2-3-slave- 处理">2.2.3 slave 处理</h4><h5 id="2-2-3-1- 获得 -master- 的 -repl-offset">2.2.3.1 获得 master 的 repl offset</h5><p>slave 节点处理带有 <strong>CLUSTERMSG_FLAG0_PAUSED</strong> 标记的 gossip 消息。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">clusterProcessPacket</span><span class="hljs-params">(clusterLink *link)</span> </span>&#123;
    <span class="hljs-comment">// ...</span>
    sender = clusterLookupNode(hdr-&gt;sender);
    <span class="hljs-keyword">if</span> (sender &amp;&amp; !nodeInHandshake(sender)) &#123;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">if</span> (server.cluster-&gt;mf_end &amp;&amp; <span class="hljs-comment">// 处于 mf 状态</span>
            nodeIsSlave(myself) &amp;&amp;   <span class="hljs-comment">// 我是 slave</span>
            myself-&gt;slaveof == sender &amp;&amp; <span class="hljs-comment">// 我的 master 是 sender</span>
            hdr-&gt;mflags[<span class="hljs-number">0</span>] &amp; CLUSTERMSG_FLAG0_PAUSED &amp;&amp;
            server.cluster-&gt;mf_master_offset == <span class="hljs-number">0</span>) <span class="hljs-comment">// 还没有正式开始时，mf_master_offset 设置为 0</span>
        &#123;
            server.cluster-&gt;mf_master_offset = sender-&gt;repl_offset; <span class="hljs-comment">// 从 sender 获得 repl_offset</span>
            serverLog(LL_WARNING,
                      <span class="hljs-string">&quot;Received replication offset for paused &quot;</span>
                      <span class="hljs-string">&quot;master manual failover: %lld&quot;</span>,
                      server.cluster-&gt;mf_master_offset);
        &#125;
    &#125;
    <span class="hljs-comment">// ...</span>
&#125;</code></pre></div><p>对于那个发起 failover 的 slave，记下其 master 的 repl_offset，如果之前还没有记录下的话。</p><h5 id="2-2-3-2- 向 -maser- 追平 -repl-offset">2.2.3.2 向 maser 追平 repl offset</h5><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clusterCron</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">if</span> (nodeIsSlave(myself)) &#123;
        clusterHandleManualFailover();
        <span class="hljs-comment">// ...</span>
    &#125;
    <span class="hljs-comment">// ...</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clusterHandleManualFailover</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-comment">/* Return ASAP if no manual failover is in progress. */</span>
    <span class="hljs-keyword">if</span> (server.cluster-&gt;mf_end == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">/* If mf_can_start is non-zero, the failover was already triggered so the</span>
<span class="hljs-comment">     * next steps are performed by clusterHandleSlaveFailover(). */</span>
    <span class="hljs-keyword">if</span> (server.cluster-&gt;mf_can_start) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">if</span> (server.cluster-&gt;mf_master_offset == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* Wait for offset... */</span>

    <span class="hljs-keyword">if</span> (server.cluster-&gt;mf_master_offset == replicationGetSlaveOffset()) &#123;
        <span class="hljs-comment">/* Our replication offset matches the master replication offset</span>
<span class="hljs-comment">         * announced after clients were paused. We can start the failover. */</span>
        server.cluster-&gt;mf_can_start = <span class="hljs-number">1</span>;
        serverLog(LL_WARNING,
                  <span class="hljs-string">&quot;All master replication stream processed, &quot;</span>
                  <span class="hljs-string">&quot;manual failover can start.&quot;</span>);
    &#125;
&#125;</code></pre></div><p>在 <code>clusterCron</code> 函数里有 <code>clusterHandleManualFailover</code> 的逻辑。<br>mf_end 为 0，说明此时没有 mf 发生。<br>mf_can_start 非 0 值，表示现在可以此 slave 可以发起选举了。<br>mf_master_offset 为 0，说明现在还没有获得 master 的复制偏移量，需要等一会儿。当 mf_master_offset 值等于 <code>replicationGetSlaveOffset</code> 函数的返回值时，把 mf_can_start 置为 1。另外，应该记得，使用带有 force 选项的 <code>CLUSTER FAILOVER</code> 命令，直接就会把 mf_can_start 置为 1，而 <code>replicationGetSlaveOffset</code> 函数的作用就是检查当前的主从复制偏移量，也就是说主从复制偏移量一定要达到 mf_master_offset 时，slave 才会发起选举，即默认选项有一个追平 repl offset 的过程。</p><p>其他一些选举什么的流程跟被动 failover 没有区别。</p><h4 id="2-2-4- 过期清理 -mf">2.2.4 过期清理 mf</h4><p>主从节点在周期性的<code>clusterCron</code> 中都有一个检查本次 mf 是否过期的函数。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">manualFailoverCheckTimeout</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (server.cluster-&gt;mf_end &amp;&amp; server.cluster-&gt;mf_end &lt; mstime()) &#123;
        serverLog(LL_WARNING,<span class="hljs-string">&quot;Manual failover timed out.&quot;</span>);
        resetManualFailover();
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resetManualFailover</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (server.cluster-&gt;mf_end &amp;&amp; clientsArePaused()) &#123;
        server.clients_pause_end_time = <span class="hljs-number">0</span>;
        clientsArePaused(); <span class="hljs-comment">/* Just use the side effect of the function. */</span>
    &#125;
    server.cluster-&gt;mf_end = <span class="hljs-number">0</span>; <span class="hljs-comment">/* No manual failover in progress. */</span>
    server.cluster-&gt;mf_can_start = <span class="hljs-number">0</span>;
    server.cluster-&gt;mf_slave = <span class="hljs-literal">NULL</span>;
    server.cluster-&gt;mf_master_offset = <span class="hljs-number">0</span>;
&#125;</code></pre></div><p>如果过期没有做 mf ，那么就会重置它的相关参数。</p><h2 id="3- 附录">3. 附录</h2><h3 id="3-1-epoch- 概念">3.1 epoch 概念</h3><p>在 Redis cluster 里 epoch 是个非常重要的概念，类似于 raft 算法中的 term 概念。Redis cluster 里主要是两种：currentEpoch 和 configEpoch。</p><h4 id="3-1-1-currentEpoch">3.1.1 currentEpoch</h4><blockquote><p>这是一个集群状态相关的概念，可以当做记录集群状态变更的递增版本号。每个集群节点，都会通过 server.cluster-&gt;currentEpoch 记录当前的 currentEpoch。</p><p>集群节点创建时，不管是主节点还是从节点，都置 currentEpoch 为 0。当前节点接收到来自其他节点的包时，如果发送者的 currentEpoch（消息头部会包含发送者的 currentEpoch）大于当前节点的 currentEpoch，那么当前节点会更新 currentEpoch 为发送者的 currentEpoch。因此，集群中所有节点的 currentEpoch 最终会达成一致，相当于对集群状态的认知达成了一致。</p></blockquote><p>currentEpoch 作用在于，集群状态发生改变时，某节点会先增加自身 currentEpoch 的值，然后向集群中其他节点征求同意，以便执行某些动作。目前，仅用于 slave 节点的故障转移流程，在上面分析中也看到了，在发起选举之前，slave 会增加自己的 currentEpoch，并且得到的 currentEpoch 表示这一轮选举的 voteEpoch，当获得了足够多的选票后才会执行故障转移。</p><h4 id="3-1-2-configEpoch">3.1.2 configEpoch</h4><blockquote><p>这是一个集群节点配置相关的概念，每个集群节点都有自己独一无二的 configepoch。所谓的节点配置，实际上是指节点所负责的 slot 信息。</p></blockquote><p>configEpoch 主要用于解决不同的节点就 slot 归属认知发生冲突的情况。公说公有理婆说婆有理，到底听谁的，configEpoch 越大，看到的集群节点配置信息越新，就越有话语权。对于冲突的情况，后面会有博客进行详细分析。</p><p>以下几种情况 configEpoch 会更新：</p><ol><li>新节点加入；</li><li>槽节点映射冲突检测；（slot 归属变更）</li><li>从节点投票选举冲突检测。(主从切换)</li></ol><p>递增 node epoch 称为 bump epoch。关于 configEpoch 有三个原则：</p><ol><li>如果 epoch 不变, 集群就不应该有变更(包括选举和迁移槽位)。</li><li>每个节点的 node epoch 都是独一无二的。</li><li>拥有越高 epoch 的节点, 集群信息越新。</li></ol><h3 id="3-2-clusterUpdateState- 函数逻辑">3.2 clusterUpdateState 函数逻辑</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLUSTER_MAX_REJOIN_DELAY 5000</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLUSTER_MIN_REJOIN_DELAY 500</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLUSTER_WRITABLE_DELAY 2000</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clusterUpdateState</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">mstime_t</span> among_minority_time;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">mstime_t</span> first_call_time = <span class="hljs-number">0</span>;
    server.cluster-&gt;todo_before_sleep &amp;= ~CLUSTER_TODO_UPDATE_STATE;

    <span class="hljs-comment">/* 时间从第一次调用该函数算起，是为了跳过 DB load 时间。</span>
<span class="hljs-comment">     * cluster 启动时，状态为 CLUSTER_FAIL，</span>
<span class="hljs-comment">     * 这里要等待一定的时间 (2s) 让 cluster 变为 CLUSTER_OK 状态。</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">if</span> (first_call_time == <span class="hljs-number">0</span>) first_call_time = mstime();
    <span class="hljs-keyword">if</span> (nodeIsMaster(myself) &amp;&amp;
        server.cluster-&gt;state == CLUSTER_FAIL &amp;&amp;
        mstime() - first_call_time &lt; CLUSTER_WRITABLE_DELAY) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">/* 先假设集群状态为 CLUSTER_OK，</span>
<span class="hljs-comment">     * 然后遍历 16384 个 slot，如果发现有 slot 被有被接管，</span>
<span class="hljs-comment">     * 或者接管某 slot 的 node 是 fail 状态，那么把集群设置为 CLUSTER_FAIL，退出循环</span>
<span class="hljs-comment">     */</span>
    new_state = CLUSTER_OK;
    <span class="hljs-keyword">if</span> (server.cluster_require_full_coverage) &#123;
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; CLUSTER_SLOTS; j++) &#123;
            <span class="hljs-keyword">if</span> (server.cluster-&gt;slots[j] == <span class="hljs-literal">NULL</span> ||
                server.cluster-&gt;slots[j]-&gt;flags &amp; (CLUSTER_NODE_FAIL))
            &#123;
                new_state = CLUSTER_FAIL;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125;
    &#123;
       <span class="hljs-comment">/* 计算 cluster size，计数的是那些至少负责一个 slot 的 node</span>
<span class="hljs-comment">        * 计算 reachable_masters，计数基于 cluster size，</span>
<span class="hljs-comment">        * 加入筛选条件(不带有 CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL) 标记</span>
<span class="hljs-comment">        */</span>
        dictIterator *di;
        dictEntry *de;
        server.cluster-&gt;size = <span class="hljs-number">0</span>;
        di = dictGetSafeIterator(server.cluster-&gt;nodes);
        <span class="hljs-keyword">while</span>((de = dictNext(di)) != <span class="hljs-literal">NULL</span>) &#123;
            clusterNode *node = dictGetVal(de);

            <span class="hljs-keyword">if</span> (nodeIsMaster(node) &amp;&amp; node-&gt;numslots) &#123;
                server.cluster-&gt;size++;
                <span class="hljs-keyword">if</span> ((node-&gt;flags &amp; (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) == <span class="hljs-number">0</span>)
                    reachable_masters++;
            &#125;
        &#125;
        dictReleaseIterator(di);
    &#125;
    &#123;
        <span class="hljs-comment">/* 如果 reachable_masters 不到 cluster size 一半(a minority partition)，</span>
<span class="hljs-comment">         * 就将集群标记为 CLUSTER_FAIL</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-keyword">int</span> needed_quorum = (server.cluster-&gt;size / <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (reachable_masters &lt; needed_quorum) &#123;
            new_state = CLUSTER_FAIL;
            among_minority_time = mstime();
        &#125;
    &#125;

    <span class="hljs-keyword">if</span> (new_state != server.cluster-&gt;state) &#123;
        <span class="hljs-keyword">mstime_t</span> rejoin_delay = server.cluster_node_timeout;

        <span class="hljs-keyword">if</span> (rejoin_delay &gt; CLUSTER_MAX_REJOIN_DELAY)
            rejoin_delay = CLUSTER_MAX_REJOIN_DELAY;
        <span class="hljs-keyword">if</span> (rejoin_delay &lt; CLUSTER_MIN_REJOIN_DELAY)
            rejoin_delay = CLUSTER_MIN_REJOIN_DELAY;
        <span class="hljs-comment">/* 处于 minority partition 的时间没有超过 cluster_node_timeout，</span>
<span class="hljs-comment">         * 那么此次不更新集群状态。</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-keyword">if</span> (new_state == CLUSTER_OK &amp;&amp;
            nodeIsMaster(myself) &amp;&amp;
            mstime() - among_minority_time &lt; rejoin_delay)
        &#123;
            <span class="hljs-keyword">return</span>;
        &#125;

        <span class="hljs-comment">/* Change the state and log the event. */</span>
        serverLog(LL_WARNING,<span class="hljs-string">&quot;Cluster state changed: %s&quot;</span>,
            new_state == CLUSTER_OK ? <span class="hljs-string">&quot;ok&quot;</span> : <span class="hljs-string">&quot;fail&quot;</span>);
        server.cluster-&gt;state = new_state;
    &#125;
</code></pre></div><h2 id="4- 参考">4. 参考</h2><p><i class="fa fa-link" aria-hidden="true"></i> <a target="_blank" rel="noopener" href="https://blog.csdn.net/gqtcgq/article/details/51830428">Redis 源码解析：27 集群 (三) 主从复制、故障转移</a></p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/redis/">redis</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext row"><article class="post-prev col-6"><a href="/1bcb9a09.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Redigo 源码分析</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/d15eb256.html"><span class="hidden-mobile">Redis 持久化之 AOF 重写</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script type="text/javascript">function loadLivere(){addScript("https://cdn-city.livere.com/js/embed.dist.js")}waitElementVisible("lv-container",loadLivere)</script><noscript>为正常使用来必力评论功能请允许 JavaScript 运行</noscript></div></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:3,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","Redis 源码之故障转移&nbsp;"],cursorChar:"|",typeSpeed:72,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "§"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>