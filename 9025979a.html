<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Redis源码之主从复制(4)"><meta name="keywords" content="redis"><meta name="author" content="Happen"><meta name="copyright" content="Happen"><title>Redis源码之主从复制(4) | Happen's Memo</title><link rel="shortcut icon" href="/images/dolphin.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?882b48640075e00a238ae94a7eec0d40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,c,g,o){e.GoogleAnalyticsObject=c,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,g=a.createElement(t),o=a.getElementsByTagName(t)[0],g.async=1,g.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(g,o)}(window,document,"script",0,"ga"),ga("create","RRBput3V2WYVZd2lq058Z4IwJEhViOwuMElqkWh6bcA","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#主从建链与握手阶段"><span class="toc-number">1.</span> <span class="toc-text">主从建链与握手阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PING-命令处理"><span class="toc-number">1.1.</span> <span class="toc-text">PING 命令处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AUTH-命令处理"><span class="toc-number">1.2.</span> <span class="toc-text">AUTH 命令处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#REPLCONF-命令处理"><span class="toc-number">1.3.</span> <span class="toc-text">REPLCONF 命令处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主从复制阶段"><span class="toc-number">2.</span> <span class="toc-text">主从复制阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SYNC-PSYNC-命令处理"><span class="toc-number">2.1.</span> <span class="toc-text">SYNC/PSYNC 命令处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#前置-check"><span class="toc-number">2.1.1.</span> <span class="toc-text">前置 check</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#完全重同步-or-部分重同步"><span class="toc-number">2.1.2.</span> <span class="toc-text">完全重同步 or 部分重同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#完全重同步过程"><span class="toc-number">2.1.3.</span> <span class="toc-text">完全重同步过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#执行-bgsave-操作"><span class="toc-number">2.1.4.</span> <span class="toc-text">执行 bgsave 操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#累积命令流过程"><span class="toc-number">2.2.</span> <span class="toc-text">累积命令流过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bgsave-收尾阶段"><span class="toc-number">3.</span> <span class="toc-text">bgsave 收尾阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#无磁盘复制"><span class="toc-number">3.1.</span> <span class="toc-text">无磁盘复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有磁盘复制"><span class="toc-number">3.2.</span> <span class="toc-text">有磁盘复制</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.png"></div><div class="author-info__name text-center">Happen</div><div class="author-info__description text-center">浮生若梦，为欢几何</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">37</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://renrenlove.me/" target="_blank" rel="noopener">Galway</a><a class="author-info-links__name text-center" href="http://kvguru.com/" target="_blank" rel="noopener">Wangbin</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div id="page-header"> <span class="pull-left"><a id="site-name" href="/">Happen's Memo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Redis源码之主从复制(4)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-13</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/">源码系列</a><div class="post-meta-wordcount"><span>字数总计:</span> <span class="word-count">5.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 25 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>在上一篇文章，主要介绍了主从复制流程中 slave 的状态机流转，本篇文章中，将做相应的 master 逻辑的相关分析。</p><a id="more"></a><h2 id="主从建链与握手阶段"><a href="#主从建链与握手阶段" class="headerlink" title="主从建链与握手阶段"></a>主从建链与握手阶段</h2><blockquote><p>slave 在向 master 发起 TCP 建链，以及复制握手过程中，master 一直把 slave 当成一个普通的 client 来处理。也就是说，不为 slave 保存状态，只是收到 slave 发来的命令进而处理并回复而已。</p></blockquote><h3 id="PING-命令处理"><a href="#PING-命令处理" class="headerlink" title="PING 命令处理"></a>PING 命令处理</h3><p>握手过程中，首先 slave 会发过来一个 PING 命令，master 使用 <strong>pingCommand</strong> 函数来进行处理。回复字符串 <strong>+PONG</strong>，还是权限错误，视情况而定。</p><h3 id="AUTH-命令处理"><a href="#AUTH-命令处理" class="headerlink" title="AUTH 命令处理"></a>AUTH 命令处理</h3><p>可能会有一个鉴权过程，master 收到 slave 发来 AUTH 命令，使用 <strong>authCommand</strong> 函数进行处理，代码大概如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">authCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!server.requirepass) &#123; <span class="comment">// 未设置 auth passwd</span></span><br><span class="line">        addReplyError(c,<span class="string">"Client sent AUTH, but no password is set"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!time_independent_strcmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr, server.requirepass)) &#123;</span><br><span class="line">      c-&gt;authenticated = <span class="number">1</span>;</span><br><span class="line">      addReply(c,shared.ok);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      c-&gt;authenticated = <span class="number">0</span>;</span><br><span class="line">      addReplyError(c,<span class="string">"invalid password"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client 的 <strong>authenticated</strong> 属性表明 server 是否设置了鉴权。</p><h3 id="REPLCONF-命令处理"><a href="#REPLCONF-命令处理" class="headerlink" title="REPLCONF 命令处理"></a>REPLCONF 命令处理</h3><p>接下来就是 REPLCONF 命令，相应处理函数为 <strong>replconfCommand</strong>，用于保存 slave 告知的端口号、地址和能力等。该函数代码逻辑基本如下，</p><p>首先进行必要的参数校验，命令格式为 <code>REPLCONF &lt;option&gt; &lt;value&gt; &lt;option&gt; &lt;value&gt; ...</code>，可以看出，后面的参数值是成对出现的，加上 REPLCONF 本身，参数个数肯定是奇数个，那么偶数个就肯定是有问题的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((c-&gt;argc % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* Number of arguments must be odd to make sure that every</span></span><br><span class="line"><span class="comment">     * option has a corresponding value. */</span></span><br><span class="line">    addReply(c,shared.syntaxerr);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，匹配到各选项分别处理，目前支持的选项有 listening-port、ip-address、capa、ack 和 getack，不支持的选项在报错后会返回，代码处理如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j+=<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">"listening-port"</span>)) &#123;</span><br><span class="line">        <span class="keyword">long</span> port;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((getLongFromObjectOrReply(c,c-&gt;argv[j+<span class="number">1</span>],</span><br><span class="line">                &amp;port,<span class="literal">NULL</span>) != C_OK))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c-&gt;slave_listening_port = port;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">"ip-address"</span>)) &#123;</span><br><span class="line">        sds ip = c-&gt;argv[j+<span class="number">1</span>]-&gt;ptr;</span><br><span class="line">        <span class="keyword">if</span> (sdslen(ip) &lt; <span class="keyword">sizeof</span>(c-&gt;slave_ip)) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(c-&gt;slave_ip,ip,sdslen(ip)+<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyErrorFormat(c,<span class="string">"REPLCONF ip-address provided by "</span></span><br><span class="line">                <span class="string">"slave instance is too long: %zd bytes"</span>, sdslen(ip));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">"capa"</span>)) &#123;</span><br><span class="line">        <span class="comment">/* Ignore capabilities not understood by this master. */</span></span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j+<span class="number">1</span>]-&gt;ptr,<span class="string">"eof"</span>))</span><br><span class="line">            c-&gt;slave_capa |= SLAVE_CAPA_EOF;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyErrorFormat(c,<span class="string">"Unrecognized REPLCONF option: %s"</span>,</span><br><span class="line">            (<span class="keyword">char</span>*)c-&gt;argv[j]-&gt;ptr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主从复制阶段"><a href="#主从复制阶段" class="headerlink" title="主从复制阶段"></a>主从复制阶段</h2><p>接下来，slave 会向 master 发送 SYNC/PSYNC 命令，请求进行完全重同步或者部分重同步。master 为 slave 保存的状态记录在 client 的 <strong>replstate</strong> 属性中。</p><p> 从 master 的角度看，slave 需要经历的如下状态：<strong>SLAVE_STATE_WAIT_BGSAVE_START</strong> → <strong>SLAVE_REPL_WAIT_BGSAVE_END</strong> → <strong>SLAVE_REPL_SEND_BULK</strong> → <strong>SLAVE_REPL_ONLINE</strong>。状态转换图在前一篇文章开头画过，这里不做赘述。</p><h3 id="SYNC-PSYNC-命令处理"><a href="#SYNC-PSYNC-命令处理" class="headerlink" title="SYNC/PSYNC 命令处理"></a>SYNC/PSYNC 命令处理</h3><p>SYNC/PSYNC 命令的处理函数为 <strong>syncCommand</strong>。</p><h4 id="前置-check"><a href="#前置-check" class="headerlink" title="前置 check"></a>前置 check</h4><p>首先，需要做一些必要的 check。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ignore SYNC if already slave or in monitor mode */</span></span><br><span class="line"><span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_SLAVE) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本节点是其他节点的 slave，但是还没有同步好数据，</span></span><br><span class="line"><span class="comment">// 此时不能为本节点的 slave 进行数据同步(因为数据不全)</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state != REPL_STATE_CONNECTED) &#123;</span><br><span class="line">    addReplyError(c,<span class="string">"Can't SYNC while not connected with my master"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 因为 master 接下来需要为该 slave 进行后台 RDB 数据转储了，</span></span><br><span class="line"><span class="comment"> * 同时需要将前台接收到的其他 client 命令请求缓存到该 slave client 的输出缓存中，</span></span><br><span class="line"><span class="comment"> * 这就需要一个完全清空的输出缓存，才能为该 slave 保存从执行 BGSAVE 开始的命令流。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在 master 收到 slave 发来的 SYNC(PSYNC)命令之前，两者之间的交互信息都是比较短的，</span></span><br><span class="line"><span class="comment"> * 因此，在网络正常的情况下，slave client 中的输出缓存应该是很容易就发送给该 slave，并清空的。</span></span><br><span class="line"><span class="comment"> * 所以，如果不为空，说明可能有问题 */</span></span><br><span class="line"><span class="keyword">if</span> (clientHasPendingReplies(c)) &#123;</span><br><span class="line">    addReplyError(c,<span class="string">"SYNC and PSYNC are invalid with pending output"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全重同步-or-部分重同步"><a href="#完全重同步-or-部分重同步" class="headerlink" title="完全重同步 or 部分重同步"></a>完全重同步 or 部分重同步</h4><p>下面就开始进入正题，SYNC/PSYNC 命令进行了区别对待。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// slave 发来 psync 命令</span></span><br><span class="line"><span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr,<span class="string">"psync"</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (masterTryPartialResynchronization(c) == C_OK) &#123;</span><br><span class="line">        server.stat_sync_partial_ok++;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* No full resync needed, return. */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> *master_runid = c-&gt;argv[<span class="number">1</span>]-&gt;ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increment stats for failed PSYNCs, but only if the</span></span><br><span class="line"><span class="comment">         * runid is not "?", as this is used by slaves to force a full</span></span><br><span class="line"><span class="comment">         * resync on purpose when they are not albe to partially</span></span><br><span class="line"><span class="comment">         * resync. */</span></span><br><span class="line">        <span class="keyword">if</span> (master_runid[<span class="number">0</span>] != <span class="string">'?'</span>) server.stat_sync_partial_err++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// slave 发来 sync 命令</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* If a slave uses SYNC, we are dealing with an old implementation</span></span><br><span class="line"><span class="comment">     * of the replication protocol (like redis-cli --slave). Flag the client</span></span><br><span class="line"><span class="comment">     * so that we don't expect to receive REPLCONF ACK feedbacks. */</span></span><br><span class="line">    c-&gt;flags |= CLIENT_PRE_PSYNC; <span class="comment">// 老版本实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，当需要进行<strong>部分重同步</strong>时，函数会直接返回，否则，开始着手处理<strong>完全重同步</strong>的情况，此时 master 要执行一次 rdb 。</p><p>处理 PSYNC 命令的函数是 <strong>masterTryPartialResynchronization</strong>，该函数通过返回值来进行区分是否进行部分重同步，<code>C_OK</code> 表示部分重同步，<code>C_ERR</code> 表示完全重同步，下面进行具体分析。</p><p>首先，把自己的 runid 与 slave 发来的 <strong>master_runid</strong> 相匹配，如果不匹配，说明是一个新的 slave，此时需要进行<strong>完全重同步</strong>，代码如下。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *master_runid = c-&gt;argv[<span class="number">1</span>]-&gt;ptr;</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (strcasecmp(master_runid, server.runid)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// slave 通过发送 runid 为 `？` 来触发一次完全重同步。</span></span><br><span class="line">    <span class="keyword">if</span> (master_runid[<span class="number">0</span>] != <span class="string">'?'</span>) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Partial resynchronization not accepted: "</span></span><br><span class="line">            <span class="string">"Runid mismatch (Client asked for runid '%s', my runid is '%s')"</span>,</span><br><span class="line">            master_runid, server.runid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Full resync requested by slave %s"</span>,</span><br><span class="line">            replicationGetSlaveName(c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> need_full_resync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，取出 slave 的复制偏移量 <strong>psync_offset</strong>，master 据此来判断是否可以进行完全重同步，关于复制偏移量的问题，前面的文章已经提过。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (getLongLongFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;psync_offset,<span class="literal">NULL</span>) !=</span><br><span class="line">    C_OK) <span class="keyword">goto</span> need_full_resync;</span><br><span class="line"><span class="keyword">if</span> (!server.repl_backlog ||</span><br><span class="line">    psync_offset &lt; server.repl_backlog_off ||</span><br><span class="line">    psync_offset &gt; (server.repl_backlog_off + server.repl_backlog_histlen))</span><br><span class="line">&#123;</span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">        <span class="string">"Unable to partial resync with slave %s for lack of backlog (Slave request was: %lld)."</span>, replicationGetSlaveName(c), psync_offset);</span><br><span class="line">    <span class="keyword">if</span> (psync_offset &gt; server.master_repl_offset) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Warning: slave %s tried to PSYNC with an offset that is greater than the master replication offset."</span>, replicationGetSlaveName(c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> need_full_resync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上出现的两种需要进行完全重同步的情况，都会进入 <strong>need_full_resync</strong> 的逻辑，最后返回 <code>C_ERR</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">need_full_resync:</span><br><span class="line">    <span class="comment">/* We need a full resync for some reason... Note that we can't</span></span><br><span class="line"><span class="comment">     * reply to PSYNC right now if a full SYNC is needed. The reply</span></span><br><span class="line"><span class="comment">     * must include the master offset at the time the RDB file we transfer</span></span><br><span class="line"><span class="comment">     * is generated, so we need to delay the reply to that moment. */</span></span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br></pre></td></tr></table></figure><p>否则，表示需要进行部分重同步，进行相应变量的初始化，返回<code>C_OK</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">c-&gt;flags |= CLIENT_SLAVE;</span><br><span class="line">c-&gt;replstate = SLAVE_STATE_ONLINE;</span><br><span class="line">c-&gt;repl_ack_time = server.unixtime;</span><br><span class="line">c-&gt;repl_put_online_on_ack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">listAddNodeTail(server.slaves,c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里不能用输出缓存，因为输出缓存只能用于累积命令流。</span></span><br><span class="line"><span class="comment">// 之前 master 向 slave 发送的信息很少，因此内核的输出缓存中应该会有空间，</span></span><br><span class="line"><span class="comment">// 所以，这里直接的 write 操作一般不会出错。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回复 slave +CONTINUE</span></span><br><span class="line">buflen = <span class="built_in">snprintf</span>(buf,<span class="keyword">sizeof</span>(buf),<span class="string">"+CONTINUE\r\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">write</span>(c-&gt;fd,buf,buflen) != buflen) &#123;</span><br><span class="line">    freeClientAsync(c);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将积压队列中 psync_offset 之后的数据复制到客户端输出缓存中</span></span><br><span class="line">psync_len = addReplyReplicationBacklog(c,psync_offset);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note that we don't need to set the selected DB at server.slaveseldb</span></span><br><span class="line"><span class="comment"> * to -1 to force the master to emit SELECT, since the slave already</span></span><br><span class="line"><span class="comment"> * has this state from the previous connection with the master. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新当前状态正常的 slave 数量</span></span><br><span class="line">refreshGoodSlavesCount();</span><br><span class="line"><span class="keyword">return</span> C_OK; <span class="comment">/* The caller can return, no full resync needed. */</span></span><br></pre></td></tr></table></figure><p><strong>addReplyReplicationBacklog</strong> 函数的逻辑也已经在前面讲过。</p><h4 id="完全重同步过程"><a href="#完全重同步过程" class="headerlink" title="完全重同步过程"></a>完全重同步过程</h4><p>首先，一些变量的更新，将 <strong>replstate</strong> 更新为 <strong>SLAVE_STATE_WAIT_BGSAVE_START</strong> 状态。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server.stat_sync_full++;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Setup the slave as one waiting for BGSAVE to start. The following code</span></span><br><span class="line"><span class="comment">    * paths will change the state if we handle the slave differently. */</span></span><br><span class="line">c-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_START;</span><br><span class="line"><span class="keyword">if</span> (server.repl_disable_tcp_nodelay)</span><br><span class="line">    anetDisableTcpNoDelay(<span class="literal">NULL</span>, c-&gt;fd); <span class="comment">/* Non critical if it fails. */</span></span><br><span class="line">c-&gt;repldbfd = <span class="number">-1</span>;</span><br><span class="line">c-&gt;flags |= CLIENT_SLAVE;</span><br><span class="line">listAddNodeTail(server.slaves,c);</span><br></pre></td></tr></table></figure><p>完全重同步时，master 需要做一次 rdb。后台 rdb 数据生成时需要做 <code>fork</code>，这对性能是有所牺牲的，所以要先看下是否有现成的 rdb 数据可以复用。分以下 3 种清理，</p><p>【1】如果后台有 rdb 任务在执行，并且使用的是<strong>有硬盘复制</strong>的方式（将 rdb 数据保存在本地临时文件），然后发送给 slave。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CASE 1: BGSAVE is in progress, with disk target. */</span></span><br><span class="line"><span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span> &amp;&amp;</span><br><span class="line">    server.rdb_child_type == RDB_CHILD_TYPE_DISK)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Ok a background save is in progress. Let's check if it is a good</span></span><br><span class="line"><span class="comment">     * one for replication, i.e. if there is another slave that is</span></span><br><span class="line"><span class="comment">     * registering differences since the server forked to save. */</span></span><br><span class="line">    client *slave;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line"></span><br><span class="line">    listRewind(server.slaves,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        slave = ln-&gt;value;</span><br><span class="line">        <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* To attach this slave, we check that it has at least all the</span></span><br><span class="line"><span class="comment">     * capabilities of the slave that triggered the current BGSAVE. */</span></span><br><span class="line">    <span class="keyword">if</span> (ln &amp;&amp; ((c-&gt;slave_capa &amp; slave-&gt;slave_capa) == slave-&gt;slave_capa)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Perfect, the server is already registering differences for</span></span><br><span class="line"><span class="comment">         * another slave. Set the right state, and copy the buffer. */</span></span><br><span class="line">        copyClientOutputBuffer(c,slave);</span><br><span class="line">        replicationSetupSlaveForFullResync(c,slave-&gt;psync_initial_offset);</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Waiting for end of BGSAVE for SYNC"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* No way, we need to wait for the next BGSAVE in order to</span></span><br><span class="line"><span class="comment">         * register differences. */</span></span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Can't attach the slave to the current BGSAVE. Waiting for next BGSAVE for SYNC"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中，在 master 所有 slave 中找到一个处于 <strong>SLAVE_STATE_WAIT_BGSAVE_END</strong> 状态的 slaveX。<br>将 slaveX 输出缓存内容 copy 一份给当前的 client，然后调用函数 <strong>replicationSetupSlaveForFullResync</strong>，将 client 状态设置为 <strong>SLAVE_STATE_WAIT_BGSAVE_END</strong>，并发送 <strong>+FULLRESYNC</strong> 回复，代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">replicationSetupSlaveForFullResync</span><span class="params">(client *slave, <span class="keyword">long</span> <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> buflen;</span><br><span class="line"></span><br><span class="line">    slave-&gt;psync_initial_offset = offset;</span><br><span class="line">    slave-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_END;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We are going to accumulate the incremental changes for this</span></span><br><span class="line"><span class="comment">     * slave as well. Set slaveseldb to -1 in order to force to re-emit</span></span><br><span class="line"><span class="comment">     * a SELECT statement in the replication stream. */</span></span><br><span class="line">    server.slaveseldb = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't send this reply to slaves that approached us with</span></span><br><span class="line"><span class="comment">     * the old SYNC command. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(slave-&gt;flags &amp; CLIENT_PRE_PSYNC)) &#123;</span><br><span class="line">        buflen = <span class="built_in">snprintf</span>(buf,<span class="keyword">sizeof</span>(buf),<span class="string">"+FULLRESYNC %s %lld\r\n"</span>,</span><br><span class="line">                          server.runid,offset);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(slave-&gt;fd,buf,buflen) != buflen) &#123;</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要做了以下 4 件事：</p><ul><li>设置 slave 的 <strong>psync_initial_offset</strong> 属性，方便后面再进来的 slave，可以最大限度的复用。</li><li>设置 slave 的当前状态为 <strong>WAIT_BGSAVE_END</strong>，表明 slave 可以从这个点来累积前台发过来的命令流，并等待 rdb 转储完成。</li><li>设置 slave 的 <strong>slaveseldb</strong> 属性为 -1，这样可以在开始累积命令流时，强制增加一条 SELECT 命令到客户端输出缓存中，以免第一条命令没有选择数据库。</li><li>给 slave 一个 <strong>+FULLRESYNC</strong> 的回复。</li></ul><p>该函数应当在以下 2 个时刻立即被调用：</p><ul><li>由复制而发起的一次成功的 bgsave 之后；</li><li>找到了一个可以复用的 slave 之后。</li></ul><p>如果找不到一个可以复用的 slave，那么 master 需要在当前的 bgsave 操作完成之后，再执行一次。</p><p>【2】如果后台有 rdb 任务在执行，并且使用的是<strong>无硬盘复制</strong>的方式。</p><p>此时，当前 slave 无法重用 rdb 数据，必须在当前的 bgsave 操作完成之后，再执行一次。代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CASE 2: BGSAVE is in progress, with socket target. */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span> &amp;&amp;</span><br><span class="line">            server.rdb_child_type == RDB_CHILD_TYPE_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* There is an RDB child process but it is writing directly to</span></span><br><span class="line"><span class="comment">     * children sockets. We need to wait for the next BGSAVE</span></span><br><span class="line"><span class="comment">     * in order to synchronize. */</span></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"Current BGSAVE has socket target. Waiting for next BGSAVE for SYNC"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【3】如果后台没有 rdb 任务在执行。</p><p>若当前 slave 使用的是<strong>无磁盘化复制</strong>，那么暂时先不进行 bgsave，把它推迟到 <strong>replicationCron</strong> 函数，这是<strong>为了等待更多的 slave，以减少执行 bgsave 的次数</strong>，因为使用 diskless 的方式进行主从复制，后来的 slave 不能 attach 到已有 slave 上，只能重新做 bgsave。</p><p>若当前 slave 使用的是<strong>有磁盘化复制</strong>，调用 <strong>startBgsaveForReplication</strong> 函数开始一次新的 bgsave，需要注意的是这里要避开后台的 aofrewite。代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CASE 3: There is no BGSAVE is progress. */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (server.repl_diskless_sync &amp;&amp; (c-&gt;slave_capa &amp; SLAVE_CAPA_EOF)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Diskless replication RDB child is created inside</span></span><br><span class="line"><span class="comment">         * replicationCron() since we want to delay its start a</span></span><br><span class="line"><span class="comment">         * few seconds to wait for more slaves to arrive. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_diskless_sync_delay)</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"Delay next BGSAVE for diskless SYNC"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Target is disk (or the slave is not capable of supporting</span></span><br><span class="line"><span class="comment">         * diskless replication) and we don't have a BGSAVE in progress,</span></span><br><span class="line"><span class="comment">         * let's start one. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            startBgsaveForReplication(c-&gt;slave_capa); <span class="comment">// 直接进行 bgsave</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"No BGSAVE in progress, but an AOF rewrite is active. "</span></span><br><span class="line">                <span class="string">"BGSAVE for replication delayed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，如果有必要的话，创建 backlog。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (listLength(server.slaves) == <span class="number">1</span> &amp;&amp; server.repl_backlog == <span class="literal">NULL</span>)</span><br><span class="line">    createReplicationBacklog();</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createReplicationBacklog</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    serverAssert(server.repl_backlog == <span class="literal">NULL</span>);</span><br><span class="line">    server.repl_backlog = zmalloc(server.repl_backlog_size);</span><br><span class="line">    server.repl_backlog_histlen = <span class="number">0</span>;</span><br><span class="line">    server.repl_backlog_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免之前使用过 backlog 的 slave 引发错误的 PSYNC 操作</span></span><br><span class="line">    server.master_repl_offset++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽管没有数据，但事实上，第一个字节的逻辑位置是 master_repl_offset 的下一个字节</span></span><br><span class="line">    server.repl_backlog_off = server.master_repl_offset+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行-bgsave-操作"><a href="#执行-bgsave-操作" class="headerlink" title="执行 bgsave 操作"></a>执行 bgsave 操作</h4><p>接上一小节，bgsave 操作的处理函数为 <strong>startBgsaveForReplication</strong>。<br>首先根据传入的参数，针对有无磁盘化复制调用不同的处理函数，即，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> retval;</span><br><span class="line"><span class="keyword">int</span> socket_target = server.repl_diskless_sync &amp;&amp; (mincapa &amp; SLAVE_CAPA_EOF);</span><br><span class="line">listIter li;</span><br><span class="line">listNode *ln;</span><br><span class="line"></span><br><span class="line">serverLog(LL_NOTICE,<span class="string">"Starting BGSAVE for SYNC with target: %s"</span>,</span><br><span class="line">    socket_target ? <span class="string">"slaves sockets"</span> : <span class="string">"disk"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket_target)</span><br><span class="line">    retval = rdbSaveToSlavesSockets();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    retval = rdbSaveBackground(server.rdb_filename);</span><br></pre></td></tr></table></figure><p>参数 <strong>mincapa</strong>，表示 slave 的”能力”，即是否能接受无硬盘复制的 rdb 数据。<br>如果选项<code>server.repl_diskless_sync</code> 为真，且 <strong>mincapa</strong> 中包含 <strong>SLAVE_CAPA_EOF</strong>，说明可以为该 slave 直接发送无硬盘复制的 rdb 数据，调用 <strong>rdbSaveToSlavesSockets</strong> 函数，在后台将 rdb 数据通过 socket 发送给所有状态为 <strong>SLAVE_STATE_WAIT_BGSAVE_START</strong> 的 slave。<br>否则，调用<strong>rdbSaveBackground</strong> 函数，在后台将 rdb 数据转储到本地文件。</p><p>如果以上的 rdb 处理函数调用失败，从 slave 列表中删除处于 <strong>SLAVE_STATE_WAIT_BGSAVE_START</strong> 状态的 slave，并在 slave 中加入 <strong>CLIENT_CLOSE_AFTER_REPLY</strong> 标识，以便在回复错误消息后关闭连接。代码逻辑如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (retval == C_ERR) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"BGSAVE for replication failed"</span>);</span><br><span class="line">    listRewind(server.slaves,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</span><br><span class="line">            slave-&gt;flags &amp;= ~CLIENT_SLAVE;</span><br><span class="line">            listDelNode(server.slaves,ln);</span><br><span class="line">            addReplyError(slave,</span><br><span class="line">                <span class="string">"BGSAVE failed, replication can't continue"</span>);</span><br><span class="line">            slave-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用的是有磁盘复制，那么从 slave 列表中找到处于 <strong>SLAVE_STATE_WAIT_BGSAVE_START</strong> 状态的 slave，调用 <strong>replicationSetupSlaveForFullResync</strong> 函数，把 slave 状态置为 <strong>SLAVE_STATE_WAIT_BGSAVE_END</strong>，并回复 <strong>+FULLRESYNC</strong>，这个前面说过。代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* If the target is socket, rdbSaveToSlavesSockets() already setup</span></span><br><span class="line"><span class="comment"> * the salves for a full resync. Otherwise for disk target do it now.*/</span></span><br><span class="line"><span class="keyword">if</span> (!socket_target) &#123;</span><br><span class="line">    listRewind(server.slaves,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</span><br><span class="line">                replicationSetupSlaveForFullResync(slave,</span><br><span class="line">                        getPsyncInitialOffset());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用函数 <strong>replicationScriptCacheFlush</strong> 清空 lua 脚本缓存。</p><h3 id="累积命令流过程"><a href="#累积命令流过程" class="headerlink" title="累积命令流过程"></a>累积命令流过程</h3><p>当 master 收到 client 发来的命令后，会调用 <strong>call</strong> 函数执行相应的命令处理函数。在代码中 <strong>PROPAGATE_REPL</strong> 标识表示需要将命令同步给 slave，有如下逻辑，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">   <span class="comment">/* Propagate the command into the AOF and replication link */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_PROPAGATE &amp;&amp;</span><br><span class="line">        (c-&gt;flags &amp; CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/* Check if the command operated changes in the data set. If so</span></span><br><span class="line"><span class="comment">         * set for replication / AOF propagation. */</span></span><br><span class="line">        <span class="keyword">if</span> (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the client forced AOF / replication of the command, set</span></span><br><span class="line"><span class="comment">         * the flags regardless of the command effects on the data set. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Call propagate() only if at least one of AOF / replication</span></span><br><span class="line"><span class="comment">         * propagation is needed. */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate_flags != PROPAGATE_NONE)</span><br><span class="line">            propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagate</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dbid, robj **argv, <span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.aof_state != AOF_OFF &amp;&amp; flags &amp; PROPAGATE_AOF)</span><br><span class="line">        feedAppendOnlyFile(cmd,dbid,argv,argc);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; PROPAGATE_REPL)</span><br><span class="line">        replicationFeedSlaves(server.slaves,dbid,argv,argc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看重点处理函数 <strong>replicationFeedSlaves</strong>，现在分析如下。</p><p>首先，必要的 check。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 backlog 为空，且本节点没有 slave，那么下面的逻辑就没必要走了</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_backlog == <span class="literal">NULL</span> &amp;&amp; listLength(slaves) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>如果有必要的话，将 SELECT 命令添加到 backlog 和所有状态不是 <strong>SLAVE_STATE_WAIT_BGSAVE_START</strong> 的 slave 输出缓存中，其他命令也是如此，代码大概如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Write the command to the replication backlog if any. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_backlog) &#123;</span><br><span class="line">    <span class="keyword">char</span> aux[LONG_STR_SIZE+<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add the multi bulk reply length. */</span></span><br><span class="line">    <span class="comment">// *..CRLF</span></span><br><span class="line">    aux[<span class="number">0</span>] = <span class="string">'*'</span>;</span><br><span class="line">    len = ll2string(aux+<span class="number">1</span>,<span class="keyword">sizeof</span>(aux)<span class="number">-1</span>,argc);</span><br><span class="line">    aux[len+<span class="number">1</span>] = <span class="string">'\r'</span>;</span><br><span class="line">    aux[len+<span class="number">2</span>] = <span class="string">'\n'</span>;</span><br><span class="line">    feedReplicationBacklog(aux,len+<span class="number">3</span>);<span class="comment">// argc 转换成字符串的长度 + 3，即 * 以及 CRLF</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        <span class="keyword">long</span> objlen = stringObjectLen(argv[j]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We need to feed the buffer with the object as a bulk reply</span></span><br><span class="line"><span class="comment">         * not just as a plain string, so create the $..CRLF payload len</span></span><br><span class="line"><span class="comment">         * and add the final CRLF */</span></span><br><span class="line">        aux[<span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">        len = ll2string(aux+<span class="number">1</span>,<span class="keyword">sizeof</span>(aux)<span class="number">-1</span>,objlen);</span><br><span class="line">        aux[len+<span class="number">1</span>] = <span class="string">'\r'</span>;</span><br><span class="line">        aux[len+<span class="number">2</span>] = <span class="string">'\n'</span>;</span><br><span class="line">        feedReplicationBacklog(aux,len+<span class="number">3</span>);</span><br><span class="line">        feedReplicationBacklogWithObject(argv[j]);</span><br><span class="line">        feedReplicationBacklog(aux+len+<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// CRLF</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write the command to every slave. */</span></span><br><span class="line">listRewind(server.slaves,&amp;li);</span><br><span class="line"><span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">    client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't feed slaves that are still waiting for BGSAVE to start */</span></span><br><span class="line">    <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Feed slaves that are waiting for the initial SYNC (so these commands</span></span><br><span class="line"><span class="comment">        * are queued in the output buffer until the initial SYNC completes),</span></span><br><span class="line"><span class="comment">        * or are already in sync with the master. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add the multi bulk length. */</span></span><br><span class="line">    addReplyMultiBulkLen(slave,argc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally any additional argument that was not stored inside the</span></span><br><span class="line"><span class="comment">        * static buffer if any (from j to argc). */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++)</span><br><span class="line">        addReplyBulk(slave,argv[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向 slave 输出缓存追加命令流时，调用的是 addReply 类的函数。</p><h2 id="bgsave-收尾阶段"><a href="#bgsave-收尾阶段" class="headerlink" title="bgsave 收尾阶段"></a>bgsave 收尾阶段</h2><p>当完成 bgsave 后，无论是有无磁盘复制，都要调用 <strong>updateSlavesWaitingBgsave</strong> 函数进行最后的处理，主要是为了前面说过的<strong>被推迟的 bgsave</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateSlavesWaitingBgsave</span><span class="params">(<span class="keyword">int</span> bgsaveerr, <span class="keyword">int</span> type)</span> </span>&#123;.....&#125;</span><br></pre></td></tr></table></figure><p>遍历 slave 列表，如果 slave 的复制状态处于 <strong>SLAVE_STATE_WAIT_BGSAVE_START</strong>，那么调用 <strong>startBgsaveForReplication</strong> 函数，开始一次新的 bgsave。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</span><br><span class="line">    startbgsave = <span class="number">1</span>;</span><br><span class="line">    mincapa = (mincapa == <span class="number">-1</span>) ? slave-&gt;slave_capa :</span><br><span class="line">                                (mincapa &amp; slave-&gt;slave_capa);</span><br></pre></td></tr></table></figure><p>如果 slave 的复制状态处于 <strong>SLAVE_STATE_WAIT_BGSAVE_END</strong>，说明该 slave 正在等待 rdb 数据处理完成，此时需要根据有无磁盘化复制，区别对待处理。</p><h3 id="无磁盘复制"><a href="#无磁盘复制" class="headerlink" title="无磁盘复制"></a>无磁盘复制</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (type == RDB_CHILD_TYPE_SOCKET) &#123;</span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">        <span class="string">"Streamed RDB transfer with slave %s succeeded (socket). Waiting for REPLCONF ACK from slave to enable streaming"</span>,</span><br><span class="line">            replicationGetSlaveName(slave));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note: we wait for a REPLCONF ACK message from slave in</span></span><br><span class="line"><span class="comment">     * order to really put it online (install the write handler</span></span><br><span class="line"><span class="comment">     * so that the accumulated data can be transfered). However</span></span><br><span class="line"><span class="comment">     * we change the replication state ASAP, since our slave</span></span><br><span class="line"><span class="comment">     * is technically online now. */</span></span><br><span class="line">    slave-&gt;replstate = SLAVE_STATE_ONLINE;</span><br><span class="line">    slave-&gt;repl_put_online_on_ack = <span class="number">1</span>;</span><br><span class="line">    slave-&gt;repl_ack_time = server.unixtime; <span class="comment">/* Timeout otherwise. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 slave 的复制状态置为 <strong>SLAVE_STATE_ONLINE</strong>，属性 <strong>repl_put_online_on_ack</strong> 置为 1。<br>⚠ <strong>注意</strong>，在收到该 slave 第一个 <code>replconf ack &lt;offset&gt;</code> 命令之后，master 才真正调用 <strong>putSlaveOnline</strong> 函数将该 slave置为 <strong>REDIS_REPL_ONLINE</strong> 状态，并且开始发送缓存的命令流。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replconfCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">"ack"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* REPLCONF ACK is used by slave to inform the master the amount</span></span><br><span class="line"><span class="comment">         * of replication stream that it processed so far. It is an</span></span><br><span class="line"><span class="comment">         * internal only command that normal clients should never use. */</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> offset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_SLAVE)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> ((getLongLongFromObject(c-&gt;argv[j+<span class="number">1</span>], &amp;offset) != C_OK))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (offset &gt; c-&gt;repl_ack_off)</span><br><span class="line">            c-&gt;repl_ack_off = offset;</span><br><span class="line">        c-&gt;repl_ack_time = server.unixtime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If this was a diskless replication, we need to really put</span></span><br><span class="line"><span class="comment">         * the slave online when the first ACK is received (which</span></span><br><span class="line"><span class="comment">         * confirms slave is online and ready to get more data). */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;repl_put_online_on_ack &amp;&amp; c-&gt;replstate == SLAVE_STATE_ONLINE)</span><br><span class="line">            putSlaveOnline(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note: this command does not reply anything! */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以这样设计，与这两种复制方式有关。</p><p>当使用<strong>有磁盘复制</strong>方式时，master 会先把 rdb 数据的长度以 <code>$&lt;len&gt;/r/n</code> 的格式发送给 slave，slave 在解析到 len 后，从 socket 中读取到特定长度的 rdb 数据。<br>当使用<strong>无磁盘复制</strong>方式时，master 预先无法获知 rdb 数据的长度，那 slave 如何判断 rdb 数据是否读完了呢？在发送 rdb 数据之前，master 会先以 <code>$EOF:&lt;40 bytes delimiter&gt;</code> 的格式发送一个 40 字节的魔数，当 rdb 数据发送完后，再次发送这个魔数，这样 slave 就可以检测到 rdb 数据发送结束了。</p><p>如果 master 发送完 rdb 数据后，直接将 slave 状态置为 <strong>SLAVE_STATE_ONLINE</strong> ，接着发送缓存的命令流。<br>当采用<strong>无磁盘复制</strong>方式时，slave 最后读到的数据很有可能包含了命令流数据。因此，需要等到 slave 发送的第一个 <code>replconf ack &lt;offset&gt;</code> 命令之后，master 再把 slave 状态置为 <strong>SLAVE_STATE_ONLINE</strong>。</p><p>可以参考作者的解释 <a href="https://github.com/antirez/redis/commit/bb7fea0d5ca7b3a53532338e8654e409014c1194" target="_blank" rel="noopener">https://github.com/antirez/redis/commit/bb7fea0d5ca7b3a53532338e8654e409014c1194</a>。</p><h3 id="有磁盘复制"><a href="#有磁盘复制" class="headerlink" title="有磁盘复制"></a>有磁盘复制</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bgsaveerr != C_OK) &#123;</span><br><span class="line">    freeClient(slave);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"SYNC failed. BGSAVE child returned an error"</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((slave-&gt;repldbfd = <span class="built_in">open</span>(server.rdb_filename,O_RDONLY)) == <span class="number">-1</span> ||</span><br><span class="line">    redis_fstat(slave-&gt;repldbfd,&amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">    freeClient(slave);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"SYNC failed. Can't open/stat DB after BGSAVE: %s"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slave-&gt;repldboff = <span class="number">0</span>;</span><br><span class="line">slave-&gt;repldbsize = buf.st_size;</span><br><span class="line">slave-&gt;replstate = SLAVE_STATE_SEND_BULK;</span><br><span class="line">slave-&gt;replpreamble = sdscatprintf(sdsempty(),<span class="string">"$%lld\r\n"</span>,</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) slave-&gt;repldbsize);</span><br><span class="line"></span><br><span class="line">aeDeleteFileEvent(server.el,slave-&gt;fd,AE_WRITABLE);</span><br><span class="line"><span class="keyword">if</span> (aeCreateFileEvent(server.el, slave-&gt;fd, AE_WRITABLE, sendBulkToSlave, slave) == AE_ERR) &#123;</span><br><span class="line">    freeClient(slave);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果前面做 bgsave 出错了，那么这里会释放掉 client。<br>否则，打开生成的 rdb 文件，将 fd 保存到 <strong>repldbfd</strong> 属性中，状态置为 <strong>SLAVE_STATE_SEND_BULK</strong>，这表示要把 rdb 数据发送给 slave 了，将 rdb 大小写入 <strong>replpreamble</strong> 属性。<br>重新注册 slave 上的写事件，回调函数为 <strong>sendBulkToSlave</strong>，该函数做以下分析，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Before sending the RDB file, we send the preamble as configured by the</span></span><br><span class="line"><span class="comment"> * replication process. Currently the preamble is just the bulk count of</span></span><br><span class="line"><span class="comment"> * the file in the form "$&lt;length&gt;\r\n". */</span></span><br><span class="line"><span class="keyword">if</span> (slave-&gt;replpreamble) &#123;</span><br><span class="line">    nwritten = <span class="built_in">write</span>(fd,slave-&gt;replpreamble,sdslen(slave-&gt;replpreamble));</span><br><span class="line">    <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_VERBOSE,<span class="string">"Write error sending RDB preamble to slave: %s"</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        freeClient(slave);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    server.stat_net_output_bytes += nwritten;</span><br><span class="line">    sdsrange(slave-&gt;replpreamble,nwritten,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sdslen(slave-&gt;replpreamble) == <span class="number">0</span>) &#123;</span><br><span class="line">        sdsfree(slave-&gt;replpreamble);</span><br><span class="line">        slave-&gt;replpreamble = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">/* fall through sending data. */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <strong>replpreamble</strong> 属性不为空，说明是第一次触发该回调，那么先把这个 rdb 数据的长度信息发送给 slave。<br>否则，进入发送实际 rdb 数据阶段。从 rdb 文件中读取数据，然后发送给 slave，代码中使用 repldboff 属性记录累积发送过多少数据。<br>默认一次发送的数据量为 <strong>PROTO_IOBUF_LEN</strong>，大小为 16K。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* If the preamble was already transfered, send the RDB bulk data. */</span></span><br><span class="line">lseek(slave-&gt;repldbfd,slave-&gt;repldboff,SEEK_SET);</span><br><span class="line">buflen = <span class="built_in">read</span>(slave-&gt;repldbfd,buf,PROTO_IOBUF_LEN); <span class="comment">// 读 16k 数据</span></span><br><span class="line"><span class="keyword">if</span> (buflen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Read error sending DB to slave: %s"</span>,</span><br><span class="line">        (buflen == <span class="number">0</span>) ? <span class="string">"premature EOF"</span> : strerror(errno));</span><br><span class="line">    freeClient(slave);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((nwritten = <span class="built_in">write</span>(fd,buf,buflen)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Write error sending DB to slave: %s"</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        freeClient(slave);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">slave-&gt;repldboff += nwritten;</span><br><span class="line">server.stat_net_output_bytes += nwritten;</span><br></pre></td></tr></table></figure><p>当 rdb 数据完全发送完以后，关闭 rdb 文件 fd，删除 fd 的写事件，重置 repldbfd。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (slave-&gt;repldboff == slave-&gt;repldbsize) &#123; <span class="comment">// 发送完 rdb 文件，删除可读事件</span></span><br><span class="line">    <span class="built_in">close</span>(slave-&gt;repldbfd);</span><br><span class="line">    slave-&gt;repldbfd = <span class="number">-1</span>;</span><br><span class="line">    aeDeleteFileEvent(server.el,slave-&gt;fd,AE_WRITABLE);</span><br><span class="line">    putSlaveOnline(slave);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用 <strong>putSlaveOnline</strong> 函数，将 slave 的复制状态置为 <strong>SLAVE_STATE_ONLINE</strong>，重新注册 fd 的写事件，回调函数为 <strong>sendReplyToClient</strong>，向 slave 发送累积的命令流。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putSlaveOnline</span><span class="params">(client *slave)</span> </span>&#123;</span><br><span class="line">    slave-&gt;replstate = SLAVE_STATE_ONLINE;</span><br><span class="line">    slave-&gt;repl_put_online_on_ack = <span class="number">0</span>;</span><br><span class="line">    slave-&gt;repl_ack_time = server.unixtime; <span class="comment">/* Prevent false timeout. */</span></span><br><span class="line">    <span class="keyword">if</span> (aeCreateFileEvent(server.el, slave-&gt;fd, AE_WRITABLE,</span><br><span class="line">        sendReplyToClient, slave) == AE_ERR) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Unable to register writable event for slave bulk transfer: %s"</span>, strerror(errno));</span><br><span class="line">        freeClient(slave);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    refreshGoodSlavesCount();</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"Synchronization with slave %s succeeded"</span>,</span><br><span class="line">        replicationGetSlaveName(slave));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置 slave 属性 <strong>repl_put_online_on_ack ** 为 0，表示该 **slave 已完成初始同步，接下来进入命令传播阶段</strong>。<br>最后，调用 <strong>refreshGoodSlavesCount</strong> 函数，更新当前状态正常的 slave 数量。</p><hr><p>到此，主从复制过程中 master 的逻辑就已经讲完了。</p></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="social-share" data-disabled="google,facebook,qzone,twitter,diandian,linkedin,qzone,tencent"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="next-post pull-right"><a href="/968a029a.html"><span>Redis 源码之主从复制(3)</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg1MS8xMzM4Nw"><script>!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script></div></div></div><footer class="footer-bg" style="background-image:url(https://s2.ax1x.com/2019/11/17/Mr5txK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;&nbsp;2016 - 2019 By Happen</div><div class="framework-info"><span>Powered by</span> <a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>